!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).ML={})}(this,(function(exports){"use strict";const toString$1=Object.prototype.toString;function isAnyArray(t){return toString$1.call(t).endsWith("Array]")}function max(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!isAnyArray(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,n=void 0===r?0:r,i=e.toIndex,o=void 0===i?t.length:i;if(n<0||n>=t.length||!Number.isInteger(n))throw new Error("fromIndex must be a positive integer smaller than length");if(o<=n||o>t.length||!Number.isInteger(o))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var s=t[n],a=n+1;a<o;a++)t[a]>s&&(s=t[a]);return s}function min(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!isAnyArray(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,n=void 0===r?0:r,i=e.toIndex,o=void 0===i?t.length:i;if(n<0||n>=t.length||!Number.isInteger(n))throw new Error("fromIndex must be a positive integer smaller than length");if(o<=n||o>t.length||!Number.isInteger(o))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var s=t[n],a=n+1;a<o;a++)t[a]<s&&(s=t[a]);return s}function rescale(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!isAnyArray(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");if(void 0!==r.output){if(!isAnyArray(r.output))throw new TypeError("output option must be an array if specified");e=r.output}else e=new Array(t.length);var n=min(t),i=max(t);if(n===i)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var o=r.min,s=void 0===o?r.autoMinMax?n:0:o,a=r.max,l=void 0===a?r.autoMinMax?i:1:a;if(s>=l)throw new RangeError("min option must be smaller than max option");for(var h=(l-s)/(i-n),u=0;u<t.length;u++)e[u]=(t[u]-n)*h+s;return e}const indent=" ".repeat(2),indentData=" ".repeat(4);function inspectMatrix(){return inspectMatrixWithOptions(this)}function inspectMatrixWithOptions(t,e={}){const{maxRows:r=15,maxColumns:n=10,maxNumSize:i=8}=e;return`${t.constructor.name} {\n${indent}[\n${indentData}${inspectData(t,r,n,i)}\n${indent}]\n${indent}rows: ${t.rows}\n${indent}columns: ${t.columns}\n}`}function inspectData(t,e,r,n){const{rows:i,columns:o}=t,s=Math.min(i,e),a=Math.min(o,r),l=[];for(let e=0;e<s;e++){let r=[];for(let i=0;i<a;i++)r.push(formatNumber(t.get(e,i),n));l.push(`${r.join(" ")}`)}return a!==o&&(l[l.length-1]+=` ... ${o-r} more columns`),s!==i&&l.push(`... ${i-e} more rows`),l.join(`\n${indentData}`)}function formatNumber(t,e){const r=String(t);if(r.length<=e)return r.padEnd(e," ");const n=t.toPrecision(e-2);if(n.length<=e)return n;const i=t.toExponential(e-2),o=i.indexOf("e"),s=i.slice(o);return i.slice(0,e-s.length)+s}function installMathOperations(t,e){t.prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},t.prototype.addS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t);return this},t.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t.get(e,r));return this},t.add=function(t,r){return new e(t).add(r)},t.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},t.prototype.subS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t);return this},t.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t.get(e,r));return this},t.sub=function(t,r){return new e(t).sub(r)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},t.prototype.mulS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this},t.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t.get(e,r));return this},t.mul=function(t,r){return new e(t).mul(r)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},t.prototype.divS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t);return this},t.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t.get(e,r));return this},t.div=function(t,r){return new e(t).div(r)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},t.prototype.modS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t);return this},t.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t.get(e,r));return this},t.mod=function(t,r){return new e(t).mod(r)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},t.prototype.andS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t);return this},t.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t.get(e,r));return this},t.and=function(t,r){return new e(t).and(r)},t.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},t.prototype.orS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t);return this},t.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t.get(e,r));return this},t.or=function(t,r){return new e(t).or(r)},t.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},t.prototype.xorS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t);return this},t.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t.get(e,r));return this},t.xor=function(t,r){return new e(t).xor(r)},t.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},t.prototype.leftShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t);return this},t.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t.get(e,r));return this},t.leftShift=function(t,r){return new e(t).leftShift(r)},t.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},t.prototype.signPropagatingRightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t);return this},t.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t.get(e,r));return this},t.signPropagatingRightShift=function(t,r){return new e(t).signPropagatingRightShift(r)},t.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},t.prototype.rightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t);return this},t.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t.get(e,r));return this},t.rightShift=function(t,r){return new e(t).rightShift(r)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},t.not=function(t){return new e(t).not()},t.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},t.abs=function(t){return new e(t).abs()},t.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},t.acos=function(t){return new e(t).acos()},t.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},t.acosh=function(t){return new e(t).acosh()},t.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},t.asin=function(t){return new e(t).asin()},t.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},t.asinh=function(t){return new e(t).asinh()},t.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},t.atan=function(t){return new e(t).atan()},t.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},t.atanh=function(t){return new e(t).atanh()},t.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},t.cbrt=function(t){return new e(t).cbrt()},t.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},t.ceil=function(t){return new e(t).ceil()},t.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},t.clz32=function(t){return new e(t).clz32()},t.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},t.cos=function(t){return new e(t).cos()},t.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},t.cosh=function(t){return new e(t).cosh()},t.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},t.exp=function(t){return new e(t).exp()},t.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},t.expm1=function(t){return new e(t).expm1()},t.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},t.floor=function(t){return new e(t).floor()},t.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},t.fround=function(t){return new e(t).fround()},t.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},t.log=function(t){return new e(t).log()},t.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},t.log1p=function(t){return new e(t).log1p()},t.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},t.log10=function(t){return new e(t).log10()},t.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},t.log2=function(t){return new e(t).log2()},t.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},t.round=function(t){return new e(t).round()},t.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},t.sign=function(t){return new e(t).sign()},t.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},t.sin=function(t){return new e(t).sin()},t.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},t.sinh=function(t){return new e(t).sinh()},t.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},t.sqrt=function(t){return new e(t).sqrt()},t.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},t.tan=function(t){return new e(t).tan()},t.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},t.tanh=function(t){return new e(t).tanh()},t.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},t.trunc=function(t){return new e(t).trunc()},t.pow=function(t,r){return new e(t).pow(r)},t.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},t.prototype.powS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t));return this},t.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t.get(e,r)));return this}}function checkRowIndex(t,e,r){let n=r?t.rows:t.rows-1;if(e<0||e>n)throw new RangeError("Row index out of range")}function checkColumnIndex(t,e,r){let n=r?t.columns:t.columns-1;if(e<0||e>n)throw new RangeError("Column index out of range")}function checkRowVector(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function checkColumnVector(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function checkIndices(t,e,r){return{row:checkRowIndices(t,e),column:checkColumnIndices(t,r)}}function checkRowIndices(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for row indices");if(e.some((e=>e<0||e>=t.rows)))throw new RangeError("row indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function checkColumnIndices(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for column indices");if(e.some((e=>e<0||e>=t.columns)))throw new RangeError("column indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function checkRange(t,e,r,n,i){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(checkNumber("startRow",e),checkNumber("endRow",r),checkNumber("startColumn",n),checkNumber("endColumn",i),e>r||n>i||e<0||e>=t.rows||r<0||r>=t.rows||n<0||n>=t.columns||i<0||i>=t.columns)throw new RangeError("Submatrix indices are out of range")}function newArray$1(t,e=0){let r=[];for(let n=0;n<t;n++)r.push(e);return r}function checkNumber(t,e){if("number"!=typeof e)throw new TypeError(`${t} must be a number`)}function checkNonEmpty(t){if(t.isEmpty())throw new Error("Empty matrix has no elements to index")}function sumByRow(t){let e=newArray$1(t.rows);for(let r=0;r<t.rows;++r)for(let n=0;n<t.columns;++n)e[r]+=t.get(r,n);return e}function sumByColumn(t){let e=newArray$1(t.columns);for(let r=0;r<t.rows;++r)for(let n=0;n<t.columns;++n)e[n]+=t.get(r,n);return e}function sumAll(t){let e=0;for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)e+=t.get(r,n);return e}function productByRow(t){let e=newArray$1(t.rows,1);for(let r=0;r<t.rows;++r)for(let n=0;n<t.columns;++n)e[r]*=t.get(r,n);return e}function productByColumn(t){let e=newArray$1(t.columns,1);for(let r=0;r<t.rows;++r)for(let n=0;n<t.columns;++n)e[n]*=t.get(r,n);return e}function productAll(t){let e=1;for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)e*=t.get(r,n);return e}function varianceByRow(t,e,r){const n=t.rows,i=t.columns,o=[];for(let s=0;s<n;s++){let n=0,a=0,l=0;for(let e=0;e<i;e++)l=t.get(s,e)-r[s],n+=l,a+=l*l;e?o.push((a-n*n/i)/(i-1)):o.push((a-n*n/i)/i)}return o}function varianceByColumn(t,e,r){const n=t.rows,i=t.columns,o=[];for(let s=0;s<i;s++){let i=0,a=0,l=0;for(let e=0;e<n;e++)l=t.get(e,s)-r[s],i+=l,a+=l*l;e?o.push((a-i*i/n)/(n-1)):o.push((a-i*i/n)/n)}return o}function varianceAll(t,e,r){const n=t.rows,i=t.columns,o=n*i;let s=0,a=0,l=0;for(let e=0;e<n;e++)for(let n=0;n<i;n++)l=t.get(e,n)-r,s+=l,a+=l*l;return e?(a-s*s/o)/(o-1):(a-s*s/o)/o}function centerByRow(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)-e[r])}function centerByColumn(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)-e[n])}function centerAll(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)-e)}function getScaleByRow(t){const e=[];for(let r=0;r<t.rows;r++){let n=0;for(let e=0;e<t.columns;e++)n+=Math.pow(t.get(r,e),2)/(t.columns-1);e.push(Math.sqrt(n))}return e}function scaleByRow(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)/e[r])}function getScaleByColumn(t){const e=[];for(let r=0;r<t.columns;r++){let n=0;for(let e=0;e<t.rows;e++)n+=Math.pow(t.get(e,r),2)/(t.rows-1);e.push(Math.sqrt(n))}return e}function scaleByColumn(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)/e[n])}function getScaleAll(t){const e=t.size-1;let r=0;for(let n=0;n<t.columns;n++)for(let i=0;i<t.rows;i++)r+=Math.pow(t.get(i,n),2)/e;return Math.sqrt(r)}function scaleAll(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)/e)}class AbstractMatrix{static from1DArray(t,e,r){if(t*e!==r.length)throw new RangeError("data length does not match given dimensions");let n=new Matrix$2(t,e);for(let i=0;i<t;i++)for(let t=0;t<e;t++)n.set(i,t,r[i*e+t]);return n}static rowVector(t){let e=new Matrix$2(1,t.length);for(let r=0;r<t.length;r++)e.set(0,r,t[r]);return e}static columnVector(t){let e=new Matrix$2(t.length,1);for(let r=0;r<t.length;r++)e.set(r,0,t[r]);return e}static zeros(t,e){return new Matrix$2(t,e)}static ones(t,e){return new Matrix$2(t,e).fill(1)}static rand(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{random:n=Math.random}=r;let i=new Matrix$2(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++)i.set(r,t,n());return i}static randInt(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{min:n=0,max:i=1e3,random:o=Math.random}=r;if(!Number.isInteger(n))throw new TypeError("min must be an integer");if(!Number.isInteger(i))throw new TypeError("max must be an integer");if(n>=i)throw new RangeError("min must be smaller than max");let s=i-n,a=new Matrix$2(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++){let e=n+Math.round(o()*s);a.set(r,t,e)}return a}static eye(t,e,r){void 0===e&&(e=t),void 0===r&&(r=1);let n=Math.min(t,e),i=this.zeros(t,e);for(let t=0;t<n;t++)i.set(t,t,r);return i}static diag(t,e,r){let n=t.length;void 0===e&&(e=n),void 0===r&&(r=e);let i=Math.min(n,e,r),o=this.zeros(e,r);for(let e=0;e<i;e++)o.set(e,e,t[e]);return o}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,n=t.columns,i=new Matrix$2(r,n);for(let o=0;o<r;o++)for(let r=0;r<n;r++)i.set(o,r,Math.min(t.get(o,r),e.get(o,r)));return i}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,n=t.columns,i=new this(r,n);for(let o=0;o<r;o++)for(let r=0;r<n;r++)i.set(o,r,Math.max(t.get(o,r),e.get(o,r)));return i}static checkMatrix(t){return AbstractMatrix.isMatrix(t)?t:new Matrix$2(t)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.call(this,e,r);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let r=0;r<this.columns;r++)t[e].push(this.get(e,r))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isEmpty(){return 0===this.rows||0===this.columns}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,r=-1,n=!0,i=!1;for(;t<this.rows&&n;){for(e=0,i=!1;e<this.columns&&!1===i;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(i=!0,r=e):(n=!1,i=!0);t++}return n}isReducedEchelonForm(){let t=0,e=0,r=-1,n=!0,i=!1;for(;t<this.rows&&n;){for(e=0,i=!1;e<this.columns&&!1===i;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(i=!0,r=e):(n=!1,i=!0);for(let r=e+1;r<this.rows;r++)0!==this.get(t,r)&&(n=!1);t++}return n}echelonForm(){let t=this.clone(),e=0,r=0;for(;e<t.rows&&r<t.columns;){let n=e;for(let i=e;i<t.rows;i++)t.get(i,r)>t.get(n,r)&&(n=i);if(0===t.get(n,r))r++;else{t.swapRows(e,n);let i=t.get(e,r);for(let n=r;n<t.columns;n++)t.set(e,n,t.get(e,n)/i);for(let n=e+1;n<t.rows;n++){let i=t.get(n,r)/t.get(e,r);t.set(n,r,0);for(let o=r+1;o<t.columns;o++)t.set(n,o,t.get(n,o)-t.get(e,o)*i)}e++,r++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,r=t.rows,n=r-1;for(;n>=0;)if(0===t.maxRow(n))n--;else{let i=0,o=!1;for(;i<r&&!1===o;)1===t.get(n,i)?o=!0:i++;for(let r=0;r<n;r++){let o=t.get(r,i);for(let s=i;s<e;s++){let e=t.get(r,s)-o*t.get(n,s);t.set(r,s,e)}}n--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:r=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let n=new Matrix$2(this.rows*e,this.columns*r);for(let t=0;t<e;t++)for(let e=0;e<r;e++)n.setSubMatrix(this,this.rows*t,this.columns*e);return n}fill(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,t);return this}neg(){return this.mulS(-1)}getRow(t){checkRowIndex(this,t);let e=[];for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}getRowVector(t){return Matrix$2.rowVector(this.getRow(t))}setRow(t,e){checkRowIndex(this,t),e=checkRowVector(this,e);for(let r=0;r<this.columns;r++)this.set(t,r,e[r]);return this}swapRows(t,e){checkRowIndex(this,t),checkRowIndex(this,e);for(let r=0;r<this.columns;r++){let n=this.get(t,r);this.set(t,r,this.get(e,r)),this.set(e,r,n)}return this}getColumn(t){checkColumnIndex(this,t);let e=[];for(let r=0;r<this.rows;r++)e.push(this.get(r,t));return e}getColumnVector(t){return Matrix$2.columnVector(this.getColumn(t))}setColumn(t,e){checkColumnIndex(this,t),e=checkColumnVector(this,e);for(let r=0;r<this.rows;r++)this.set(r,t,e[r]);return this}swapColumns(t,e){checkColumnIndex(this,t),checkColumnIndex(this,e);for(let r=0;r<this.rows;r++){let n=this.get(r,t);this.set(r,t,this.get(r,e)),this.set(r,e,n)}return this}addRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[r]);return this}subRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[r]);return this}mulRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[r]);return this}divRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[r]);return this}addColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[e]);return this}subColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[e]);return this}mulColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[e]);return this}divColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[e]);return this}mulRow(t,e){checkRowIndex(this,t);for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e);return this}mulColumn(t,e){checkColumnIndex(this,t);for(let r=0;r<this.rows;r++)this.set(r,t,this.get(r,t)*e);return this}max(){if(this.isEmpty())return NaN;let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}maxIndex(){checkNonEmpty(this);let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let n=0;n<this.columns;n++)this.get(r,n)>t&&(t=this.get(r,n),e[0]=r,e[1]=n);return e}min(){if(this.isEmpty())return NaN;let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}minIndex(){checkNonEmpty(this);let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let n=0;n<this.columns;n++)this.get(r,n)<t&&(t=this.get(r,n),e[0]=r,e[1]=n);return e}maxRow(t){if(checkRowIndex(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)>e&&(e=this.get(t,r));return e}maxRowIndex(t){checkRowIndex(this,t),checkNonEmpty(this);let e=this.get(t,0),r=[t,0];for(let n=1;n<this.columns;n++)this.get(t,n)>e&&(e=this.get(t,n),r[1]=n);return r}minRow(t){if(checkRowIndex(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)<e&&(e=this.get(t,r));return e}minRowIndex(t){checkRowIndex(this,t),checkNonEmpty(this);let e=this.get(t,0),r=[t,0];for(let n=1;n<this.columns;n++)this.get(t,n)<e&&(e=this.get(t,n),r[1]=n);return r}maxColumn(t){if(checkColumnIndex(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)>e&&(e=this.get(r,t));return e}maxColumnIndex(t){checkColumnIndex(this,t),checkNonEmpty(this);let e=this.get(0,t),r=[0,t];for(let n=1;n<this.rows;n++)this.get(n,t)>e&&(e=this.get(n,t),r[0]=n);return r}minColumn(t){if(checkColumnIndex(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)<e&&(e=this.get(r,t));return e}minColumnIndex(t){checkColumnIndex(this,t),checkNonEmpty(this);let e=this.get(0,t),r=[0,t];for(let n=1;n<this.rows;n++)this.get(n,t)<e&&(e=this.get(n,t),r[0]=n);return r}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let r=0;r<t;r++)e.push(this.get(r,r));return e}norm(t="frobenius"){let e=0;if("max"===t)return this.max();if("frobenius"===t){for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e+=this.get(t,r)*this.get(t,r);return Math.sqrt(e)}throw new RangeError(`unknown norm type: ${t}`)}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t+=this.get(e,r),this.set(e,r,t);return this}dot(t){AbstractMatrix.isMatrix(t)&&(t=t.to1DArray());let e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");let r=0;for(let n=0;n<e.length;n++)r+=e[n]*t[n];return r}mmul(t){t=Matrix$2.checkMatrix(t);let e=this.rows,r=this.columns,n=t.columns,i=new Matrix$2(e,n),o=new Float64Array(r);for(let s=0;s<n;s++){for(let e=0;e<r;e++)o[e]=t.get(e,s);for(let t=0;t<e;t++){let e=0;for(let n=0;n<r;n++)e+=this.get(t,n)*o[n];i.set(t,s,e)}}return i}strassen2x2(t){t=Matrix$2.checkMatrix(t);let e=new Matrix$2(2,2);const r=this.get(0,0),n=t.get(0,0),i=this.get(0,1),o=t.get(0,1),s=this.get(1,0),a=t.get(1,0),l=this.get(1,1),h=t.get(1,1),u=(r+l)*(n+h),c=(s+l)*n,f=r*(o-h),m=l*(a-n),g=(r+i)*h,d=u+m-g+(i-l)*(a+h),p=f+g,w=c+m,x=u-c+f+(s-r)*(n+o);return e.set(0,0,d),e.set(0,1,p),e.set(1,0,w),e.set(1,1,x),e}strassen3x3(t){t=Matrix$2.checkMatrix(t);let e=new Matrix$2(3,3);const r=this.get(0,0),n=this.get(0,1),i=this.get(0,2),o=this.get(1,0),s=this.get(1,1),a=this.get(1,2),l=this.get(2,0),h=this.get(2,1),u=this.get(2,2),c=t.get(0,0),f=t.get(0,1),m=t.get(0,2),g=t.get(1,0),d=t.get(1,1),p=t.get(1,2),w=t.get(2,0),x=t.get(2,1),y=t.get(2,2),M=(r-o)*(-f+d),v=(-r+o+s)*(c-f+d),b=(o+s)*(-c+f),S=r*c,A=(-r+l+h)*(c-m+p),E=(-r+l)*(m-p),R=(l+h)*(-c+m),N=(-i+h+u)*(d+w-x),$=(i-u)*(d-x),k=i*w,T=(h+u)*(-w+x),C=(-i+s+a)*(p+w-y),O=(i-a)*(p-y),I=(s+a)*(-w+y),F=S+k+n*g,L=(r+n+i-o-s-h-u)*d+v+b+S+N+k+T,P=S+A+R+(r+n+i-s-a-l-h)*p+k+C+I,D=M+s*(-c+f+g-d-p-w+y)+v+S+k+C+O,_=M+v+b+S+a*x,V=k+C+O+I+o*m,z=S+A+E+h*(-c+m+g-d-p-w+x)+N+$+k,q=N+$+k+T+l*f,B=S+A+E+R+u*y;return e.set(0,0,F),e.set(0,1,L),e.set(0,2,P),e.set(1,0,D),e.set(1,1,_),e.set(1,2,V),e.set(2,0,z),e.set(2,1,q),e.set(2,2,B),e}mmulStrassen(t){t=Matrix$2.checkMatrix(t);let e=this.clone(),r=e.rows,n=e.columns,i=t.rows,o=t.columns;function s(t,e,r){let n=t.rows,i=t.columns;if(n===e&&i===r)return t;{let n=AbstractMatrix.zeros(e,r);return n=n.setSubMatrix(t,0,0),n}}n!==i&&console.warn(`Multiplying ${r} x ${n} and ${i} x ${o} matrix: dimensions do not match.`);let a=Math.max(r,i),l=Math.max(n,o);return e=s(e,a,l),function t(e,r,n,i){if(n<=512||i<=512)return e.mmul(r);n%2==1&&i%2==1?(e=s(e,n+1,i+1),r=s(r,n+1,i+1)):n%2==1?(e=s(e,n+1,i),r=s(r,n+1,i)):i%2==1&&(e=s(e,n,i+1),r=s(r,n,i+1));let o=parseInt(e.rows/2,10),a=parseInt(e.columns/2,10),l=e.subMatrix(0,o-1,0,a-1),h=r.subMatrix(0,o-1,0,a-1),u=e.subMatrix(0,o-1,a,e.columns-1),c=r.subMatrix(0,o-1,a,r.columns-1),f=e.subMatrix(o,e.rows-1,0,a-1),m=r.subMatrix(o,r.rows-1,0,a-1),g=e.subMatrix(o,e.rows-1,a,e.columns-1),d=r.subMatrix(o,r.rows-1,a,r.columns-1),p=t(AbstractMatrix.add(l,g),AbstractMatrix.add(h,d),o,a),w=t(AbstractMatrix.add(f,g),h,o,a),x=t(l,AbstractMatrix.sub(c,d),o,a),y=t(g,AbstractMatrix.sub(m,h),o,a),M=t(AbstractMatrix.add(l,u),d,o,a),v=t(AbstractMatrix.sub(f,l),AbstractMatrix.add(h,c),o,a),b=t(AbstractMatrix.sub(u,g),AbstractMatrix.add(m,d),o,a),S=AbstractMatrix.add(p,y);S.sub(M),S.add(b);let A=AbstractMatrix.add(x,M),E=AbstractMatrix.add(w,y),R=AbstractMatrix.sub(p,w);R.add(x),R.add(v);let N=AbstractMatrix.zeros(2*S.rows,2*S.columns);return N=N.setSubMatrix(S,0,0),N=N.setSubMatrix(A,S.rows,0),N=N.setSubMatrix(E,0,S.columns),N=N.setSubMatrix(R,S.rows,S.columns),N.subMatrix(0,n-1,0,i-1)}(e,t=s(t,a,l),a,l)}scaleRows(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let n=new Matrix$2(this.rows,this.columns);for(let t=0;t<this.rows;t++){const i=this.getRow(t);i.length>0&&rescale(i,{min:e,max:r,output:i}),n.setRow(t,i)}return n}scaleColumns(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let n=new Matrix$2(this.rows,this.columns);for(let t=0;t<this.columns;t++){const i=this.getColumn(t);i.length&&rescale(i,{min:e,max:r,output:i}),n.setColumn(t,i)}return n}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let r=0;r<t;r++){let t=this.get(e,r),n=this.get(e,this.columns-1-r);this.set(e,r,n),this.set(e,this.columns-1-r,t)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let r=0;r<t;r++){let t=this.get(r,e),n=this.get(this.rows-1-r,e);this.set(r,e,n),this.set(this.rows-1-r,e,t)}return this}kroneckerProduct(t){t=Matrix$2.checkMatrix(t);let e=this.rows,r=this.columns,n=t.rows,i=t.columns,o=new Matrix$2(e*n,r*i);for(let s=0;s<e;s++)for(let e=0;e<r;e++)for(let r=0;r<n;r++)for(let a=0;a<i;a++)o.set(n*s+r,i*e+a,this.get(s,e)*t.get(r,a));return o}kroneckerSum(t){if(t=Matrix$2.checkMatrix(t),!this.isSquare()||!t.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let e=this.rows,r=t.rows,n=this.kroneckerProduct(Matrix$2.eye(r,r)),i=Matrix$2.eye(e,e).kroneckerProduct(t);return n.add(i)}transpose(){let t=new Matrix$2(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(r,e,this.get(e,r));return t}sortRows(t=compareNumbers){for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(t=compareNumbers){for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,r,n){checkRange(this,t,e,r,n);let i=new Matrix$2(e-t+1,n-r+1);for(let o=t;o<=e;o++)for(let e=r;e<=n;e++)i.set(o-t,e-r,this.get(o,e));return i}subMatrixRow(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.columns-1),e>r||e<0||e>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let n=new Matrix$2(t.length,r-e+1);for(let i=0;i<t.length;i++)for(let o=e;o<=r;o++){if(t[i]<0||t[i]>=this.rows)throw new RangeError(`Row index out of range: ${t[i]}`);n.set(i,o-e,this.get(t[i],o))}return n}subMatrixColumn(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.rows-1),e>r||e<0||e>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let n=new Matrix$2(r-e+1,t.length);for(let i=0;i<t.length;i++)for(let o=e;o<=r;o++){if(t[i]<0||t[i]>=this.columns)throw new RangeError(`Column index out of range: ${t[i]}`);n.set(o-e,i,this.get(o,t[i]))}return n}setSubMatrix(t,e,r){if((t=Matrix$2.checkMatrix(t)).isEmpty())return this;checkRange(this,e,e+t.rows-1,r,r+t.columns-1);for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)this.set(e+n,r+i,t.get(n,i));return this}selection(t,e){let r=checkIndices(this,t,e),n=new Matrix$2(t.length,e.length);for(let t=0;t<r.row.length;t++){let e=r.row[t];for(let i=0;i<r.column.length;i++){let o=r.column[i];n.set(t,i,this.get(e,o))}}return n}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let r=0;r<t;r++)e+=this.get(r,r);return e}clone(){let t=new Matrix$2(this.rows,this.columns);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(e,r,this.get(e,r));return t}sum(t){switch(t){case"row":return sumByRow(this);case"column":return sumByColumn(this);case void 0:return sumAll(this);default:throw new Error(`invalid option: ${t}`)}}product(t){switch(t){case"row":return productByRow(this);case"column":return productByColumn(this);case void 0:return productAll(this);default:throw new Error(`invalid option: ${t}`)}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error(`invalid option: ${t}`)}}variance(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:r=!0,mean:n=this.mean(t)}=e;if("boolean"!=typeof r)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!Array.isArray(n))throw new TypeError("mean must be an array");return varianceByRow(this,r,n);case"column":if(!Array.isArray(n))throw new TypeError("mean must be an array");return varianceByColumn(this,r,n);case void 0:if("number"!=typeof n)throw new TypeError("mean must be a number");return varianceAll(this,r,n);default:throw new Error(`invalid option: ${t}`)}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const r=this.variance(t,e);if(void 0===t)return Math.sqrt(r);for(let t=0;t<r.length;t++)r[t]=Math.sqrt(r[t]);return r}center(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:r=this.mean(t)}=e;switch(t){case"row":if(!Array.isArray(r))throw new TypeError("center must be an array");return centerByRow(this,r),this;case"column":if(!Array.isArray(r))throw new TypeError("center must be an array");return centerByColumn(this,r),this;case void 0:if("number"!=typeof r)throw new TypeError("center must be a number");return centerAll(this,r),this;default:throw new Error(`invalid option: ${t}`)}}scale(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let r=e.scale;switch(t){case"row":if(void 0===r)r=getScaleByRow(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return scaleByRow(this,r),this;case"column":if(void 0===r)r=getScaleByColumn(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return scaleByColumn(this,r),this;case void 0:if(void 0===r)r=getScaleAll(this);else if("number"!=typeof r)throw new TypeError("scale must be a number");return scaleAll(this,r),this;default:throw new Error(`invalid option: ${t}`)}}toString(t){return inspectMatrixWithOptions(this,t)}}function compareNumbers(t,e){return t-e}AbstractMatrix.prototype.klass="Matrix","undefined"!=typeof Symbol&&(AbstractMatrix.prototype[Symbol.for("nodejs.util.inspect.custom")]=inspectMatrix),AbstractMatrix.random=AbstractMatrix.rand,AbstractMatrix.randomInt=AbstractMatrix.randInt,AbstractMatrix.diagonal=AbstractMatrix.diag,AbstractMatrix.prototype.diagonal=AbstractMatrix.prototype.diag,AbstractMatrix.identity=AbstractMatrix.eye,AbstractMatrix.prototype.negate=AbstractMatrix.prototype.neg,AbstractMatrix.prototype.tensorProduct=AbstractMatrix.prototype.kroneckerProduct;class Matrix$2 extends AbstractMatrix{constructor(t,e){if(super(),Matrix$2.isMatrix(t))return t.clone();if(Number.isInteger(t)&&t>=0){if(this.data=[],!(Number.isInteger(e)&&e>=0))throw new TypeError("nColumns must be a positive integer");for(let r=0;r<t;r++)this.data.push(new Float64Array(e))}else{if(!Array.isArray(t))throw new TypeError("First argument must be a positive number or an array");{const r=t;if("number"!=typeof(e=(t=r.length)?r[0].length:0))throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let n=0;n<t;n++){if(r[n].length!==e)throw new RangeError("Inconsistent array dimensions");this.data.push(Float64Array.from(r[n]))}}}this.rows=t,this.columns=e}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}removeRow(t){return checkRowIndex(this,t),this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),checkRowIndex(this,t,!0),e=Float64Array.from(checkRowVector(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){checkColumnIndex(this,t);for(let e=0;e<this.rows;e++){const r=new Float64Array(this.columns-1);for(let n=0;n<t;n++)r[n]=this.data[e][n];for(let n=t+1;n<this.columns;n++)r[n-1]=this.data[e][n];this.data[e]=r}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),checkColumnIndex(this,t,!0),e=checkColumnVector(this,e);for(let r=0;r<this.rows;r++){const n=new Float64Array(this.columns+1);let i=0;for(;i<t;i++)n[i]=this.data[r][i];for(n[i++]=e[r];i<this.columns+1;i++)n[i]=this.data[r][i-1];this.data[r]=n}return this.columns+=1,this}}installMathOperations(AbstractMatrix,Matrix$2);class BaseView extends AbstractMatrix{constructor(t,e,r){super(),this.matrix=t,this.rows=e,this.columns=r}}class MatrixColumnView extends BaseView{constructor(t,e){checkColumnIndex(t,e),super(t,t.rows,1),this.column=e}set(t,e,r){return this.matrix.set(t,this.column,r),this}get(t){return this.matrix.get(t,this.column)}}class MatrixColumnSelectionView extends BaseView{constructor(t,e){e=checkColumnIndices(t,e),super(t,t.rows,e.length),this.columnIndices=e}set(t,e,r){return this.matrix.set(t,this.columnIndices[e],r),this}get(t,e){return this.matrix.get(t,this.columnIndices[e])}}class MatrixFlipColumnView extends BaseView{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(t,this.columns-e-1,r),this}get(t,e){return this.matrix.get(t,this.columns-e-1)}}class MatrixFlipRowView extends BaseView{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(this.rows-t-1,e,r),this}get(t,e){return this.matrix.get(this.rows-t-1,e)}}class MatrixRowView extends BaseView{constructor(t,e){checkRowIndex(t,e),super(t,1,t.columns),this.row=e}set(t,e,r){return this.matrix.set(this.row,e,r),this}get(t,e){return this.matrix.get(this.row,e)}}class MatrixRowSelectionView extends BaseView{constructor(t,e){super(t,(e=checkRowIndices(t,e)).length,t.columns),this.rowIndices=e}set(t,e,r){return this.matrix.set(this.rowIndices[t],e,r),this}get(t,e){return this.matrix.get(this.rowIndices[t],e)}}class MatrixSelectionView extends BaseView{constructor(t,e,r){let n=checkIndices(t,e,r);super(t,n.row.length,n.column.length),this.rowIndices=n.row,this.columnIndices=n.column}set(t,e,r){return this.matrix.set(this.rowIndices[t],this.columnIndices[e],r),this}get(t,e){return this.matrix.get(this.rowIndices[t],this.columnIndices[e])}}class MatrixSubView extends BaseView{constructor(t,e,r,n,i){checkRange(t,e,r,n,i),super(t,r-e+1,i-n+1),this.startRow=e,this.startColumn=n}set(t,e,r){return this.matrix.set(this.startRow+t,this.startColumn+e,r),this}get(t,e){return this.matrix.get(this.startRow+t,this.startColumn+e)}}class MatrixTransposeView$1 extends BaseView{constructor(t){super(t,t.columns,t.rows)}set(t,e,r){return this.matrix.set(e,t,r),this}get(t,e){return this.matrix.get(e,t)}}class WrapperMatrix1D extends AbstractMatrix{constructor(t,e={}){const{rows:r=1}=e;if(t.length%r!=0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=r,this.columns=t.length/r,this.data=t}set(t,e,r){let n=this._calculateIndex(t,e);return this.data[n]=r,this}get(t,e){let r=this._calculateIndex(t,e);return this.data[r]}_calculateIndex(t,e){return t*this.columns+e}}class WrapperMatrix2D extends AbstractMatrix{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}}function wrap(t,e){if(Array.isArray(t))return t[0]&&Array.isArray(t[0])?new WrapperMatrix2D(t):new WrapperMatrix1D(t,e);throw new Error("the argument is not an array")}class LuDecomposition$1{constructor(t){let e,r,n,i,o,s,a,l,h,u=(t=WrapperMatrix2D.checkMatrix(t)).clone(),c=u.rows,f=u.columns,m=new Float64Array(c),g=1;for(e=0;e<c;e++)m[e]=e;for(l=new Float64Array(c),r=0;r<f;r++){for(e=0;e<c;e++)l[e]=u.get(e,r);for(e=0;e<c;e++){for(h=Math.min(e,r),o=0,n=0;n<h;n++)o+=u.get(e,n)*l[n];l[e]-=o,u.set(e,r,l[e])}for(i=r,e=r+1;e<c;e++)Math.abs(l[e])>Math.abs(l[i])&&(i=e);if(i!==r){for(n=0;n<f;n++)s=u.get(i,n),u.set(i,n,u.get(r,n)),u.set(r,n,s);a=m[i],m[i]=m[r],m[r]=a,g=-g}if(r<c&&0!==u.get(r,r))for(e=r+1;e<c;e++)u.set(e,r,u.get(e,r)/u.get(r,r))}this.LU=u,this.pivotVector=m,this.pivotSign=g}isSingular(){let t=this.LU,e=t.columns;for(let r=0;r<e;r++)if(0===t.get(r,r))return!0;return!1}solve(t){t=Matrix$2.checkMatrix(t);let e=this.LU;if(e.rows!==t.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let r,n,i,o=t.columns,s=t.subMatrixRow(this.pivotVector,0,o-1),a=e.columns;for(i=0;i<a;i++)for(r=i+1;r<a;r++)for(n=0;n<o;n++)s.set(r,n,s.get(r,n)-s.get(i,n)*e.get(r,i));for(i=a-1;i>=0;i--){for(n=0;n<o;n++)s.set(i,n,s.get(i,n)/e.get(i,i));for(r=0;r<i;r++)for(n=0;n<o;n++)s.set(r,n,s.get(r,n)-s.get(i,n)*e.get(r,i))}return s}get determinant(){let t=this.LU;if(!t.isSquare())throw new Error("Matrix must be square");let e=this.pivotSign,r=t.columns;for(let n=0;n<r;n++)e*=t.get(n,n);return e}get lowerTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,n=new Matrix$2(e,r);for(let i=0;i<e;i++)for(let e=0;e<r;e++)i>e?n.set(i,e,t.get(i,e)):i===e?n.set(i,e,1):n.set(i,e,0);return n}get upperTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,n=new Matrix$2(e,r);for(let i=0;i<e;i++)for(let e=0;e<r;e++)i<=e?n.set(i,e,t.get(i,e)):n.set(i,e,0);return n}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function hypotenuse(t,e){let r=0;return Math.abs(t)>Math.abs(e)?(r=e/t,Math.abs(t)*Math.sqrt(1+r*r)):0!==e?(r=t/e,Math.abs(e)*Math.sqrt(1+r*r)):0}class QrDecomposition$1{constructor(t){let e,r,n,i,o=(t=WrapperMatrix2D.checkMatrix(t)).clone(),s=t.rows,a=t.columns,l=new Float64Array(a);for(n=0;n<a;n++){let t=0;for(e=n;e<s;e++)t=hypotenuse(t,o.get(e,n));if(0!==t){for(o.get(n,n)<0&&(t=-t),e=n;e<s;e++)o.set(e,n,o.get(e,n)/t);for(o.set(n,n,o.get(n,n)+1),r=n+1;r<a;r++){for(i=0,e=n;e<s;e++)i+=o.get(e,n)*o.get(e,r);for(i=-i/o.get(n,n),e=n;e<s;e++)o.set(e,r,o.get(e,r)+i*o.get(e,n))}}l[n]=-t}this.QR=o,this.Rdiag=l}solve(t){t=Matrix$2.checkMatrix(t);let e=this.QR,r=e.rows;if(t.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let n,i,o,s,a=t.columns,l=t.clone(),h=e.columns;for(o=0;o<h;o++)for(i=0;i<a;i++){for(s=0,n=o;n<r;n++)s+=e.get(n,o)*l.get(n,i);for(s=-s/e.get(o,o),n=o;n<r;n++)l.set(n,i,l.get(n,i)+s*e.get(n,o))}for(o=h-1;o>=0;o--){for(i=0;i<a;i++)l.set(o,i,l.get(o,i)/this.Rdiag[o]);for(n=0;n<o;n++)for(i=0;i<a;i++)l.set(n,i,l.get(n,i)-l.get(o,i)*e.get(n,o))}return l.subMatrix(0,h-1,0,a-1)}isFullRank(){let t=this.QR.columns;for(let e=0;e<t;e++)if(0===this.Rdiag[e])return!1;return!0}get upperTriangularMatrix(){let t,e,r=this.QR,n=r.columns,i=new Matrix$2(n,n);for(t=0;t<n;t++)for(e=0;e<n;e++)t<e?i.set(t,e,r.get(t,e)):t===e?i.set(t,e,this.Rdiag[t]):i.set(t,e,0);return i}get orthogonalMatrix(){let t,e,r,n,i=this.QR,o=i.rows,s=i.columns,a=new Matrix$2(o,s);for(r=s-1;r>=0;r--){for(t=0;t<o;t++)a.set(t,r,0);for(a.set(r,r,1),e=r;e<s;e++)if(0!==i.get(r,r)){for(n=0,t=r;t<o;t++)n+=i.get(t,r)*a.get(t,e);for(n=-n/i.get(r,r),t=r;t<o;t++)a.set(t,e,a.get(t,e)+n*i.get(t,r))}}return a}}class SingularValueDecomposition{constructor(t,e={}){if((t=WrapperMatrix2D.checkMatrix(t)).isEmpty())throw new Error("Matrix must be non-empty");let r=t.rows,n=t.columns;const{computeLeftSingularVectors:i=!0,computeRightSingularVectors:o=!0,autoTranspose:s=!1}=e;let a,l=Boolean(i),h=Boolean(o),u=!1;if(r<n)if(s){a=t.transpose(),r=a.rows,n=a.columns,u=!0;let e=l;l=h,h=e}else a=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else a=t.clone();let c=Math.min(r,n),f=Math.min(r+1,n),m=new Float64Array(f),g=new Matrix$2(r,c),d=new Matrix$2(n,n),p=new Float64Array(n),w=new Float64Array(r),x=new Float64Array(f);for(let t=0;t<f;t++)x[t]=t;let y=Math.min(r-1,n),M=Math.max(0,Math.min(n-2,r)),v=Math.max(y,M);for(let t=0;t<v;t++){if(t<y){m[t]=0;for(let e=t;e<r;e++)m[t]=hypotenuse(m[t],a.get(e,t));if(0!==m[t]){a.get(t,t)<0&&(m[t]=-m[t]);for(let e=t;e<r;e++)a.set(e,t,a.get(e,t)/m[t]);a.set(t,t,a.get(t,t)+1)}m[t]=-m[t]}for(let e=t+1;e<n;e++){if(t<y&&0!==m[t]){let n=0;for(let i=t;i<r;i++)n+=a.get(i,t)*a.get(i,e);n=-n/a.get(t,t);for(let i=t;i<r;i++)a.set(i,e,a.get(i,e)+n*a.get(i,t))}p[e]=a.get(t,e)}if(l&&t<y)for(let e=t;e<r;e++)g.set(e,t,a.get(e,t));if(t<M){p[t]=0;for(let e=t+1;e<n;e++)p[t]=hypotenuse(p[t],p[e]);if(0!==p[t]){p[t+1]<0&&(p[t]=0-p[t]);for(let e=t+1;e<n;e++)p[e]/=p[t];p[t+1]+=1}if(p[t]=-p[t],t+1<r&&0!==p[t]){for(let e=t+1;e<r;e++)w[e]=0;for(let e=t+1;e<r;e++)for(let r=t+1;r<n;r++)w[e]+=p[r]*a.get(e,r);for(let e=t+1;e<n;e++){let n=-p[e]/p[t+1];for(let i=t+1;i<r;i++)a.set(i,e,a.get(i,e)+n*w[i])}}if(h)for(let e=t+1;e<n;e++)d.set(e,t,p[e])}}let b=Math.min(n,r+1);if(y<n&&(m[y]=a.get(y,y)),r<b&&(m[b-1]=0),M+1<b&&(p[M]=a.get(M,b-1)),p[b-1]=0,l){for(let t=y;t<c;t++){for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}for(let t=y-1;t>=0;t--)if(0!==m[t]){for(let e=t+1;e<c;e++){let n=0;for(let i=t;i<r;i++)n+=g.get(i,t)*g.get(i,e);n=-n/g.get(t,t);for(let i=t;i<r;i++)g.set(i,e,g.get(i,e)+n*g.get(i,t))}for(let e=t;e<r;e++)g.set(e,t,-g.get(e,t));g.set(t,t,1+g.get(t,t));for(let e=0;e<t-1;e++)g.set(e,t,0)}else{for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}}if(h)for(let t=n-1;t>=0;t--){if(t<M&&0!==p[t])for(let e=t+1;e<n;e++){let r=0;for(let i=t+1;i<n;i++)r+=d.get(i,t)*d.get(i,e);r=-r/d.get(t+1,t);for(let i=t+1;i<n;i++)d.set(i,e,d.get(i,e)+r*d.get(i,t))}for(let e=0;e<n;e++)d.set(e,t,0);d.set(t,t,1)}let S=b-1,A=Number.EPSILON;for(;b>0;){let t,e;for(t=b-2;t>=-1&&-1!==t;t--){const e=Number.MIN_VALUE+A*Math.abs(m[t]+Math.abs(m[t+1]));if(Math.abs(p[t])<=e||Number.isNaN(p[t])){p[t]=0;break}}if(t===b-2)e=4;else{let r;for(r=b-1;r>=t&&r!==t;r--){let e=(r!==b?Math.abs(p[r]):0)+(r!==t+1?Math.abs(p[r-1]):0);if(Math.abs(m[r])<=A*e){m[r]=0;break}}r===t?e=3:r===b-1?e=1:(e=2,t=r)}switch(t++,e){case 1:{let e=p[b-2];p[b-2]=0;for(let r=b-2;r>=t;r--){let i=hypotenuse(m[r],e),o=m[r]/i,s=e/i;if(m[r]=i,r!==t&&(e=-s*p[r-1],p[r-1]=o*p[r-1]),h)for(let t=0;t<n;t++)i=o*d.get(t,r)+s*d.get(t,b-1),d.set(t,b-1,-s*d.get(t,r)+o*d.get(t,b-1)),d.set(t,r,i)}break}case 2:{let e=p[t-1];p[t-1]=0;for(let n=t;n<b;n++){let i=hypotenuse(m[n],e),o=m[n]/i,s=e/i;if(m[n]=i,e=-s*p[n],p[n]=o*p[n],l)for(let e=0;e<r;e++)i=o*g.get(e,n)+s*g.get(e,t-1),g.set(e,t-1,-s*g.get(e,n)+o*g.get(e,t-1)),g.set(e,n,i)}break}case 3:{const e=Math.max(Math.abs(m[b-1]),Math.abs(m[b-2]),Math.abs(p[b-2]),Math.abs(m[t]),Math.abs(p[t])),i=m[b-1]/e,o=m[b-2]/e,s=p[b-2]/e,a=m[t]/e,u=p[t]/e,c=((o+i)*(o-i)+s*s)/2,f=i*s*(i*s);let w=0;0===c&&0===f||(w=c<0?0-Math.sqrt(c*c+f):Math.sqrt(c*c+f),w=f/(c+w));let x=(a+i)*(a-i)+w,y=a*u;for(let e=t;e<b-1;e++){let i=hypotenuse(x,y);0===i&&(i=Number.MIN_VALUE);let o=x/i,s=y/i;if(e!==t&&(p[e-1]=i),x=o*m[e]+s*p[e],p[e]=o*p[e]-s*m[e],y=s*m[e+1],m[e+1]=o*m[e+1],h)for(let t=0;t<n;t++)i=o*d.get(t,e)+s*d.get(t,e+1),d.set(t,e+1,-s*d.get(t,e)+o*d.get(t,e+1)),d.set(t,e,i);if(i=hypotenuse(x,y),0===i&&(i=Number.MIN_VALUE),o=x/i,s=y/i,m[e]=i,x=o*p[e]+s*m[e+1],m[e+1]=-s*p[e]+o*m[e+1],y=s*p[e+1],p[e+1]=o*p[e+1],l&&e<r-1)for(let t=0;t<r;t++)i=o*g.get(t,e)+s*g.get(t,e+1),g.set(t,e+1,-s*g.get(t,e)+o*g.get(t,e+1)),g.set(t,e,i)}p[b-2]=x;break}case 4:if(m[t]<=0&&(m[t]=m[t]<0?-m[t]:0,h))for(let e=0;e<=S;e++)d.set(e,t,-d.get(e,t));for(;t<S&&!(m[t]>=m[t+1]);){let e=m[t];if(m[t]=m[t+1],m[t+1]=e,h&&t<n-1)for(let r=0;r<n;r++)e=d.get(r,t+1),d.set(r,t+1,d.get(r,t)),d.set(r,t,e);if(l&&t<r-1)for(let n=0;n<r;n++)e=g.get(n,t+1),g.set(n,t+1,g.get(n,t)),g.set(n,t,e);t++}b--}}if(u){let t=d;d=g,g=t}this.m=r,this.n=n,this.s=m,this.U=g,this.V=d}solve(t){let e=t,r=this.threshold,n=this.s.length,i=Matrix$2.zeros(n,n);for(let t=0;t<n;t++)Math.abs(this.s[t])<=r?i.set(t,t,0):i.set(t,t,1/this.s[t]);let o=this.U,s=this.rightSingularVectors,a=s.mmul(i),l=s.rows,h=o.rows,u=Matrix$2.zeros(l,h);for(let t=0;t<l;t++)for(let e=0;e<h;e++){let r=0;for(let i=0;i<n;i++)r+=a.get(t,i)*o.get(e,i);u.set(t,e,r)}return u.mmul(e)}solveForDiagonal(t){return this.solve(Matrix$2.diag(t))}inverse(){let t=this.V,e=this.threshold,r=t.rows,n=t.columns,i=new Matrix$2(r,this.s.length);for(let o=0;o<r;o++)for(let r=0;r<n;r++)Math.abs(this.s[r])>e&&i.set(o,r,t.get(o,r)/this.s[r]);let o=this.U,s=o.rows,a=o.columns,l=new Matrix$2(r,s);for(let t=0;t<r;t++)for(let e=0;e<s;e++){let r=0;for(let n=0;n<a;n++)r+=i.get(t,n)*o.get(e,n);l.set(t,e,r)}return l}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,r=this.s;for(let n=0,i=r.length;n<i;n++)r[n]>t&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Matrix$2.diag(this.s)}}function inverse(t,e=!1){return t=WrapperMatrix2D.checkMatrix(t),e?new SingularValueDecomposition(t).inverse():solve(t,Matrix$2.eye(t.rows))}function solve(t,e,r=!1){return t=WrapperMatrix2D.checkMatrix(t),e=WrapperMatrix2D.checkMatrix(e),r?new SingularValueDecomposition(t).solve(e):t.isSquare()?new LuDecomposition$1(t).solve(e):new QrDecomposition$1(t).solve(e)}function determinant(t){if((t=Matrix$2.checkMatrix(t)).isSquare()){if(0===t.columns)return 1;let e,r,n,i;if(2===t.columns)return e=t.get(0,0),r=t.get(0,1),n=t.get(1,0),i=t.get(1,1),e*i-r*n;if(3===t.columns){let i,o,s;return i=new MatrixSelectionView(t,[1,2],[1,2]),o=new MatrixSelectionView(t,[1,2],[0,2]),s=new MatrixSelectionView(t,[1,2],[0,1]),e=t.get(0,0),r=t.get(0,1),n=t.get(0,2),e*determinant(i)-r*determinant(o)+n*determinant(s)}return new LuDecomposition$1(t).determinant}throw Error("determinant can only be calculated for a square matrix")}function xrange(t,e){let r=[];for(let n=0;n<t;n++)n!==e&&r.push(n);return r}function dependenciesOneRow(t,e,r,n=1e-9,i=1e-9){if(t>i)return new Array(e.rows+1).fill(0);{let t=e.addRow(r,[0]);for(let e=0;e<t.rows;e++)Math.abs(t.get(e,0))<n&&t.set(e,0,0);return t.to1DArray()}}function linearDependencies(t,e={}){const{thresholdValue:r=1e-9,thresholdError:n=1e-9}=e;let i=(t=Matrix$2.checkMatrix(t)).rows,o=new Matrix$2(i,i);for(let e=0;e<i;e++){let s=Matrix$2.columnVector(t.getRow(e)),a=t.subMatrixRow(xrange(i,e)).transpose(),l=new SingularValueDecomposition(a).solve(s),h=Matrix$2.sub(s,a.mmul(l)).abs().max();o.setRow(e,dependenciesOneRow(h,l,e,r,n))}return o}function pseudoInverse(t,e=Number.EPSILON){if((t=Matrix$2.checkMatrix(t)).isEmpty())return t.transpose();let r=new SingularValueDecomposition(t,{autoTranspose:!0}),n=r.leftSingularVectors,i=r.rightSingularVectors,o=r.diagonal;for(let t=0;t<o.length;t++)Math.abs(o[t])>e?o[t]=1/o[t]:o[t]=0;return i.mmul(Matrix$2.diag(o).mmul(n.transpose()))}function covariance$1(t,e=t,r={}){t=new Matrix$2(t);let n=!1;if("object"!=typeof e||Matrix$2.isMatrix(e)||Array.isArray(e)?e=new Matrix$2(e):(r=e,e=t,n=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:i=!0}=r;i&&(t=t.center("column"),n||(e=e.center("column")));const o=t.transpose().mmul(e);for(let e=0;e<o.rows;e++)for(let r=0;r<o.columns;r++)o.set(e,r,o.get(e,r)*(1/(t.rows-1)));return o}function correlation(t,e=t,r={}){t=new Matrix$2(t);let n=!1;if("object"!=typeof e||Matrix$2.isMatrix(e)||Array.isArray(e)?e=new Matrix$2(e):(r=e,e=t,n=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:i=!0,scale:o=!0}=r;i&&(t.center("column"),n||e.center("column")),o&&(t.scale("column"),n||e.scale("column"));const s=t.standardDeviation("column",{unbiased:!0}),a=n?s:e.standardDeviation("column",{unbiased:!0}),l=t.transpose().mmul(e);for(let e=0;e<l.rows;e++)for(let r=0;r<l.columns;r++)l.set(e,r,l.get(e,r)*(1/(s[e]*a[r]))*(1/(t.rows-1)));return l}class EigenvalueDecomposition{constructor(t,e={}){const{assumeSymmetric:r=!1}=e;if(!(t=WrapperMatrix2D.checkMatrix(t)).isSquare())throw new Error("Matrix is not a square matrix");if(t.isEmpty())throw new Error("Matrix must be non-empty");let n,i,o=t.columns,s=new Matrix$2(o,o),a=new Float64Array(o),l=new Float64Array(o),h=t,u=!1;if(u=!!r||t.isSymmetric(),u){for(n=0;n<o;n++)for(i=0;i<o;i++)s.set(n,i,h.get(n,i));tred2(o,l,a,s),tql2(o,l,a,s)}else{let t=new Matrix$2(o,o),e=new Float64Array(o);for(i=0;i<o;i++)for(n=0;n<o;n++)t.set(n,i,h.get(n,i));orthes(o,t,e,s),hqr2(o,l,a,s,t)}this.n=o,this.e=l,this.d=a,this.V=s}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let t,e,r=this.n,n=this.e,i=this.d,o=new Matrix$2(r,r);for(t=0;t<r;t++){for(e=0;e<r;e++)o.set(t,e,0);o.set(t,t,i[t]),n[t]>0?o.set(t,t+1,n[t]):n[t]<0&&o.set(t,t-1,n[t])}return o}}function tred2(t,e,r,n){let i,o,s,a,l,h,u,c;for(l=0;l<t;l++)r[l]=n.get(t-1,l);for(a=t-1;a>0;a--){for(c=0,s=0,h=0;h<a;h++)c+=Math.abs(r[h]);if(0===c)for(e[a]=r[a-1],l=0;l<a;l++)r[l]=n.get(a-1,l),n.set(a,l,0),n.set(l,a,0);else{for(h=0;h<a;h++)r[h]/=c,s+=r[h]*r[h];for(i=r[a-1],o=Math.sqrt(s),i>0&&(o=-o),e[a]=c*o,s-=i*o,r[a-1]=i-o,l=0;l<a;l++)e[l]=0;for(l=0;l<a;l++){for(i=r[l],n.set(l,a,i),o=e[l]+n.get(l,l)*i,h=l+1;h<=a-1;h++)o+=n.get(h,l)*r[h],e[h]+=n.get(h,l)*i;e[l]=o}for(i=0,l=0;l<a;l++)e[l]/=s,i+=e[l]*r[l];for(u=i/(s+s),l=0;l<a;l++)e[l]-=u*r[l];for(l=0;l<a;l++){for(i=r[l],o=e[l],h=l;h<=a-1;h++)n.set(h,l,n.get(h,l)-(i*e[h]+o*r[h]));r[l]=n.get(a-1,l),n.set(a,l,0)}}r[a]=s}for(a=0;a<t-1;a++){if(n.set(t-1,a,n.get(a,a)),n.set(a,a,1),s=r[a+1],0!==s){for(h=0;h<=a;h++)r[h]=n.get(h,a+1)/s;for(l=0;l<=a;l++){for(o=0,h=0;h<=a;h++)o+=n.get(h,a+1)*n.get(h,l);for(h=0;h<=a;h++)n.set(h,l,n.get(h,l)-o*r[h])}}for(h=0;h<=a;h++)n.set(h,a+1,0)}for(l=0;l<t;l++)r[l]=n.get(t-1,l),n.set(t-1,l,0);n.set(t-1,t-1,1),e[0]=0}function tql2(t,e,r,n){let i,o,s,a,l,h,u,c,f,m,g,d,p,w,x,y;for(s=1;s<t;s++)e[s-1]=e[s];e[t-1]=0;let M=0,v=0,b=Number.EPSILON;for(h=0;h<t;h++){for(v=Math.max(v,Math.abs(r[h])+Math.abs(e[h])),u=h;u<t&&!(Math.abs(e[u])<=b*v);)u++;if(u>h)do{for(i=r[h],c=(r[h+1]-i)/(2*e[h]),f=hypotenuse(c,1),c<0&&(f=-f),r[h]=e[h]/(c+f),r[h+1]=e[h]*(c+f),m=r[h+1],o=i-r[h],s=h+2;s<t;s++)r[s]-=o;for(M+=o,c=r[u],g=1,d=g,p=g,w=e[h+1],x=0,y=0,s=u-1;s>=h;s--)for(p=d,d=g,y=x,i=g*e[s],o=g*c,f=hypotenuse(c,e[s]),e[s+1]=x*f,x=e[s]/f,g=c/f,c=g*r[s]-x*i,r[s+1]=o+x*(g*i+x*r[s]),l=0;l<t;l++)o=n.get(l,s+1),n.set(l,s+1,x*n.get(l,s)+g*o),n.set(l,s,g*n.get(l,s)-x*o);c=-x*y*p*w*e[h]/m,e[h]=x*c,r[h]=g*c}while(Math.abs(e[h])>b*v);r[h]=r[h]+M,e[h]=0}for(s=0;s<t-1;s++){for(l=s,c=r[s],a=s+1;a<t;a++)r[a]<c&&(l=a,c=r[a]);if(l!==s)for(r[l]=r[s],r[s]=c,a=0;a<t;a++)c=n.get(a,s),n.set(a,s,n.get(a,l)),n.set(a,l,c)}}function orthes(t,e,r,n){let i,o,s,a,l,h,u,c=t-1;for(h=1;h<=c-1;h++){for(u=0,a=h;a<=c;a++)u+=Math.abs(e.get(a,h-1));if(0!==u){for(s=0,a=c;a>=h;a--)r[a]=e.get(a,h-1)/u,s+=r[a]*r[a];for(o=Math.sqrt(s),r[h]>0&&(o=-o),s-=r[h]*o,r[h]=r[h]-o,l=h;l<t;l++){for(i=0,a=c;a>=h;a--)i+=r[a]*e.get(a,l);for(i/=s,a=h;a<=c;a++)e.set(a,l,e.get(a,l)-i*r[a])}for(a=0;a<=c;a++){for(i=0,l=c;l>=h;l--)i+=r[l]*e.get(a,l);for(i/=s,l=h;l<=c;l++)e.set(a,l,e.get(a,l)-i*r[l])}r[h]=u*r[h],e.set(h,h-1,u*o)}}for(a=0;a<t;a++)for(l=0;l<t;l++)n.set(a,l,a===l?1:0);for(h=c-1;h>=1;h--)if(0!==e.get(h,h-1)){for(a=h+1;a<=c;a++)r[a]=e.get(a,h-1);for(l=h;l<=c;l++){for(o=0,a=h;a<=c;a++)o+=r[a]*n.get(a,l);for(o=o/r[h]/e.get(h,h-1),a=h;a<=c;a++)n.set(a,l,n.get(a,l)+o*r[a])}}}function hqr2(t,e,r,n,i){let o,s,a,l,h,u,c,f,m,g,d,p,w,x,y,M=t-1,v=t-1,b=Number.EPSILON,S=0,A=0,E=0,R=0,N=0,$=0,k=0,T=0;for(o=0;o<t;o++)for((o<0||o>v)&&(r[o]=i.get(o,o),e[o]=0),s=Math.max(o-1,0);s<t;s++)A+=Math.abs(i.get(o,s));for(;M>=0;){for(l=M;l>0&&($=Math.abs(i.get(l-1,l-1))+Math.abs(i.get(l,l)),0===$&&($=A),!(Math.abs(i.get(l,l-1))<b*$));)l--;if(l===M)i.set(M,M,i.get(M,M)+S),r[M]=i.get(M,M),e[M]=0,M--,T=0;else if(l===M-1){if(c=i.get(M,M-1)*i.get(M-1,M),E=(i.get(M-1,M-1)-i.get(M,M))/2,R=E*E+c,k=Math.sqrt(Math.abs(R)),i.set(M,M,i.get(M,M)+S),i.set(M-1,M-1,i.get(M-1,M-1)+S),f=i.get(M,M),R>=0){for(k=E>=0?E+k:E-k,r[M-1]=f+k,r[M]=r[M-1],0!==k&&(r[M]=f-c/k),e[M-1]=0,e[M]=0,f=i.get(M,M-1),$=Math.abs(f)+Math.abs(k),E=f/$,R=k/$,N=Math.sqrt(E*E+R*R),E/=N,R/=N,s=M-1;s<t;s++)k=i.get(M-1,s),i.set(M-1,s,R*k+E*i.get(M,s)),i.set(M,s,R*i.get(M,s)-E*k);for(o=0;o<=M;o++)k=i.get(o,M-1),i.set(o,M-1,R*k+E*i.get(o,M)),i.set(o,M,R*i.get(o,M)-E*k);for(o=0;o<=v;o++)k=n.get(o,M-1),n.set(o,M-1,R*k+E*n.get(o,M)),n.set(o,M,R*n.get(o,M)-E*k)}else r[M-1]=f+E,r[M]=f+E,e[M-1]=k,e[M]=-k;M-=2,T=0}else{if(f=i.get(M,M),m=0,c=0,l<M&&(m=i.get(M-1,M-1),c=i.get(M,M-1)*i.get(M-1,M)),10===T){for(S+=f,o=0;o<=M;o++)i.set(o,o,i.get(o,o)-f);$=Math.abs(i.get(M,M-1))+Math.abs(i.get(M-1,M-2)),f=m=.75*$,c=-.4375*$*$}if(30===T&&($=(m-f)/2,$=$*$+c,$>0)){for($=Math.sqrt($),m<f&&($=-$),$=f-c/((m-f)/2+$),o=0;o<=M;o++)i.set(o,o,i.get(o,o)-$);S+=$,f=m=c=.964}for(T+=1,h=M-2;h>=l&&(k=i.get(h,h),N=f-k,$=m-k,E=(N*$-c)/i.get(h+1,h)+i.get(h,h+1),R=i.get(h+1,h+1)-k-N-$,N=i.get(h+2,h+1),$=Math.abs(E)+Math.abs(R)+Math.abs(N),E/=$,R/=$,N/=$,h!==l)&&!(Math.abs(i.get(h,h-1))*(Math.abs(R)+Math.abs(N))<b*(Math.abs(E)*(Math.abs(i.get(h-1,h-1))+Math.abs(k)+Math.abs(i.get(h+1,h+1)))));)h--;for(o=h+2;o<=M;o++)i.set(o,o-2,0),o>h+2&&i.set(o,o-3,0);for(a=h;a<=M-1&&(x=a!==M-1,a!==h&&(E=i.get(a,a-1),R=i.get(a+1,a-1),N=x?i.get(a+2,a-1):0,f=Math.abs(E)+Math.abs(R)+Math.abs(N),0!==f&&(E/=f,R/=f,N/=f)),0!==f);a++)if($=Math.sqrt(E*E+R*R+N*N),E<0&&($=-$),0!==$){for(a!==h?i.set(a,a-1,-$*f):l!==h&&i.set(a,a-1,-i.get(a,a-1)),E+=$,f=E/$,m=R/$,k=N/$,R/=E,N/=E,s=a;s<t;s++)E=i.get(a,s)+R*i.get(a+1,s),x&&(E+=N*i.get(a+2,s),i.set(a+2,s,i.get(a+2,s)-E*k)),i.set(a,s,i.get(a,s)-E*f),i.set(a+1,s,i.get(a+1,s)-E*m);for(o=0;o<=Math.min(M,a+3);o++)E=f*i.get(o,a)+m*i.get(o,a+1),x&&(E+=k*i.get(o,a+2),i.set(o,a+2,i.get(o,a+2)-E*N)),i.set(o,a,i.get(o,a)-E),i.set(o,a+1,i.get(o,a+1)-E*R);for(o=0;o<=v;o++)E=f*n.get(o,a)+m*n.get(o,a+1),x&&(E+=k*n.get(o,a+2),n.set(o,a+2,n.get(o,a+2)-E*N)),n.set(o,a,n.get(o,a)-E),n.set(o,a+1,n.get(o,a+1)-E*R)}}}if(0!==A){for(M=t-1;M>=0;M--)if(E=r[M],R=e[M],0===R)for(l=M,i.set(M,M,1),o=M-1;o>=0;o--){for(c=i.get(o,o)-E,N=0,s=l;s<=M;s++)N+=i.get(o,s)*i.get(s,M);if(e[o]<0)k=c,$=N;else if(l=o,0===e[o]?i.set(o,M,0!==c?-N/c:-N/(b*A)):(f=i.get(o,o+1),m=i.get(o+1,o),R=(r[o]-E)*(r[o]-E)+e[o]*e[o],u=(f*$-k*N)/R,i.set(o,M,u),i.set(o+1,M,Math.abs(f)>Math.abs(k)?(-N-c*u)/f:(-$-m*u)/k)),u=Math.abs(i.get(o,M)),b*u*u>1)for(s=o;s<=M;s++)i.set(s,M,i.get(s,M)/u)}else if(R<0)for(l=M-1,Math.abs(i.get(M,M-1))>Math.abs(i.get(M-1,M))?(i.set(M-1,M-1,R/i.get(M,M-1)),i.set(M-1,M,-(i.get(M,M)-E)/i.get(M,M-1))):(y=cdiv(0,-i.get(M-1,M),i.get(M-1,M-1)-E,R),i.set(M-1,M-1,y[0]),i.set(M-1,M,y[1])),i.set(M,M-1,0),i.set(M,M,1),o=M-2;o>=0;o--){for(g=0,d=0,s=l;s<=M;s++)g+=i.get(o,s)*i.get(s,M-1),d+=i.get(o,s)*i.get(s,M);if(c=i.get(o,o)-E,e[o]<0)k=c,N=g,$=d;else if(l=o,0===e[o]?(y=cdiv(-g,-d,c,R),i.set(o,M-1,y[0]),i.set(o,M,y[1])):(f=i.get(o,o+1),m=i.get(o+1,o),p=(r[o]-E)*(r[o]-E)+e[o]*e[o]-R*R,w=2*(r[o]-E)*R,0===p&&0===w&&(p=b*A*(Math.abs(c)+Math.abs(R)+Math.abs(f)+Math.abs(m)+Math.abs(k))),y=cdiv(f*N-k*g+R*d,f*$-k*d-R*g,p,w),i.set(o,M-1,y[0]),i.set(o,M,y[1]),Math.abs(f)>Math.abs(k)+Math.abs(R)?(i.set(o+1,M-1,(-g-c*i.get(o,M-1)+R*i.get(o,M))/f),i.set(o+1,M,(-d-c*i.get(o,M)-R*i.get(o,M-1))/f)):(y=cdiv(-N-m*i.get(o,M-1),-$-m*i.get(o,M),k,R),i.set(o+1,M-1,y[0]),i.set(o+1,M,y[1]))),u=Math.max(Math.abs(i.get(o,M-1)),Math.abs(i.get(o,M))),b*u*u>1)for(s=o;s<=M;s++)i.set(s,M-1,i.get(s,M-1)/u),i.set(s,M,i.get(s,M)/u)}for(o=0;o<t;o++)if(o<0||o>v)for(s=o;s<t;s++)n.set(o,s,i.get(o,s));for(s=t-1;s>=0;s--)for(o=0;o<=v;o++){for(k=0,a=0;a<=Math.min(s,v);a++)k+=n.get(o,a)*i.get(a,s);n.set(o,s,k)}}}function cdiv(t,e,r,n){let i,o;return Math.abs(r)>Math.abs(n)?(i=n/r,o=r+i*n,[(t+i*e)/o,(e-i*t)/o]):(i=r/n,o=n+i*r,[(i*t+e)/o,(i*e-t)/o])}class CholeskyDecomposition$1{constructor(t){if(!(t=WrapperMatrix2D.checkMatrix(t)).isSymmetric())throw new Error("Matrix is not symmetric");let e,r,n,i=t,o=i.rows,s=new Matrix$2(o,o),a=!0;for(r=0;r<o;r++){let t=0;for(n=0;n<r;n++){let o=0;for(e=0;e<n;e++)o+=s.get(n,e)*s.get(r,e);o=(i.get(r,n)-o)/s.get(n,n),s.set(r,n,o),t+=o*o}for(t=i.get(r,r)-t,a&=t>0,s.set(r,r,Math.sqrt(Math.max(t,0))),n=r+1;n<o;n++)s.set(r,n,0)}this.L=s,this.positiveDefinite=Boolean(a)}isPositiveDefinite(){return this.positiveDefinite}solve(t){t=WrapperMatrix2D.checkMatrix(t);let e=this.L,r=e.rows;if(t.rows!==r)throw new Error("Matrix dimensions do not match");if(!1===this.isPositiveDefinite())throw new Error("Matrix is not positive definite");let n,i,o,s=t.columns,a=t.clone();for(o=0;o<r;o++)for(i=0;i<s;i++){for(n=0;n<o;n++)a.set(o,i,a.get(o,i)-a.get(n,i)*e.get(o,n));a.set(o,i,a.get(o,i)/e.get(o,o))}for(o=r-1;o>=0;o--)for(i=0;i<s;i++){for(n=o+1;n<r;n++)a.set(o,i,a.get(o,i)-a.get(n,i)*e.get(n,o));a.set(o,i,a.get(o,i)/e.get(o,o))}return a}get lowerTriangularMatrix(){return this.L}}class nipals{constructor(t,e={}){t=WrapperMatrix2D.checkMatrix(t);let{Y:r}=e;const{scaleScores:n=!1,maxIterations:i=1e3,terminationCriteria:o=1e-10}=e;let s;if(r){if(r=Array.isArray(r)&&"number"==typeof r[0]?Matrix$2.columnVector(r):WrapperMatrix2D.checkMatrix(r),r.rows!==t.rows)throw new Error("Y should have the same number of rows as X");s=r.getColumnVector(0)}else s=t.getColumnVector(0);let a,l,h,u,c=1;for(let e=0;e<i&&c>o;e++)h=t.transpose().mmul(s).div(s.transpose().mmul(s).get(0,0)),h=h.div(h.norm()),a=t.mmul(h).div(h.transpose().mmul(h).get(0,0)),e>0&&(c=a.clone().sub(u).pow(2).sum()),u=a.clone(),r?(l=r.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0)),l=l.div(l.norm()),s=r.mmul(l).div(l.transpose().mmul(l).get(0,0))):s=a;if(r){let e=t.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0));e=e.div(e.norm());let n=t.clone().sub(a.clone().mmul(e.transpose())),i=s.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0)),o=r.clone().sub(a.clone().mulS(i.get(0,0)).mmul(l.transpose()));this.t=a,this.p=e.transpose(),this.w=h.transpose(),this.q=l,this.u=s,this.s=a.transpose().mmul(a),this.xResidual=n,this.yResidual=o,this.betas=i}else this.w=h.transpose(),this.s=a.transpose().mmul(a).sqrt(),this.t=n?a.clone().div(this.s.get(0,0)):a,this.xResidual=t.sub(a.mmul(h.transpose()))}}var MatrixLib=Object.freeze({__proto__:null,AbstractMatrix:AbstractMatrix,default:Matrix$2,Matrix:Matrix$2,wrap:wrap,WrapperMatrix1D:WrapperMatrix1D,WrapperMatrix2D:WrapperMatrix2D,solve:solve,inverse:inverse,determinant:determinant,linearDependencies:linearDependencies,pseudoInverse:pseudoInverse,covariance:covariance$1,correlation:correlation,SingularValueDecomposition:SingularValueDecomposition,SVD:SingularValueDecomposition,EigenvalueDecomposition:EigenvalueDecomposition,EVD:EigenvalueDecomposition,CholeskyDecomposition:CholeskyDecomposition$1,CHO:CholeskyDecomposition$1,LuDecomposition:LuDecomposition$1,LU:LuDecomposition$1,QrDecomposition:QrDecomposition$1,QR:QrDecomposition$1,Nipals:nipals,NIPALS:nipals,MatrixColumnView:MatrixColumnView,MatrixColumnSelectionView:MatrixColumnSelectionView,MatrixFlipColumnView:MatrixFlipColumnView,MatrixFlipRowView:MatrixFlipRowView,MatrixRowView:MatrixRowView,MatrixRowSelectionView:MatrixRowSelectionView,MatrixSelectionView:MatrixSelectionView,MatrixSubView:MatrixSubView,MatrixTransposeView:MatrixTransposeView$1});function sum(t){if(!isAnyArray(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=0,r=0;r<t.length;r++)e+=t[r];return e}function mean$1(t){return sum(t)/t.length}function toDiscreteDistribution(t,e){let r=new Array(e).fill(0);for(let e=0;e<t.length;++e)r[t[e]]+=1/t.length;return Matrix$2.rowVector(r)}function giniImpurity(t){if(0===t.length)return 0;let e=toDiscreteDistribution(t,getNumberOfClasses(t)).getRow(0),r=0;for(let t=0;t<e.length;++t)r+=e[t]*e[t];return 1-r}function getNumberOfClasses(t){return t.filter((function(t,e,r){return r.indexOf(t)===e})).map((t=>t+1)).reduce(((t,e)=>Math.max(t,e)))}function giniGain(t,e){let r=0,n=["greater","lesser"];for(let i=0;i<n.length;++i){let o=e[n[i]];r+=giniImpurity(o)*o.length/t.length}return giniImpurity(t)-r}function squaredError(t){let e=t.length;if(0===e)return 0;let r=mean$1(t),n=0;for(let i=0;i<e;++i){let e=t[i];n+=(e-r)*(e-r)}return n}function regressionError(t,e){let r=0,n=["greater","lesser"];for(let t=0;t<n.length;++t){r+=squaredError(e[n[t]])}return r}function matrixSplitter(t,e,r,n){let i=[],o=[],s=[],a=[];for(let l=0;l<t.rows;++l)t.get(l,r)<n?(i.push(t.getRow(l)),s.push(e[l])):(o.push(t.getRow(l)),a.push(e[l]));return{greaterX:o,greaterY:a,lesserX:i,lesserY:s}}function mean(t,e){return(t+e)/2}function zip(t,e){if(t.length!==e.length)throw new TypeError(`Error on zip: the size of a: ${t.length} is different from b: ${e.length}`);let r=new Array(t.length);for(let n=0;n<t.length;++n)r[n]=[t[n],e[n]];return r}const gainFunctions={gini:giniGain,regression:regressionError},splitFunctions={mean:mean};class TreeNode{constructor(t){this.kind=t.kind,this.gainFunction=t.gainFunction,this.splitFunction=t.splitFunction,this.minNumSamples=t.minNumSamples,this.maxDepth=t.maxDepth}bestSplit(t,e){let r,n,i="classifier"===this.kind?-1/0:1/0,o="classifier"===this.kind?(t,e)=>t>e:(t,e)=>t<e;for(let s=0;s<t.rows;++s){let a=t.getRow(s),l=this.featureSplit(a,e);for(let t=0;t<l.length;++t){let h=l[t],u=this.split(a,e,h),c=gainFunctions[this.gainFunction](e,u);o(c,i)&&(r=s,n=h,i=c)}}return{maxGain:i,maxColumn:r,maxValue:n}}split(t,e,r){let n=[],i=[];for(let o=0;o<t.length;++o)t[o]<r?n.push(e[o]):i.push(e[o]);return{greater:i,lesser:n}}featureSplit(t,e){let r=[],n=zip(t,e);n.sort((function(t,e){return t[0]-e[0]}));for(let t=1;t<n.length;++t)n[t-1][1]!==n[t][1]&&r.push(splitFunctions[this.splitFunction](n[t-1][0],n[t][0]));return r}calculatePrediction(t){if("classifier"===this.kind){if(this.distribution=toDiscreteDistribution(t,getNumberOfClasses(t)),0===this.distribution.columns)throw new TypeError("Error on calculate the prediction")}else this.distribution=mean$1(t)}train(t,e,r,n){if(t.rows<=this.minNumSamples)return void this.calculatePrediction(e);void 0===n&&(n=0);let i=t.transpose(),o=this.bestSplit(i,e);this.splitValue=o.maxValue,this.splitColumn=o.maxColumn,this.gain=o.maxGain;let s=matrixSplitter(t,e,this.splitColumn,this.splitValue);if(r<this.maxDepth&&this.gain>.01&&this.gain!==n&&s.lesserX.length>0&&s.greaterX.length>0){this.left=new TreeNode(this),this.right=new TreeNode(this);let t=new Matrix$2(s.lesserX),e=new Matrix$2(s.greaterX);this.left.train(t,s.lesserY,r+1,this.gain),this.right.train(e,s.greaterY,r+1,this.gain)}else this.calculatePrediction(e)}classify(t){return this.right&&this.left?t[this.splitColumn]<this.splitValue?this.left.classify(t):this.right.classify(t):this.distribution}setNodeParameters(t){void 0!==t.distribution?this.distribution=t.distribution.constructor===Array?new Matrix$2(t.distribution):t.distribution:(this.distribution=void 0,this.splitValue=t.splitValue,this.splitColumn=t.splitColumn,this.gain=t.gain,this.left=new TreeNode(this),this.right=new TreeNode(this),t.left!=={}&&this.left.setNodeParameters(t.left),t.right!=={}&&this.right.setNodeParameters(t.right))}}const defaultOptions$h={gainFunction:"gini",splitFunction:"mean",minNumSamples:3,maxDepth:1/0};class DecisionTreeClassifier{constructor(t,e){!0===t?(this.options=e.options,this.root=new TreeNode(e.options),this.root.setNodeParameters(e.root)):(this.options=Object.assign({},defaultOptions$h,t),this.options.kind="classifier")}train(t,e){this.root=new TreeNode(this.options),t=Matrix$2.checkMatrix(t),this.root.train(t,e,0,null)}predict(t){t=Matrix$2.checkMatrix(t);let e=new Array(t.rows);for(let r=0;r<t.rows;++r)e[r]=this.root.classify(t.getRow(r)).maxRowIndex(0)[1];return e}toJSON(){return{options:this.options,root:this.root,name:"DTClassifier"}}static load(t){if("DTClassifier"!==t.name)throw new RangeError(`Invalid model: ${t.name}`);return new DecisionTreeClassifier(!0,t)}}const defaultOptions$g={gainFunction:"regression",splitFunction:"mean",minNumSamples:3,maxDepth:1/0};class DecisionTreeRegression{constructor(t,e){!0===t?(this.options=e.options,this.root=new TreeNode(e.options),this.root.setNodeParameters(e.root)):(this.options=Object.assign({},defaultOptions$g,t),this.options.kind="regression")}train(t,e){this.root=new TreeNode(this.options),t=void 0!==t[0]&&void 0===t[0].length?Matrix$2.columnVector(t):Matrix$2.checkMatrix(t),this.root.train(t,e,0)}predict(t){void 0!==t[0]&&void 0===t[0].length&&(t=Matrix$2.columnVector(t)),t=Matrix$2.checkMatrix(t);let e=new Array(t.rows);for(let r=0;r<t.rows;++r)e[r]=this.root.classify(t.getRow(r));return e}toJSON(){return{options:this.options,root:this.root,name:"DTRegression"}}static load(t){if("DTRegression"!==t.name)throw new RangeError(`Invalid model:${t.name}`);return new DecisionTreeRegression(!0,t)}}const SMALLEST_UNSAFE_INTEGER=9007199254740992,LARGEST_SAFE_INTEGER=SMALLEST_UNSAFE_INTEGER-1,UINT32_MAX=-1>>>0,UINT32_SIZE=UINT32_MAX+1,INT32_SIZE=UINT32_SIZE/2,INT32_MAX=INT32_SIZE-1,UINT21_SIZE=1<<21,UINT21_MAX=UINT21_SIZE-1;function int32(t){return 0|t.next()}function add(t,e){return 0===e?t:r=>t(r)+e}function int53(t){const e=0|t.next(),r=t.next()>>>0;return(e&UINT21_MAX)*UINT32_SIZE+r+(e&UINT21_SIZE?-SMALLEST_UNSAFE_INTEGER:0)}function int53Full(t){for(;;){const e=0|t.next();if(!(4194304&e)){const r=t.next()>>>0;return(e&UINT21_MAX)*UINT32_SIZE+r+(e&UINT21_SIZE?-SMALLEST_UNSAFE_INTEGER:0)}if(4194304==(8388607&e)&&0==(0|t.next()))return SMALLEST_UNSAFE_INTEGER}}function uint32(t){return t.next()>>>0}function uint53(t){const e=t.next()&UINT21_MAX,r=t.next()>>>0;return e*UINT32_SIZE+r}function uint53Full(t){for(;;){const e=0|t.next();if(!(e&UINT21_SIZE)){const r=t.next()>>>0;return(e&UINT21_MAX)*UINT32_SIZE+r}if(0==(e&UINT21_MAX)&&0==(0|t.next()))return SMALLEST_UNSAFE_INTEGER}}function isPowerOfTwoMinusOne(t){return 0==(t+1&t)}function bitmask(t){return e=>e.next()&t}function downscaleToLoopCheckedRange(t){const e=t+1,r=e*Math.floor(UINT32_SIZE/e);return t=>{let n=0;do{n=t.next()>>>0}while(n>=r);return n%e}}function downscaleToRange(t){return isPowerOfTwoMinusOne(t)?bitmask(t):downscaleToLoopCheckedRange(t)}function isEvenlyDivisibleByMaxInt32(t){return 0==(0|t)}function upscaleWithHighMasking(t){return e=>{const r=e.next()&t,n=e.next()>>>0;return r*UINT32_SIZE+n}}function upscaleToLoopCheckedRange(t){const e=t*Math.floor(SMALLEST_UNSAFE_INTEGER/t);return r=>{let n=0;do{const t=r.next()&UINT21_MAX,e=r.next()>>>0;n=t*UINT32_SIZE+e}while(n>=e);return n%t}}function upscaleWithinU53(t){const e=t+1;if(isEvenlyDivisibleByMaxInt32(e)){const t=(e/UINT32_SIZE|0)-1;if(isPowerOfTwoMinusOne(t))return upscaleWithHighMasking(t)}return upscaleToLoopCheckedRange(e)}function upscaleWithinI53AndLoopCheck(t,e){return r=>{let n=0;do{const t=0|r.next(),e=r.next()>>>0;n=(t&UINT21_MAX)*UINT32_SIZE+e+(t&UINT21_SIZE?-SMALLEST_UNSAFE_INTEGER:0)}while(n<t||n>e);return n}}function integer(t,e){if(t=Math.floor(t),e=Math.floor(e),t<-SMALLEST_UNSAFE_INTEGER||!isFinite(t))throw new RangeError("Expected min to be at least "+-SMALLEST_UNSAFE_INTEGER);if(e>SMALLEST_UNSAFE_INTEGER||!isFinite(e))throw new RangeError(`Expected max to be at most ${SMALLEST_UNSAFE_INTEGER}`);const r=e-t;return r<=0||!isFinite(r)?()=>t:r===UINT32_MAX?0===t?uint32:add(int32,t+INT32_SIZE):r<UINT32_MAX?add(downscaleToRange(r),t):r===LARGEST_SAFE_INTEGER?add(uint53,t):r<LARGEST_SAFE_INTEGER?add(upscaleWithinU53(r),t):e-1-t===LARGEST_SAFE_INTEGER?add(uint53Full,t):t===-SMALLEST_UNSAFE_INTEGER&&e===SMALLEST_UNSAFE_INTEGER?int53Full:t===-SMALLEST_UNSAFE_INTEGER&&e===LARGEST_SAFE_INTEGER?int53:t===-LARGEST_SAFE_INTEGER&&e===SMALLEST_UNSAFE_INTEGER?add(int53,1):e===SMALLEST_UNSAFE_INTEGER?add(upscaleWithinI53AndLoopCheck(t-1,e-1),1):upscaleWithinI53AndLoopCheck(t,e)}const DEFAULT_STRING_POOL="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-";function string(t=DEFAULT_STRING_POOL){const e=t.length;if(!e)throw new Error("Expected pool not to be an empty string");const r=integer(0,e-1);return(e,n)=>{let i="";for(let o=0;o<n;++o){const n=r(e);i+=t.charAt(n)}return i}}const LOWER_HEX_POOL="0123456789abcdef";string(LOWER_HEX_POOL),string(LOWER_HEX_POOL.toUpperCase()),(()=>{try{if("xxx"==="x".repeat(3))return(t,e)=>t.repeat(e)}catch(t){}})();const nativeMath={next:()=>Math.random()*UINT32_SIZE|0},I32Array=(()=>{try{const t=new ArrayBuffer(4),e=new Int32Array(t);if(e[0]=INT32_SIZE,e[0]===-INT32_SIZE)return Int32Array}catch(t){}return Array})();function createEntropy(t=nativeMath,e=16){const r=[];r.push(0|(new Date).getTime());for(let n=1;n<e;++n)r[n]=0|t.next();return r}const imul=(()=>{try{if(-5===Math.imul(UINT32_MAX,5))return Math.imul}catch(t){}const t=65535;return(e,r)=>{const n=e&t,i=r&t;return n*i+((e>>>16&t)*i+n*(r>>>16&t)<<16>>>0)|0}})(),ARRAY_SIZE=624,ARRAY_MAX=ARRAY_SIZE-1,M=397,ARRAY_SIZE_MINUS_M=ARRAY_SIZE-M,A=2567483615;class MersenneTwister19937{constructor(){this.data=new I32Array(ARRAY_SIZE),this.index=0,this.uses=0}static seed(t){return(new MersenneTwister19937).seed(t)}static seedWithArray(t){return(new MersenneTwister19937).seedWithArray(t)}static autoSeed(){return MersenneTwister19937.seedWithArray(createEntropy())}next(){(0|this.index)>=ARRAY_SIZE&&(refreshData(this.data),this.index=0);const t=this.data[this.index];return this.index=this.index+1|0,this.uses+=1,0|temper(t)}getUseCount(){return this.uses}discard(t){if(t<=0)return this;for(this.uses+=t,(0|this.index)>=ARRAY_SIZE&&(refreshData(this.data),this.index=0);t+this.index>ARRAY_SIZE;)t-=ARRAY_SIZE-this.index,refreshData(this.data),this.index=0;return this.index=this.index+t|0,this}seed(t){let e=0;this.data[0]=e=0|t;for(let t=1;t<ARRAY_SIZE;t=t+1|0)this.data[t]=e=imul(e^e>>>30,1812433253)+t|0;return this.index=ARRAY_SIZE,this.uses=0,this}seedWithArray(t){return this.seed(19650218),seedWithArray(this.data,t),this}}function refreshData(t){let e=0,r=0;for(;(0|e)<ARRAY_SIZE_MINUS_M;e=e+1|0)r=t[e]&INT32_SIZE|t[e+1|0]&INT32_MAX,t[e]=t[e+M|0]^r>>>1^(1&r?A:0);for(;(0|e)<ARRAY_MAX;e=e+1|0)r=t[e]&INT32_SIZE|t[e+1|0]&INT32_MAX,t[e]=t[e-ARRAY_SIZE_MINUS_M|0]^r>>>1^(1&r?A:0);r=t[ARRAY_MAX]&INT32_SIZE|t[0]&INT32_MAX,t[ARRAY_MAX]=t[M-1]^r>>>1^(1&r?A:0)}function temper(t){return t^=t>>>11,t^=t<<7&2636928640,(t^=t<<15&4022730752)^t>>>18}function seedWithArray(t,e){let r=1,n=0;const i=e.length;let o=0|Math.max(i,ARRAY_SIZE),s=0|t[0];for(;(0|o)>0;--o)t[r]=s=(t[r]^imul(s^s>>>30,1664525))+(0|e[n])+(0|n)|0,r=r+1|0,++n,(0|r)>ARRAY_MAX&&(t[0]=t[ARRAY_MAX],r=1),n>=i&&(n=0);for(o=ARRAY_MAX;(0|o)>0;--o)t[r]=s=(t[r]^imul(s^s>>>30,1566083941))-r|0,r=r+1|0,(0|r)>ARRAY_MAX&&(t[0]=t[ARRAY_MAX],r=1);t[0]=INT32_SIZE}function checkFloat(t){return t>0&&t<=1}function examplesBaggingWithReplacement(t,e,r){let n,i=integer(0,t.rows-1);if(void 0===r)n=MersenneTwister19937.autoSeed();else{if(!Number.isInteger(r))throw new RangeError(`Expected seed must be undefined or integer not ${r}`);n=MersenneTwister19937.seed(r)}let o=new Array(t.rows),s=new Array(t.rows),a=new Array(t.rows).fill(0),l=t.rows;for(let r=0;r<t.rows;++r){let h=i(n);o[r]=t.getRow(h),s[r]=e[h],0==a[h]++&&l--}let h=new Array(l),u=new Array(l);for(let e=t.rows-1;e>=0&&l>0;--e)0===a[e]&&(h[--l]=t.getRow(e),u[l]=e);return{X:new Matrix$2(o),y:s,Xoob:new Matrix$2(h),ioob:u,seed:n.next()}}function featureBagging(t,e,r,n){if(t.columns<e)throw new RangeError("N should be less or equal to the number of columns of X");let i,o=integer(0,t.columns-1);if(void 0===n)i=MersenneTwister19937.autoSeed();else{if(!Number.isInteger(n))throw new RangeError(`Expected seed must be undefined or integer not ${n}`);i=MersenneTwister19937.seed(n)}let s,a,l=new Matrix$2(t.rows,e);if(r){s=new Array(e);for(let r=0;r<e;++r)a=o(i),s[r]=a,l.setColumn(r,t.getColumn(a))}else{s=new Set,a=o(i);for(let r=0;r<e;++r){for(;s.has(a);)a=o(i);l.setColumn(r,t.getColumn(a)),s.add(a)}s=Array.from(s)}return{X:l,usedIndex:s,seed:i.next()}}const collectOOB=(t,e,r)=>{const n=Array(e.length);for(let i=0;i<e.length;i++){const o=[];for(let e=0;e<t.length;e++){const r=t[e];r.index[0]===i&&(o.push(r.predicted[0]),r.index=r.index.slice(1),r.predicted=r.predicted.slice(1))}n[i]={true:e[i],all:o,predicted:r(o)}}return n};class RandomForestBase{constructor(t,e){if(!0===t){this.replacement=e.replacement,this.maxFeatures=e.maxFeatures,this.nEstimators=e.nEstimators,this.treeOptions=e.treeOptions,this.isClassifier=e.isClassifier,this.seed=e.seed,this.n=e.n,this.indexes=e.indexes,this.useSampleBagging=e.useSampleBagging,this.noOOB=!0;let t=this.isClassifier?DecisionTreeClassifier:DecisionTreeRegression;this.estimators=e.estimators.map((e=>t.load(e)))}else this.replacement=t.replacement,this.maxFeatures=t.maxFeatures,this.nEstimators=t.nEstimators,this.treeOptions=t.treeOptions,this.isClassifier=t.isClassifier,this.seed=t.seed,this.useSampleBagging=t.useSampleBagging,this.noOOB=t.noOOB}train(t,e){let r,n=this.seed;if(t=Matrix$2.checkMatrix(t),this.maxFeatures=this.maxFeatures||t.columns,checkFloat(this.maxFeatures))this.n=Math.floor(t.columns*this.maxFeatures);else{if(!Number.isInteger(this.maxFeatures))throw new RangeError(`Cannot process the maxFeatures parameter ${this.maxFeatures}`);if(this.maxFeatures>t.columns)throw new RangeError(`The maxFeatures parameter should be less than ${t.columns}`);this.n=this.maxFeatures}r=this.isClassifier?DecisionTreeClassifier:DecisionTreeRegression,this.estimators=new Array(this.nEstimators),this.indexes=new Array(this.nEstimators);let i=new Array(this.nEstimators);for(let o=0;o<this.nEstimators;++o){let s=this.useSampleBagging?examplesBaggingWithReplacement(t,e,n):{X:t,y:e,seed:n,Xoob:void 0,yoob:[],ioob:[]},a=s.X,l=s.y;n=s.seed;let{Xoob:h,ioob:u}=s;if(s=featureBagging(a,this.n,this.replacement,n),a=s.X,n=s.seed,this.indexes[o]=s.usedIndex,this.estimators[o]=new r(this.treeOptions),this.estimators[o].train(a,l),!this.noOOB&&this.useSampleBagging){let t=new MatrixColumnSelectionView(h,this.indexes[o]);i[o]={index:u,predicted:this.estimators[o].predict(t)}}}!this.noOOB&&this.useSampleBagging&&i.length>0&&(this.oobResults=collectOOB(i,e,this.selection.bind(this)))}selection(t){throw new Error("Abstract method 'selection' not implemented!")}predict(t){const e=this.predictionValues(t);let r=new Array(e.rows);for(let t=0;t<e.rows;++t)r[t]=this.selection(e.getRow(t));return r}predictionValues(t){let e=new Array(this.nEstimators);t=Matrix$2.checkMatrix(t);for(let r=0;r<this.nEstimators;++r){let n=new MatrixColumnSelectionView(t,this.indexes[r]);e[r]=this.estimators[r].predict(n)}return new MatrixTransposeView$1(new WrapperMatrix2D(e))}predictOOB(){if(!this.oobResults||0===this.oobResults.length)throw new Error("No Out-Of-Bag results found. Did you forgot to train first?");return this.oobResults.map((t=>t.predicted))}toJSON(){return{indexes:this.indexes,n:this.n,replacement:this.replacement,maxFeatures:this.maxFeatures,nEstimators:this.nEstimators,treeOptions:this.treeOptions,isClassifier:this.isClassifier,seed:this.seed,estimators:this.estimators.map((t=>t.toJSON())),useSampleBagging:this.useSampleBagging}}}const defaultOptions$f={maxFeatures:1,replacement:!0,nEstimators:50,seed:42,useSampleBagging:!0,noOOB:!1};class RandomForestClassifier extends RandomForestBase{constructor(t,e){!0===t?super(!0,e.baseModel):((t=Object.assign({},defaultOptions$f,t)).isClassifier=!0,super(t))}selection(t){return mode$1(t)}toJSON(){return{baseModel:super.toJSON(),name:"RFClassifier"}}getConfusionMatrix(){if(!this.oobResults)throw new Error("No Out-Of-Bag results available.");const t=new Set,e=this.oobResults.reduce(((e,r)=>{t.add(r.true),t.add(r.predicted);const n=e[r.predicted]||{};return n[r.true]=(n[r.true]||0)+1,e[r.predicted]=n,e}),{}),r=[...t].sort();return r.map((t=>r.map((r=>(e[t]||{})[r]||0))))}static load(t){if("RFClassifier"!==t.name)throw new RangeError(`Invalid model: ${t.name}`);return new RandomForestClassifier(!0,t)}predictProbability(t,e){const r=this.predictionValues(t);let n=new Array(r.rows);for(let t=0;t<r.rows;++t){const i=r.getRow(t),o=i.length,s=Math.pow(10,6);n[t]=Math.round(i.reduce(((t,r)=>(r===e&&(t+=s/o),t))))/s}return n}}function mode$1(t){return t.sort(((e,r)=>t.filter((t=>t===e)).length-t.filter((t=>t===r)).length)).pop()}var commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function getAugmentedNamespace(t){if(t.__esModule)return t;var e=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(t).forEach((function(r){var n=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,n.get?n:{enumerable:!0,get:function(){return t[r]}})})),e}function createCommonjsModule(t){var e={exports:{}};return t(e,e.exports),e.exports}var medianQuickselect_min=createCommonjsModule((function(t){!function(){function e(t){for(var e=0,i=t.length-1,o=void 0,s=void 0,a=void 0,l=n(e,i);;){if(i<=e)return t[l];if(i==e+1)return t[e]>t[i]&&r(t,e,i),t[l];for(t[o=n(e,i)]>t[i]&&r(t,o,i),t[e]>t[i]&&r(t,e,i),t[o]>t[e]&&r(t,o,e),r(t,o,e+1),s=e+1,a=i;;){do{s++}while(t[e]>t[s]);do{a--}while(t[a]>t[e]);if(a<s)break;r(t,s,a)}r(t,e,a),a<=l&&(e=s),a>=l&&(i=a-1)}}var r=function(t,e,r){var n;return n=[t[r],t[e]],t[e]=n[0],t[r]=n[1],n},n=function(t,e){return~~((t+e)/2)};t.exports?t.exports=e:window.median=e}()}));function median(t){if(!isAnyArray(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");return medianQuickselect_min(t.slice())}const selectionMethods={mean:mean$1,median:median},defaultOptions$e={maxFeatures:1,replacement:!1,nEstimators:50,treeOptions:{},selectionMethod:"mean",seed:42,useSampleBagging:!0,noOOB:!1};class RandomForestRegression extends RandomForestBase{constructor(t,e){if(!0===t)super(!0,e.baseModel),this.selectionMethod=e.selectionMethod;else{if("mean"!==(t=Object.assign({},defaultOptions$e,t)).selectionMethod&&"median"!==t.selectionMethod)throw new RangeError(`Unsupported selection method ${t.selectionMethod}`);t.isClassifier=!1,super(t),this.selectionMethod=t.selectionMethod}}selection(t){return selectionMethods[this.selectionMethod](t)}toJSON(){return{baseModel:super.toJSON(),selectionMethod:this.selectionMethod,name:"RFRegression"}}static load(t){if("RFRegression"!==t.name)throw new RangeError(`Invalid model: ${t.name}`);return new RandomForestRegression(!0,t)}}class PCA{constructor(t,e={}){if(!0===t){const t=e;return this.center=t.center,this.scale=t.scale,this.means=t.means,this.stdevs=t.stdevs,this.U=Matrix$2.checkMatrix(t.U),this.S=t.S,this.R=t.R,void(this.excludedFeatures=t.excludedFeatures||[])}t=new Matrix$2(t);const{isCovarianceMatrix:r=!1,method:n="SVD",nCompNIPALS:i=2,center:o=!0,scale:s=!1,ignoreZeroVariance:a=!1}=e;if(this.center=o,this.scale=s,this.means=null,this.stdevs=null,this.excludedFeatures=[],r)this._computeFromCovarianceMatrix(t);else switch(this._adjust(t,a),n){case"covarianceMatrix":{const e=new MatrixTransposeView$1(t).mmul(t).div(t.rows-1);this._computeFromCovarianceMatrix(e);break}case"NIPALS":this._computeWithNIPALS(t,i);break;case"SVD":{const e=new SingularValueDecomposition(t,{computeLeftSingularVectors:!1,computeRightSingularVectors:!0,autoTranspose:!0});this.U=e.rightSingularVectors;const r=e.diagonal,n=[];for(const e of r)n.push(e*e/(t.rows-1));this.S=n;break}default:throw new Error(`unknown method: ${n}`)}}static load(t){if("string"!=typeof t.name)throw new TypeError("model must have a name property");if("PCA"!==t.name)throw new RangeError(`invalid model: ${t.name}`);return new PCA(!0,t)}predict(t,e={}){const{nComponents:r=this.U.columns}=e;if(t=new Matrix$2(t),this.center&&(t.subRowVector(this.means),this.scale)){for(let e of this.excludedFeatures)t.removeColumn(e);t.divRowVector(this.stdevs)}let n=t.mmul(this.U);return n.subMatrix(0,n.rows-1,0,r-1)}invert(t){let e=(t=Matrix$2.checkMatrix(t)).mmul(this.U.transpose());return this.center&&(this.scale&&e.mulRowVector(this.stdevs),e.addRowVector(this.means)),e}getExplainedVariance(){let t=0;for(const e of this.S)t+=e;return this.S.map((e=>e/t))}getCumulativeVariance(){let t=this.getExplainedVariance();for(let e=1;e<t.length;e++)t[e]+=t[e-1];return t}getEigenvectors(){return this.U}getEigenvalues(){return this.S}getStandardDeviations(){return this.S.map((t=>Math.sqrt(t)))}getLoadings(){return this.U.transpose()}toJSON(){return{name:"PCA",center:this.center,scale:this.scale,means:this.means,stdevs:this.stdevs,U:this.U,S:this.S,excludedFeatures:this.excludedFeatures}}_adjust(t,e){if(this.center){const r=t.mean("column"),n=this.scale?t.standardDeviation("column",{mean:r}):null;if(this.means=r,t.subRowVector(r),this.scale){for(let r=0;r<n.length;r++)if(0===n[r]){if(!e)throw new RangeError(`Cannot scale the dataset (standard deviation is zero at index ${r}`);t.removeColumn(r),n.splice(r,1),this.excludedFeatures.push(r),r--}this.stdevs=n,t.divRowVector(n)}}}_computeFromCovarianceMatrix(t){const e=new EigenvalueDecomposition(t,{assumeSymmetric:!0});this.U=e.eigenvectorMatrix,this.U.flipRows(),this.S=e.realEigenvalues,this.S.reverse()}_computeWithNIPALS(t,e){this.U=new Matrix$2(e,t.columns),this.S=[];let r=t;for(let t=0;t<e;t++){let e=new nipals(r);this.U.setRow(t,e.w.transpose()),this.S.push(Math.pow(e.s.get(0,0),2)),r=e.xResidual}this.U=this.U.transpose()}}function squaredEuclidean$4(t,e){let r=0;for(let n=0;n<t.length;n++)r+=(t[n]-e[n])*(t[n]-e[n]);return r}function euclidean$2(t,e){return Math.sqrt(squaredEuclidean$4(t,e))}var euclidean$3=Object.freeze({__proto__:null,squaredEuclidean:squaredEuclidean$4,euclidean:euclidean$2});function distanceMatrix(t,e){const r=getMatrix(t.length);for(let n=0;n<t.length;n++)for(let i=0;i<=n;i++)r[n][i]=e(t[n],t[i]),r[i][n]=r[n][i];return r}function getMatrix(t){const e=[];for(let r=0;r<t;r++){const r=[];e.push(r);for(let e=0;e<t;e++)r.push(0)}return e}var heap$1=createCommonjsModule((function(t,e){(function(){var e,r,n,i,o,s,a,l,h,u,c,f,m,g,d;n=Math.floor,u=Math.min,r=function(t,e){return t<e?-1:t>e?1:0},h=function(t,e,i,o,s){var a;if(null==i&&(i=0),null==s&&(s=r),i<0)throw new Error("lo must be non-negative");for(null==o&&(o=t.length);i<o;)s(e,t[a=n((i+o)/2)])<0?o=a:i=a+1;return[].splice.apply(t,[i,i-i].concat(e)),e},s=function(t,e,n){return null==n&&(n=r),t.push(e),g(t,0,t.length-1,n)},o=function(t,e){var n,i;return null==e&&(e=r),n=t.pop(),t.length?(i=t[0],t[0]=n,d(t,0,e)):i=n,i},l=function(t,e,n){var i;return null==n&&(n=r),i=t[0],t[0]=e,d(t,0,n),i},a=function(t,e,n){var i;return null==n&&(n=r),t.length&&n(t[0],e)<0&&(e=(i=[t[0],e])[0],t[0]=i[1],d(t,0,n)),e},i=function(t,e){var i,o,s,a,l,h;for(null==e&&(e=r),l=[],o=0,s=(a=function(){h=[];for(var e=0,r=n(t.length/2);0<=r?e<r:e>r;0<=r?e++:e--)h.push(e);return h}.apply(this).reverse()).length;o<s;o++)i=a[o],l.push(d(t,i,e));return l},m=function(t,e,n){var i;if(null==n&&(n=r),-1!==(i=t.indexOf(e)))return g(t,0,i,n),d(t,i,n)},c=function(t,e,n){var o,s,l,h,u;if(null==n&&(n=r),!(s=t.slice(0,e)).length)return s;for(i(s,n),l=0,h=(u=t.slice(e)).length;l<h;l++)o=u[l],a(s,o,n);return s.sort(n).reverse()},f=function(t,e,n){var s,a,l,c,f,m,g,d,p;if(null==n&&(n=r),10*e<=t.length){if(!(l=t.slice(0,e).sort(n)).length)return l;for(a=l[l.length-1],c=0,m=(g=t.slice(e)).length;c<m;c++)n(s=g[c],a)<0&&(h(l,s,0,null,n),l.pop(),a=l[l.length-1]);return l}for(i(t,n),p=[],f=0,d=u(e,t.length);0<=d?f<d:f>d;0<=d?++f:--f)p.push(o(t,n));return p},g=function(t,e,n,i){var o,s,a;for(null==i&&(i=r),o=t[n];n>e&&i(o,s=t[a=n-1>>1])<0;)t[n]=s,n=a;return t[n]=o},d=function(t,e,n){var i,o,s,a,l;for(null==n&&(n=r),o=t.length,l=e,s=t[e],i=2*e+1;i<o;)(a=i+1)<o&&!(n(t[i],t[a])<0)&&(i=a),t[e]=t[i],i=2*(e=i)+1;return t[e]=s,g(t,l,e,n)},e=function(){function t(t){this.cmp=null!=t?t:r,this.nodes=[]}return t.push=s,t.pop=o,t.replace=l,t.pushpop=a,t.heapify=i,t.updateItem=m,t.nlargest=c,t.nsmallest=f,t.prototype.push=function(t){return s(this.nodes,t,this.cmp)},t.prototype.pop=function(){return o(this.nodes,this.cmp)},t.prototype.peek=function(){return this.nodes[0]},t.prototype.contains=function(t){return-1!==this.nodes.indexOf(t)},t.prototype.replace=function(t){return l(this.nodes,t,this.cmp)},t.prototype.pushpop=function(t){return a(this.nodes,t,this.cmp)},t.prototype.heapify=function(){return i(this.nodes,this.cmp)},t.prototype.updateItem=function(t){return m(this.nodes,t,this.cmp)},t.prototype.clear=function(){return this.nodes=[]},t.prototype.empty=function(){return 0===this.nodes.length},t.prototype.size=function(){return this.nodes.length},t.prototype.clone=function(){var e;return(e=new t).nodes=this.nodes.slice(0),e},t.prototype.toArray=function(){return this.nodes.slice(0)},t.prototype.insert=t.prototype.push,t.prototype.top=t.prototype.peek,t.prototype.front=t.prototype.peek,t.prototype.has=t.prototype.contains,t.prototype.copy=t.prototype.clone,t}(),t.exports=e}).call(commonjsGlobal)})),heap=heap$1;class Cluster{constructor(){this.children=[],this.height=0,this.size=1,this.index=-1,this.isLeaf=!1}cut(t){if("number"!=typeof t)throw new TypeError("threshold must be a number");if(t<0)throw new RangeError("threshold must be a positive number");let e=[this];const r=[];for(;e.length>0;){const n=e.shift();t>=n.height?r.push(n):e=e.concat(n.children)}return r}group(t){if(!Number.isInteger(t)||t<1)throw new RangeError("groups must be a positive integer");const e=new heap(((t,e)=>e.height-t.height));for(e.push(this);e.size()<t;){var r=e.pop();if(0===r.children.length)break;r.children.forEach((t=>e.push(t)))}var n=new Cluster;return n.children=e.toArray(),n.height=this.height,n}traverse(t){!function t(e,r){if(r(e),e.children)for(const n of e.children)t(n,r)}(this,t)}indices(){const t=[];return this.traverse((e=>{e.isLeaf&&t.push(e.index)})),t}}function singleLink(t,e){return Math.min(t,e)}function completeLink(t,e){return Math.max(t,e)}function averageLink(t,e,r,n,i){return n/(n+i)*t+i/(n+i)*e}function weightedAverageLink(t,e){return(t+e)/2}function centroidLink(t,e,r,n,i){return n/(n+i)*t+i/(n+i)*e+-n*i/(n+i)**2*r}function medianLink(t,e,r){return t/2+e/2-r/4}function wardLink(t,e,r,n,i,o){return(n+o)/(n+i+o)*t+(i+o)/(n+i+o)*e+-o/(n+i+o)*r}function wardLink2(t,e,r,n,i,o){const s=(n+o)/(n+i+o),a=(i+o)/(n+i+o),l=-o/(n+i+o);return Math.sqrt(s*t*t+a*e*e+l*r*r)}function agnes(t,e={}){const{distanceFunction:r=euclidean$2,method:n="complete",isDistanceMatrix:i=!1}=e;let o;i||(t=distanceMatrix(t,r));let s=new Matrix$2(t);const a=s.rows;if("string"==typeof n)switch(n.toLowerCase()){case"single":o=singleLink;break;case"complete":o=completeLink;break;case"average":case"upgma":o=averageLink;break;case"wpgma":o=weightedAverageLink;break;case"centroid":case"upgmc":o=centroidLink;break;case"median":case"wpgmc":o=medianLink;break;case"ward":o=wardLink;break;case"ward2":o=wardLink2;break;default:throw new RangeError(`unknown clustering method: ${n}`)}else if("function"!=typeof n)throw new TypeError("method must be a string or function");let l=[];for(let t=0;t<a;t++){const e=new Cluster;e.isLeaf=!0,e.index=t,l.push(e)}for(let t=0;t<a-1;t++){const[t,e,r]=getSmallestDistance(s),n=l[t],i=l[e],a=new Cluster;a.size=n.size+i.size,a.children.push(n,i),a.height=r;const h=[a],u=new Matrix$2(s.rows-1,s.rows-1),c=r=>getPreviousIndex(r,Math.min(t,e),Math.max(t,e));for(let a=1;a<u.rows;a++){const f=c(a),m=l[f];h.push(m);for(let l=0;l<a;l++)if(0===l){const h=o(s.get(t,f),s.get(f,e),r,n.size,i.size,m.size);u.set(a,l,h),u.set(l,a,h)}else{const t=s.get(f,c(l));u.set(a,l,t),u.set(l,a,t)}}l=h,s=u}return l[0]}function getSmallestDistance(t){let e=1/0,r=0,n=0;for(let i=1;i<t.rows;i++)for(let o=0;o<i;o++)t.get(i,o)<e&&(e=t.get(i,o),r=i,n=o);return[r,n,e]}function getPreviousIndex(t,e,r){return(t-=1)>=e&&t++,t>=r&&t++,t}var index$5=Object.freeze({__proto__:null,agnes:agnes});const defaultOptions$d={distanceFunction:squaredEuclidean$4};function nearestVector(t,e,r=defaultOptions$d){const n=r.distanceFunction||defaultOptions$d.distanceFunction,i=r.similarityFunction||defaultOptions$d.similarityFunction;let o=-1;if("function"==typeof i){let r=Number.MIN_VALUE;for(let n=0;n<t.length;n++){const s=i(e,t[n]);s>r&&(r=s,o=n)}}else{if("function"!=typeof n)throw new Error("A similarity or distance function it's required");{let r=Number.MAX_VALUE;for(let i=0;i<t.length;i++){const s=n(e,t[i]);s<r&&(r=s,o=i)}}}return o}function calculateDistanceMatrix(t,e){for(var r=new Array(t.length),n=0;n<t.length;++n)for(var i=n;i<t.length;++i){r[n]||(r[n]=new Array(t.length)),r[i]||(r[i]=new Array(t.length));const o=e(t[n],t[i]);r[n][i]=o,r[i][n]=o}return r}function updateClusterID(t,e,r,n){for(var i=0;i<t.length;i++)r[i]=nearestVector(e,t[i],{distanceFunction:n});return r}function updateCenters(t,e,r,n){const i=e[0].length;for(var o=new Array(n),s=new Array(n),a=0;a<n;a++){o[a]=new Array(i),s[a]=0;for(var l=0;l<i;l++)o[a][l]=0}for(var h=0;h<e.length;h++){s[r[h]]++;for(var u=0;u<i;u++)o[r[h]][u]+=e[h][u]}for(var c=0;c<n;c++)for(var f=0;f<i;f++)s[c]?o[c][f]/=s[c]:o[c][f]=t[c][f];return o}function hasConverged(t,e,r,n){for(var i=0;i<t.length;i++)if(r(t[i],e[i])>n)return!1;return!0}const LOOP=8,FLOAT_MUL=1/16777216,sh1=15,sh2=18,sh3=11;function multiply_uint32(t,e){const r=65535&(t>>>=0);return((t-r)*(e>>>=0)>>>0)+r*e>>>0}class XSadd{constructor(t=Date.now()){this.state=new Uint32Array(4),this.init(t),this.random=this.getFloat.bind(this)}getUint32(){return this.nextState(),this.state[3]+this.state[2]>>>0}getFloat(){return(this.getUint32()>>>8)*FLOAT_MUL}init(t){if(!Number.isInteger(t))throw new TypeError("seed must be an integer");this.state[0]=t,this.state[1]=0,this.state[2]=0,this.state[3]=0;for(let t=1;t<LOOP;t++)this.state[3&t]^=t+multiply_uint32(1812433253,this.state[t-1&3]^this.state[t-1&3]>>>30>>>0)>>>0;this.periodCertification();for(let t=0;t<LOOP;t++)this.nextState()}periodCertification(){0===this.state[0]&&0===this.state[1]&&0===this.state[2]&&0===this.state[3]&&(this.state[0]=88,this.state[1]=83,this.state[2]=65,this.state[3]=68)}nextState(){let t=this.state[0];t^=t<<sh1,t^=t>>>sh2,t^=this.state[3]<<sh3,this.state[0]=this.state[1],this.state[1]=this.state[2],this.state[2]=this.state[3],this.state[3]=t}}const PROB_TOLERANCE=1e-8;function randomChoice(t,e={},r=Math.random){const{size:n=1,replace:i=!1,probabilities:o}=e;let s,a;if(s="number"==typeof t?getArray(t):t.slice(),o){if(!i)throw new Error("choice with probabilities and no replacement is not implemented");if(o.length!==s.length)throw new Error("the length of probabilities option should be equal to the number of choices");a=[o[0]];for(let t=1;t<o.length;t++)a[t]=a[t-1]+o[t];if(Math.abs(1-a[a.length-1])>PROB_TOLERANCE)throw new Error(`probabilities should sum to 1, but instead sums to ${a[a.length-1]}`)}if(!1===i&&n>s.length)throw new Error("size option is too large");const l=[];for(let t=0;t<n;t++){const t=randomIndex(s.length,r,a);l.push(s[t]),i||s.splice(t,1)}return l}function getArray(t){const e=[];for(let r=0;r<t;r++)e.push(r);return e}function randomIndex(t,e,r){const n=e();if(r){let t=0;for(;n>r[t];)t++;return t}return Math.floor(n*t)}class Random{constructor(t=Math.random){if("number"==typeof t){const e=new XSadd(t);this.randomGenerator=e.random}else this.randomGenerator=t}choice(t,e){return randomChoice(t,e,this.randomGenerator)}random(){return this.randomGenerator()}randInt(t,e){return void 0===e&&(e=t,t=0),t+Math.floor(this.randomGenerator()*(e-t))}randomSample(t){const e=[];for(let r=0;r<t;r++)e.push(this.random());return e}}function random(t,e,r){return new Random(r).choice(t,{size:e})}function mostDistant(t,e,r,n){const i=new Random(n);var o=new Array(e);if(o[0]=Math.floor(i.random()*t.length),e>1){for(var s={dist:-1,index:-1},a=0;a<t.length;++a)r[o[0]][a]>s.dist&&(s.dist=r[o[0]][a],s.index=a);if(o[1]=s.index,e>2)for(var l=2;l<e;++l){for(var h={dist:-1,index:-1},u=0;u<t.length;++u){for(var c={dist:Number.MAX_VALUE,index:-1},f=0;f<l;++f)r[f][u]<c.dist&&-1===o.indexOf(u)&&(c={dist:r[f][u],index:u});c.dist!==Number.MAX_VALUE&&c.dist>h.dist&&(h=Object.assign({},c))}o[l]=h.index}}return o.map((e=>t[e]))}function kmeanspp(t,e,r={}){const n=(t=new Matrix$2(t)).rows,i=new Random(r.seed),o=[],s=r.localTrials||2+Math.floor(Math.log(e)),a=i.randInt(n);o.push(t.getRow(a));let l=new Matrix$2(1,t.rows);for(let e=0;e<t.rows;e++)l.set(0,e,squaredEuclidean$4(t.getRow(e),o[0]));let h=[cumSum(l.getRow(0))];const u=1/h[0][n-1];let c=Matrix$2.mul(l,u);for(let r=1;r<e;r++){const e=i.choice(n,{replace:!0,size:s,probabilities:c[0]}),a=euclideanDistances(t.selection(e,range(t.columns)),t);let u,f,m;for(let t=0;t<s;t++){const r=Matrix$2.min(l,[a.getRow(t)]),n=r.sum();(void 0===u||n<f)&&(u=e[t],f=n,m=r)}o[r]=t.getRow(u),l=m,h=[cumSum(l.getRow(0))],c=Matrix$2.mul(l,1/h[0][n-1])}return o}function euclideanDistances(t,e){const r=new Matrix$2(t.rows,e.rows);for(let n=0;n<t.rows;n++)for(let i=0;i<e.rows;i++)r.set(n,i,squaredEuclidean$4(t.getRow(n),e.getRow(i)));return r}function range(t){let e=[];for(let r=0;r<t;r++)e.push(r);return e}function cumSum(t){let e=[t[0]];for(let r=1;r<t.length;r++)e[r]=e[r-1]+t[r];return e}const distanceSymbol=Symbol("distance");class KMeansResult{constructor(t,e,r,n,i){this.clusters=t,this.centroids=e,this.converged=r,this.iterations=n,this[distanceSymbol]=i}nearest(t){const e=new Array(t.length);return updateClusterID(t,this.centroids.map((function(t){return t.centroid})),e,this[distanceSymbol])}computeInformation(t){for(var e=this.centroids.map((function(t){return{centroid:t,error:0,size:0}})),r=0;r<t.length;r++)e[this.clusters[r]].error+=this[distanceSymbol](t[r],this.centroids[this.clusters[r]]),e[this.clusters[r]].size++;for(var n=0;n<this.centroids.length;n++)e[n].size?e[n].error/=e[n].size:e[n].error=null;return new KMeansResult(this.clusters,e,this.converged,this.iterations,this[distanceSymbol])}}const defaultOptions$c={maxIterations:100,tolerance:1e-6,withIterations:!1,initialization:"kmeans++",distanceFunction:squaredEuclidean$4};function step$1(t,e,r,n,i,o){var s=updateCenters(t,e,r=updateClusterID(e,t,r,i.distanceFunction),n),a=hasConverged(s,t,i.distanceFunction,i.tolerance);return new KMeansResult(r,s,a,o,i.distanceFunction)}function*kmeansGenerator(t,e,r,n,i){for(var o,s=!1,a=0;!s&&a<i.maxIterations;)o=step$1(t,e,r,n,i,++a),yield o.computeInformation(e),s=o.converged,t=o.centroids}function kmeans(t,e,r){if(r=Object.assign({},defaultOptions$c,r),e<=0||e>t.length||!Number.isInteger(e))throw new Error("K should be a positive integer smaller than the number of points");var n;if(Array.isArray(r.initialization)){if(r.initialization.length!==e)throw new Error("The initial centers should have the same length as K");n=r.initialization}else switch(r.initialization){case"kmeans++":n=kmeanspp(t,e,r);break;case"random":n=random(t,e,r.seed);break;case"mostDistant":n=mostDistant(t,e,calculateDistanceMatrix(t,r.distanceFunction),r.seed);break;default:throw new Error(`Unknown initialization method: "${r.initialization}"`)}0===r.maxIterations&&(r.maxIterations=Number.MAX_VALUE);var i=new Array(t.length);if(r.withIterations)return kmeansGenerator(n,t,i,e,r);for(var o,s=!1,a=0;!s&&a<r.maxIterations;)s=(o=step$1(n,t,i,e,r,++a)).converged,n=o.centroids;return o.computeInformation(t)}function separateClasses(t,e){for(var r=t.columns,n=0,i=new Array(1e4),o=0;o<e.length;o++)void 0===i[e[o]]&&(i[e[o]]=0,n++),i[e[o]]++;var s=new Array(n),a=new Array(n);for(o=0;o<n;++o)s[o]=new Matrix$2(i[o],r),a[o]=0;for(o=0;o<t.rows;++o)s[e[o]].setRow(a[e[o]],t.getRow(o)),a[e[o]]++;return s}class GaussianNB{constructor(t,e){t&&(this.means=e.means,this.calculateProbabilities=e.calculateProbabilities)}train(t,e){var r=Math.sqrt(2*Math.PI);if((t=Matrix$2.checkMatrix(t)).rows!==e.length)throw new RangeError("the size of the training set and the training labels must be the same.");var n=separateClasses(t,e),i=new Array(n.length);this.means=new Array(n.length);for(var o=0;o<n.length;++o){var s=n[o].mean("column"),a=n[o].standardDeviation("column",{mean:s}),l=Math.log(n[o].rows/t.rows);i[o]=new Array(s.length+1),i[o][0]=l;for(var h=1;h<s.length+1;++h){var u=a[h-1];i[o][h]=[1/(r*u),-2*u*u]}this.means[o]=s}this.calculateProbabilities=i}predict(t){if((t=Matrix$2.checkMatrix(t)).rows===this.calculateProbabilities[0].length)throw new RangeError("the dataset must have the same features as the training set");for(var e=new Array(t.rows),r=0;r<e.length;++r)e[r]=getCurrentClass(t.getRow(r),this.means,this.calculateProbabilities);return e}toJSON(){return{modelName:"NaiveBayes",means:this.means,calculateProbabilities:this.calculateProbabilities}}static load(t){if("NaiveBayes"!==t.modelName)throw new RangeError("The current model is not a Multinomial Naive Bayes, current model:",t.name);return new GaussianNB(!0,t)}}function getCurrentClass(t,e,r){for(var n=0,i=-1,o=0;o<r.length;++o){for(var s=r[o][0],a=1;a<r[0][1].length+1;++a)s+=calculateLogProbability(t[a-1],e[o][a-1],r[o][a][0],r[o][a][1]);(s=Math.exp(s))>n&&(n=s,i=o)}return i}function calculateLogProbability(t,e,r,n){return t-=e,Math.log(r*Math.exp(t*t/n))}class MultinomialNB{constructor(t){t&&(this.conditionalProbability=Matrix$2.checkMatrix(t.conditionalProbability),this.priorProbability=Matrix$2.checkMatrix(t.priorProbability))}train(t,e){if((t=Matrix$2.checkMatrix(t)).rows!==e.length)throw new RangeError("the size of the training set and the training labels must be the same.");var r=separateClasses(t,e);this.priorProbability=new Matrix$2(r.length,1);for(var n=0;n<r.length;++n)this.priorProbability.set(n,0,Math.log(r[n].rows/t.rows));var i=t.columns;for(this.conditionalProbability=new Matrix$2(r.length,i),n=0;n<r.length;++n){var o=Matrix$2.checkMatrix(r[n]),s=o.sum()+i;this.conditionalProbability.setRow(n,Matrix$2.rowVector(o.sum("column")).add(1).div(s).apply(matrixLog))}}predict(t){t=Matrix$2.checkMatrix(t);for(var e=new Array(t.rows),r=0;r<t.rows;++r){var n=t.getRowVector(r);const i=Matrix$2.columnVector(this.conditionalProbability.clone().mulRowVector(n).sum("row"));e[r]=i.add(this.priorProbability).maxIndex()[0]}return e}toJSON(){return{name:"MultinomialNB",priorProbability:this.priorProbability,conditionalProbability:this.conditionalProbability}}static load(t){if("MultinomialNB"!==t.name)throw new RangeError(`${t.name} is not a Multinomial Naive Bayes`);return new MultinomialNB(t)}}function matrixLog(t,e){this.set(t,e,Math.log(this.get(t,e)))}var index$4=Object.freeze({__proto__:null,GaussianNB:GaussianNB,MultinomialNB:MultinomialNB});
/*
   * Original code from:
   *
   * k-d Tree JavaScript - V 1.01
   *
   * https://github.com/ubilabs/kd-tree-javascript
   *
   * @author Mircea Pricop <pricop@ubilabs.net>, 2012
   * @author Martin Kleppe <kleppe@ubilabs.net>, 2012
   * @author Ubilabs http://ubilabs.net, 2012
   * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
   */function Node(t,e,r){this.obj=t,this.left=null,this.right=null,this.parent=r,this.dimension=e}class KDTree{constructor(t,e){if(Array.isArray(t)){this.dimensions=new Array(t[0].length);for(var r=0;r<this.dimensions.length;r++)this.dimensions[r]=r;this.root=buildTree(t,0,null,this.dimensions)}else this.dimensions=t.dimensions,this.root=t,restoreParent(this.root);this.metric=e}toJSON(){const t=toJSONImpl(this.root);return t.dimensions=this.dimensions,t}nearest(t,e,r){const n=this.metric,i=this.dimensions;var o;const s=new BinaryHeap((function(t){return-t[1]}));if(r)for(o=0;o<e;o+=1)s.push([null,r]);this.root&&function r(o){const a=i[o.dimension],l=n(t,o.obj),h={};var u,c,f,m;function g(t,r){s.push([t,r]),s.size()>e&&s.pop()}for(m=0;m<i.length;m+=1)m===o.dimension?h[i[m]]=t[i[m]]:h[i[m]]=o.obj[i[m]];c=n(h,o.obj),null!==o.right||null!==o.left?(r(u=null===o.right?o.left:null===o.left?o.right:t[a]<o.obj[a]?o.left:o.right),(s.size()<e||l<s.peek()[1])&&g(o,l),(s.size()<e||Math.abs(c)<s.peek()[1])&&null!==(f=u===o.left?o.right:o.left)&&r(f)):(s.size()<e||l<s.peek()[1])&&g(o,l)}(this.root);const a=[];for(o=0;o<Math.min(e,s.content.length);o+=1)s.content[o][0]&&a.push([s.content[o][0].obj,s.content[o][1]]);return a}}function toJSONImpl(t){const e=new Node(t.obj,t.dimension,null);return t.left&&(e.left=toJSONImpl(t.left)),t.right&&(e.right=toJSONImpl(t.right)),e}function buildTree(t,e,r,n){const i=e%n.length;if(0===t.length)return null;if(1===t.length)return new Node(t[0],i,r);t.sort(((t,e)=>t[n[i]]-e[n[i]]));const o=Math.floor(t.length/2),s=new Node(t[o],i,r);return s.left=buildTree(t.slice(0,o),e+1,s,n),s.right=buildTree(t.slice(o+1),e+1,s,n),s}function restoreParent(t){t.left&&(t.left.parent=t,restoreParent(t.left)),t.right&&(t.right.parent=t,restoreParent(t.right))}class BinaryHeap{constructor(t){this.content=[],this.scoreFunction=t}push(t){this.content.push(t),this.bubbleUp(this.content.length-1)}pop(){var t=this.content[0],e=this.content.pop();return this.content.length>0&&(this.content[0]=e,this.sinkDown(0)),t}peek(){return this.content[0]}size(){return this.content.length}bubbleUp(t){for(var e=this.content[t];t>0;){const r=Math.floor((t+1)/2)-1,n=this.content[r];if(!(this.scoreFunction(e)<this.scoreFunction(n)))break;this.content[r]=e,this.content[t]=n,t=r}}sinkDown(t){for(var e=this.content.length,r=this.content[t],n=this.scoreFunction(r);;){var i=2*(t+1),o=i-1,s=null;if(o<e){var a=this.content[o],l=this.scoreFunction(a);l<n&&(s=o)}if(i<e){var h=this.content[i];this.scoreFunction(h)<(null===s?n:l)&&(s=i)}if(null===s)break;this.content[t]=this.content[s],this.content[s]=r,t=s}}}class KNN{constructor(t,e,r={}){if(!0===t){const t=e;return this.kdTree=new KDTree(t.kdTree,r),this.k=t.k,this.classes=new Set(t.classes),void(this.isEuclidean=t.isEuclidean)}const n=new Set(e),{distance:i=euclidean$2,k:o=n.size+1}=r,s=new Array(t.length);for(var a=0;a<s.length;++a)s[a]=t[a].slice();for(a=0;a<e.length;++a)s[a].push(e[a]);this.kdTree=new KDTree(s,i),this.k=o,this.classes=n,this.isEuclidean=i===euclidean$2}static load(t,e=euclidean$2){if("KNN"!==t.name)throw new Error(`invalid model: ${t.name}`);if(!t.isEuclidean&&e===euclidean$2)throw new Error("a custom distance function was used to create the model. Please provide it again");if(t.isEuclidean&&e!==euclidean$2)throw new Error("the model was created with the default distance function. Do not load it with another one");return new KNN(!0,t,e)}toJSON(){return{name:"KNN",kdTree:this.kdTree,k:this.k,classes:Array.from(this.classes),isEuclidean:this.isEuclidean}}predict(t){if(Array.isArray(t)){if("number"==typeof t[0])return getSinglePrediction(this,t);if(Array.isArray(t[0])&&"number"==typeof t[0][0]){const r=new Array(t.length);for(var e=0;e<t.length;e++)r[e]=getSinglePrediction(this,t[e]);return r}}throw new TypeError("dataset to predict must be an array or a matrix")}}function getSinglePrediction(t,e){var r=t.kdTree.nearest(e,t.k),n={},i=-1,o=-1,s=r[0][0].length-1;for(var a of t.classes)n[a]=0;for(var l=0;l<r.length;++l){var h=r[l][0][s],u=++n[h];u>o&&(i=h,o=u)}return i}function norm$1(t){return Math.sqrt(t.clone().apply(pow2array).sum())}function pow2array(t,e){this.set(t,e,this.get(t,e)**2)}function initializeMatrices(t,e){if(e)for(let e=0;e<t.length;++e)for(let r=0;r<t[e].length;++r){let n=t[e][r];t[e][r]=null!==n?new Matrix$2(t[e][r]):void 0}else for(let e=0;e<t.length;++e)t[e]=new Matrix$2(t[e]);return t}class PLS{constructor(t,e){if(!0===t)this.meanX=e.meanX,this.stdDevX=e.stdDevX,this.meanY=e.meanY,this.stdDevY=e.stdDevY,this.PBQ=Matrix$2.checkMatrix(e.PBQ),this.R2X=e.R2X,this.scale=e.scale,this.scaleMethod=e.scaleMethod,this.tolerance=e.tolerance;else{let{tolerance:e=1e-5,scale:r=!0}=t;this.tolerance=e,this.scale=r,this.latentVectors=t.latentVectors}}train(t,e){if(t=Matrix$2.checkMatrix(t),e=Matrix$2.checkMatrix(e),t.length!==e.length)throw new RangeError("The number of X rows must be equal to the number of Y rows");this.meanX=t.mean("column"),this.stdDevX=t.standardDeviation("column",{mean:this.meanX,unbiased:!0}),this.meanY=e.mean("column"),this.stdDevY=e.standardDeviation("column",{mean:this.meanY,unbiased:!0}),this.scale&&(t=t.clone().subRowVector(this.meanX).divRowVector(this.stdDevX),e=e.clone().subRowVector(this.meanY).divRowVector(this.stdDevY)),void 0===this.latentVectors&&(this.latentVectors=Math.min(t.rows-1,t.columns));let r,n,i,o,s=t.rows,a=t.columns,l=e.rows,h=e.columns,u=t.clone().mul(t).sum(),c=e.clone().mul(e).sum(),f=this.tolerance,m=this.latentVectors,g=Matrix$2.zeros(s,m),d=Matrix$2.zeros(a,m),p=Matrix$2.zeros(l,m),w=Matrix$2.zeros(h,m),x=Matrix$2.zeros(m,m),y=d.clone(),M=0;for(;norm$1(e)>f&&M<m;){let a=t.transpose(),l=e.transpose(),h=maxSumColIndex(t.clone().mul(t)),u=maxSumColIndex(e.clone().mul(e)),c=t.getColumnVector(h),m=e.getColumnVector(u);for(r=Matrix$2.zeros(s,1);norm$1(c.clone().sub(r))>f;)n=a.mmul(m),n.div(norm$1(n)),r=c,c=t.mmul(n),i=l.mmul(c),i.div(norm$1(i)),m=e.mmul(i);r=c;let v=a.mmul(r),b=r.transpose().mmul(r).get(0,0);o=v.div(b);let S=norm$1(o);o.div(S),r.mul(S),n.mul(S),v=m.transpose().mmul(r),b=r.transpose().mmul(r).get(0,0);let A=v.div(b).get(0,0);t.sub(r.mmul(o.transpose())),e.sub(r.clone().mul(A).mmul(i.transpose())),g.setColumn(M,r),d.setColumn(M,o),p.setColumn(M,m),w.setColumn(M,i),y.setColumn(M,n),x.set(M,M,A),M++}M--,g=g.subMatrix(0,g.rows-1,0,M),d=d.subMatrix(0,d.rows-1,0,M),p=p.subMatrix(0,p.rows-1,0,M),w=w.subMatrix(0,w.rows-1,0,M),y=y.subMatrix(0,y.rows-1,0,M),x=x.subMatrix(0,M,0,M),this.ssqYcal=c,this.E=t,this.F=e,this.T=g,this.P=d,this.U=p,this.Q=w,this.W=y,this.B=x,this.PBQ=d.mmul(x).mmul(w.transpose()),this.R2X=r.transpose().mmul(r).mmul(o.transpose().mmul(o)).div(u).get(0,0)}predict(t){let e=Matrix$2.checkMatrix(t);this.scale&&(e=e.subRowVector(this.meanX).divRowVector(this.stdDevX));let r=e.mmul(this.PBQ);return r=r.mulRowVector(this.stdDevY).addRowVector(this.meanY),r}getExplainedVariance(){return this.R2X}toJSON(){return{name:"PLS",R2X:this.R2X,meanX:this.meanX,stdDevX:this.stdDevX,meanY:this.meanY,stdDevY:this.stdDevY,PBQ:this.PBQ,tolerance:this.tolerance,scale:this.scale}}static load(t){if("PLS"!==t.name)throw new RangeError(`Invalid model: ${t.name}`);return new PLS(!0,t)}}function maxSumColIndex(t){return Matrix$2.rowVector(t.sum("column")).maxIndex()[0]}class KOPLS{constructor(t,e){if(!0===t)this.trainingSet=new Matrix$2(e.trainingSet),this.YLoadingMat=new Matrix$2(e.YLoadingMat),this.SigmaPow=new Matrix$2(e.SigmaPow),this.YScoreMat=new Matrix$2(e.YScoreMat),this.predScoreMat=initializeMatrices(e.predScoreMat,!1),this.YOrthLoadingVec=initializeMatrices(e.YOrthLoadingVec,!1),this.YOrthEigen=e.YOrthEigen,this.YOrthScoreMat=initializeMatrices(e.YOrthScoreMat,!1),this.toNorm=initializeMatrices(e.toNorm,!1),this.TURegressionCoeff=initializeMatrices(e.TURegressionCoeff,!1),this.kernelX=initializeMatrices(e.kernelX,!0),this.kernel=e.kernel,this.orthogonalComp=e.orthogonalComp,this.predictiveComp=e.predictiveComp;else{if(void 0===t.predictiveComponents)throw new RangeError("no predictive components found!");if(void 0===t.orthogonalComponents)throw new RangeError("no orthogonal components found!");if(void 0===t.kernel)throw new RangeError("no kernel found!");this.orthogonalComp=t.orthogonalComponents,this.predictiveComp=t.predictiveComponents,this.kernel=t.kernel}}train(t,e){t=Matrix$2.checkMatrix(t),e=Matrix$2.checkMatrix(e),this.trainingSet=t.clone();let r=this.kernel.compute(t),n=Matrix$2.eye(r.rows,r.rows,1),i=r;r=new Array(this.orthogonalComp+1);for(let t=0;t<this.orthogonalComp+1;t++)r[t]=new Array(this.orthogonalComp+1);r[0][0]=i;let o=new SingularValueDecomposition(e.transpose().mmul(r[0][0]).mmul(e),{computeLeftSingularVectors:!0,computeRightSingularVectors:!1}),s=o.leftSingularVectors,a=o.diagonalMatrix;s=s.subMatrix(0,s.rows-1,0,this.predictiveComp-1),a=a.subMatrix(0,this.predictiveComp-1,0,this.predictiveComp-1);let l=e.mmul(s),h=new Array(this.orthogonalComp+1),u=new Array(this.orthogonalComp+1),c=new Array(this.orthogonalComp),f=new Array(this.orthogonalComp),m=new Array(this.orthogonalComp),g=new Array(this.orthogonalComp),d=Matrix$2.pow(a,-.5);d.apply((function(t,e){this.get(t,e)===1/0&&this.set(t,e,0)}));for(let t=0;t<this.orthogonalComp;++t){h[t]=r[0][t].transpose().mmul(l).mmul(d);let e=h[t].transpose();u[t]=inverse(e.mmul(h[t])).mmul(e).mmul(l),o=new SingularValueDecomposition(e.mmul(Matrix$2.sub(r[t][t],h[t].mmul(e))).mmul(h[t]),{computeLeftSingularVectors:!0,computeRightSingularVectors:!1});let i=o.leftSingularVectors,s=o.diagonalMatrix;f[t]=i.subMatrix(0,i.rows-1,0,0),m[t]=s.get(0,0),c[t]=Matrix$2.sub(r[t][t],h[t].mmul(e)).mmul(h[t]).mmul(f[t]).mul(Math.pow(m[t],-.5));let a=c[t].transpose();g[t]=Matrix$2.sqrt(a.mmul(c[t])),c[t]=c[t].divRowVector(g[t]);let p=Matrix$2.sub(n,c[t].mmul(c[t].transpose()));r[0][t+1]=r[0][t].mmul(p),r[t+1][t+1]=p.mmul(r[t][t]).mmul(p)}let p=h[this.orthogonalComp]=r[0][this.orthogonalComp].transpose().mmul(l).mmul(d),w=p.transpose();u[this.orthogonalComp]=inverse(w.mmul(p)).mmul(w).mmul(l),this.YLoadingMat=s,this.SigmaPow=d,this.YScoreMat=l,this.predScoreMat=h,this.YOrthLoadingVec=f,this.YOrthEigen=m,this.YOrthScoreMat=c,this.toNorm=g,this.TURegressionCoeff=u,this.kernelX=r}predict(t){let e=this.kernel.compute(t,this.trainingSet),r=e;e=new Array(this.orthogonalComp+1);for(let t=0;t<this.orthogonalComp+1;t++)e[t]=new Array(this.orthogonalComp+1);e[0][0]=r;let n,i=new Array(this.orthogonalComp),o=new Array(this.orthogonalComp);for(n=0;n<this.orthogonalComp;++n){o[n]=e[n][0].mmul(this.YScoreMat).mmul(this.SigmaPow),i[n]=Matrix$2.sub(e[n][n],o[n].mmul(this.predScoreMat[n].transpose())).mmul(this.predScoreMat[n]).mmul(this.YOrthLoadingVec[n]).mul(Math.pow(this.YOrthEigen[n],-.5)),i[n]=i[n].divRowVector(this.toNorm[n]);let t=this.YOrthScoreMat[n].transpose();e[n+1][0]=Matrix$2.sub(e[n][0],i[n].mmul(t).mmul(this.kernelX[0][n].transpose()));let r=Matrix$2.sub(e[n][0],e[n][n].mmul(this.YOrthScoreMat[n]).mmul(t)),s=i[n].mmul(t).mmul(this.kernelX[n][n]),a=s.mmul(this.YOrthScoreMat[n]).mmul(t);e[n+1][n+1]=r.sub(s).add(a)}return o[n]=e[n][0].mmul(this.YScoreMat).mmul(this.SigmaPow),{prediction:o[n].mmul(this.TURegressionCoeff[n]).mmul(this.YLoadingMat.transpose()),predScoreMat:o,predYOrthVectors:i}}toJSON(){return{name:"K-OPLS",YLoadingMat:this.YLoadingMat,SigmaPow:this.SigmaPow,YScoreMat:this.YScoreMat,predScoreMat:this.predScoreMat,YOrthLoadingVec:this.YOrthLoadingVec,YOrthEigen:this.YOrthEigen,YOrthScoreMat:this.YOrthScoreMat,toNorm:this.toNorm,TURegressionCoeff:this.TURegressionCoeff,kernelX:this.kernelX,trainingSet:this.trainingSet,orthogonalComp:this.orthogonalComp,predictiveComp:this.predictiveComp}}static load(t,e){if("K-OPLS"!==t.name)throw new RangeError(`Invalid model: ${t.name}`);if(!e)throw new RangeError("You must provide a kernel for the model!");return t.kernel=e,new KOPLS(!0,t)}}class ConfusionMatrix{constructor(t,e){if(t.length!==t[0].length)throw new Error("Confusion matrix must be square");if(e.length!==t.length)throw new Error("Confusion matrix and labels should have the same length");this.labels=e,this.matrix=t}static fromLabels(t,e,r={}){if(e.length!==t.length)throw new Error("predicted and actual must have the same length");let n;n=r.labels?new Set(r.labels):new Set([...t,...e]),n=Array.from(n),r.sort&&n.sort(r.sort);const i=Array.from({length:n.length});for(let t=0;t<i.length;t++)i[t]=new Array(i.length),i[t].fill(0);for(let r=0;r<e.length;r++){const o=n.indexOf(t[r]),s=n.indexOf(e[r]);o>=0&&s>=0&&i[o][s]++}return new ConfusionMatrix(i,n)}getMatrix(){return this.matrix}getLabels(){return this.labels}getTotalCount(){let t=0;for(let e=0;e<this.matrix.length;e++)for(let r=0;r<this.matrix.length;r++)t+=this.matrix[e][r];return t}getTrueCount(){let t=0;for(let e=0;e<this.matrix.length;e++)t+=this.matrix[e][e];return t}getFalseCount(){return this.getTotalCount()-this.getTrueCount()}getTruePositiveCount(t){const e=this.getIndex(t);return this.matrix[e][e]}getTrueNegativeCount(t){const e=this.getIndex(t);let r=0;for(let t=0;t<this.matrix.length;t++)for(let n=0;n<this.matrix.length;n++)t!==e&&n!==e&&(r+=this.matrix[t][n]);return r}getFalsePositiveCount(t){const e=this.getIndex(t);let r=0;for(let t=0;t<this.matrix.length;t++)t!==e&&(r+=this.matrix[t][e]);return r}getFalseNegativeCount(t){const e=this.getIndex(t);let r=0;for(let t=0;t<this.matrix.length;t++)t!==e&&(r+=this.matrix[e][t]);return r}getPositiveCount(t){return this.getTruePositiveCount(t)+this.getFalseNegativeCount(t)}getNegativeCount(t){return this.getTrueNegativeCount(t)+this.getFalsePositiveCount(t)}getIndex(t){const e=this.labels.indexOf(t);if(-1===e)throw new Error("The label does not exist");return e}getTruePositiveRate(t){return this.getTruePositiveCount(t)/this.getPositiveCount(t)}getTrueNegativeRate(t){return this.getTrueNegativeCount(t)/this.getNegativeCount(t)}getPositivePredictiveValue(t){const e=this.getTruePositiveCount(t);return e/(e+this.getFalsePositiveCount(t))}getNegativePredictiveValue(t){const e=this.getTrueNegativeCount(t);return e/(e+this.getFalseNegativeCount(t))}getFalseNegativeRate(t){return 1-this.getTruePositiveRate(t)}getFalsePositiveRate(t){return 1-this.getTrueNegativeRate(t)}getFalseDiscoveryRate(t){const e=this.getFalsePositiveCount(t);return e/(e+this.getTruePositiveCount(t))}getFalseOmissionRate(t){const e=this.getFalseNegativeCount(t);return e/(e+this.getTruePositiveCount(t))}getF1Score(t){const e=this.getTruePositiveCount(t);return 2*e/(2*e+this.getFalsePositiveCount(t)+this.getFalseNegativeCount(t))}getMatthewsCorrelationCoefficient(t){const e=this.getTruePositiveCount(t),r=this.getTrueNegativeCount(t),n=this.getFalsePositiveCount(t),i=this.getFalseNegativeCount(t);return(e*r-n*i)/Math.sqrt((e+n)*(e+i)*(r+n)*(r+i))}getInformedness(t){return this.getTruePositiveRate(t)+this.getTrueNegativeRate(t)-1}getMarkedness(t){return this.getPositivePredictiveValue(t)+this.getNegativePredictiveValue(t)-1}getConfusionTable(t){return[[this.getTruePositiveCount(t),this.getFalseNegativeCount(t)],[this.getFalsePositiveCount(t),this.getTrueNegativeCount(t)]]}getAccuracy(){let t=0,e=0;for(let r=0;r<this.matrix.length;r++)for(let n=0;n<this.matrix.length;n++)r===n?t+=this.matrix[r][n]:e+=this.matrix[r][n];return t/(t+e)}getCount(t,e){const r=this.getIndex(t),n=this.getIndex(e);return this.matrix[r][n]}get accuracy(){return this.getAccuracy()}get total(){return this.getTotalCount()}}var lib=createCommonjsModule((function(t,e){!function(){function e(t,e){return t(e={exports:{}},e.exports),e.exports}var r=e((function(t){!function(e){var r,n=Object.prototype,i=n.hasOwnProperty,o="function"==typeof Symbol?Symbol:{},s=o.iterator||"@@iterator",a=o.asyncIterator||"@@asyncIterator",l=o.toStringTag||"@@toStringTag",h=e.regeneratorRuntime;if(h)t.exports=h;else{(h=e.regeneratorRuntime=t.exports).wrap=y;var u="suspendedStart",c="suspendedYield",f="executing",m="completed",g={},d={};d[s]=function(){return this};var p=Object.getPrototypeOf,w=p&&p(p(C([])));w&&w!==n&&i.call(w,s)&&(d=w);var x=S.prototype=v.prototype=Object.create(d);b.prototype=x.constructor=S,S.constructor=b,S[l]=b.displayName="GeneratorFunction",h.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===b||"GeneratorFunction"===(e.displayName||e.name))},h.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,S):(t.__proto__=S,l in t||(t[l]="GeneratorFunction")),t.prototype=Object.create(x),t},h.awrap=function(t){return{__await:t}},A(E.prototype),E.prototype[a]=function(){return this},h.AsyncIterator=E,h.async=function(t,e,r,n){var i=new E(y(t,e,r,n));return h.isGeneratorFunction(e)?i:i.next().then((function(t){return t.done?t.value:i.next()}))},A(x),x[l]="Generator",x[s]=function(){return this},x.toString=function(){return"[object Generator]"},h.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},h.values=C,T.prototype={constructor:T,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=r,this.done=!1,this.delegate=null,this.method="next",this.arg=r,this.tryEntries.forEach(k),!t)for(var e in this)"t"===e.charAt(0)&&i.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=r)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var e=this;function n(n,i){return a.type="throw",a.arg=t,e.next=n,i&&(e.method="next",e.arg=r),!!i}for(var o=this.tryEntries.length-1;o>=0;--o){var s=this.tryEntries[o],a=s.completion;if("root"===s.tryLoc)return n("end");if(s.tryLoc<=this.prev){var l=i.call(s,"catchLoc"),h=i.call(s,"finallyLoc");if(l&&h){if(this.prev<s.catchLoc)return n(s.catchLoc,!0);if(this.prev<s.finallyLoc)return n(s.finallyLoc)}else if(l){if(this.prev<s.catchLoc)return n(s.catchLoc,!0)}else{if(!h)throw new Error("try statement without catch or finally");if(this.prev<s.finallyLoc)return n(s.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&i.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var o=n;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var s=o?o.completion:{};return s.type=t,s.arg=e,o?(this.method="next",this.next=o.finallyLoc,g):this.complete(s)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),g},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),k(r),g}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var i=n.arg;k(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,e,n){return this.delegate={iterator:C(t),resultName:e,nextLoc:n},"next"===this.method&&(this.arg=r),g}}}function y(t,e,r,n){var i=e&&e.prototype instanceof v?e:v,o=Object.create(i.prototype),s=new T(n||[]);return o._invoke=R(t,r,s),o}function M(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}function v(){}function b(){}function S(){}function A(t){["next","throw","return"].forEach((function(e){t[e]=function(t){return this._invoke(e,t)}}))}function E(t){function e(r,n,o,s){var a=M(t[r],t,n);if("throw"!==a.type){var l=a.arg,h=l.value;return h&&"object"==typeof h&&i.call(h,"__await")?Promise.resolve(h.__await).then((function(t){e("next",t,o,s)}),(function(t){e("throw",t,o,s)})):Promise.resolve(h).then((function(t){l.value=t,o(l)}),s)}s(a.arg)}var r;function n(t,n){function i(){return new Promise((function(r,i){e(t,n,r,i)}))}return r=r?r.then(i,i):i()}this._invoke=n}function R(t,e,r){var n=u;return function(i,o){if(n===f)throw new Error("Generator is already running");if(n===m){if("throw"===i)throw o;return O()}for(r.method=i,r.arg=o;;){var s=r.delegate;if(s){var a=N(s,r);if(a){if(a===g)continue;return a}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===u)throw n=m,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=f;var l=M(t,e,r);if("normal"===l.type){if(n=r.done?m:c,l.arg===g)continue;return{value:l.arg,done:r.done}}"throw"===l.type&&(n=m,r.method="throw",r.arg=l.arg)}}}function N(t,e){var n=t.iterator[e.method];if(n===r){if(e.delegate=null,"throw"===e.method){if(t.iterator.return&&(e.method="return",e.arg=r,N(t,e),"throw"===e.method))return g;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return g}var i=M(n,t.iterator,e.arg);if("throw"===i.type)return e.method="throw",e.arg=i.arg,e.delegate=null,g;var o=i.arg;return o?o.done?(e[t.resultName]=o.value,e.next=t.nextLoc,"return"!==e.method&&(e.method="next",e.arg=r),e.delegate=null,g):o:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,g)}function $(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function k(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function T(t){this.tryEntries=[{tryLoc:"root"}],t.forEach($,this),this.reset(!0)}function C(t){if(t){var e=t[s];if(e)return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var n=-1,o=function e(){for(;++n<t.length;)if(i.call(t,n))return e.value=t[n],e.done=!1,e;return e.value=r,e.done=!0,e};return o.next=o}}return{next:O}}function O(){return{value:r,done:!0}}}(function(){return this}()||Function("return this")())})),n=function(){return this}()||Function("return this")(),i=n.regeneratorRuntime&&Object.getOwnPropertyNames(n).indexOf("regeneratorRuntime")>=0,o=i&&n.regeneratorRuntime;n.regeneratorRuntime=void 0;var s=r;if(i)n.regeneratorRuntime=o;else try{delete n.regeneratorRuntime}catch(t){n.regeneratorRuntime=void 0}var a=s,l={mode:"index"};t.exports=a.mark((function t(e,r,n){var i,o,s,h,u,c,f,m,g;return a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:for(g=function(){var t,e,r;for(e=1;h[e]<=0;)e++;if(0===h[e-1]){for(t=e-1;1!==t;t--)h[t]=-1;h[e]=0,u=f=0,h[1]=1,c=e-1}else{e>1&&(h[e-1]=0);do{e++}while(h[e]>0);for(r=e-1,t=e;0===h[t];)h[t++]=-1;if(-1===h[t])h[t]=h[r],f=h[r]-1,u=t-1,c=r-1,h[r]=-1;else{if(t===h[0])return 0;h[e]=h[t],f=h[t]-1,h[t]=0,u=e-1,c=t-1}}return 1},n=Object.assign({},l,n),i=new Array(r),o=new Array(e),s=new Array(r),h=new Array(r+2),m=0;m<r;m++)i[m]=m,s[m]=m<r-e?0:1;for(m=0;m<e;m++)o[m]=r-e+m;for(m=0;m<h.length;m++)h[m]=0===m?r+1:m<=r-e?0:m<=r?m-r+e:-2;if("index"!==n.mode){t.next=20;break}return t.next=12,o.slice();case 12:if(!g()){t.next=18;break}return o[f]=i[u],t.next=16,o.slice();case 16:t.next=12;break;case 18:t.next=33;break;case 20:if("mask"!==n.mode){t.next=32;break}return t.next=23,s.slice();case 23:if(!g()){t.next=30;break}return s[u]=1,s[c]=0,t.next=28,s.slice();case 28:t.next=23;break;case 30:t.next=33;break;case 32:throw new Error("Invalid mode");case 33:case"end":return t.stop()}}),t,this)}))}()}));function getFolds(t,e=5){let r=t.length,n=new Array(r);for(let t=0;t<r;t++)n[t]=t;let i=Math.floor(r/e),o=[],s=[];for(;n.length;){let t=Math.floor(Math.random()*n.length);o.push(n[t]),n.splice(t,1),o.length===i&&(s.push(o),o=[])}return o.length&&o.forEach((t=>s[e-1].push(t))),s=s.slice(0,e),s.map(((t,e)=>({testIndex:t,trainIndex:[].concat(...s.filter(((t,r)=>r!==e)))})))}function sampleAClass(t,e){let r=JSON.parse(JSON.stringify(t)),n=Array.from(Array(r.length).keys()).sort(((t,e)=>r[t]<r[e]?-1:r[e]<r[t]|0));r.sort(((t,e)=>t<e?-1:e<t|0));let i={};r.forEach((t=>i[t]=(i[t]||0)+1));let o=[];Object.keys(i).forEach(((t,r)=>{let n=[];Object.values(i).reduce(((t,e,r)=>n[r]=t+e),0);let s=[...Array(i[t]).keys()],a=[];for(let r=0;r<Math.floor(i[t]*e);r++){let t=s[Math.floor(Math.random()*s.length)];a.push(t);let e=s.indexOf(t);s.splice(e,1)}o=0===r?o.concat(a):o.concat(a.map((t=>t+n[r-1])))}));let s=[];o.forEach((t=>s.push(n[t])));let a=[],l=[];return t.forEach(((t,e)=>{s.includes(e)?l.push(!0):(l.push(!1),a.push(e))})),{trainIndex:s,testIndex:a,mask:l}}function leaveOneOut(t,e,r,n){if("function"==typeof r){let n=r;return r=e,leavePOut(e=t,r,1,n)}return leavePOut(t,e,r,n,1)}function leavePOut(t,e,r,n,i){let o;"function"==typeof n&&(o=n,i=r,r=e,e=t),check(e,r);const s=getDistinct(r),a=initMatrix(s.length,s.length);let l=e.length,h=lib(i,l),u=new Array(l);for(let t=0;t<l;t++)u[t]=t;for(const i of h){let l=u.slice();for(let t=i.length-1;t>=0;t--)l.splice(i[t],1);o?validateWithCallback(e,r,i,l,a,s,o):validate(t,e,r,n,i,l,a,s)}return new ConfusionMatrix(a,s)}function kFold(t,e,r,n,i){let o;"function"==typeof n&&(o=n,i=r,r=e,e=t),check(e,r);const s=getDistinct(r),a=initMatrix(s.length,s.length);let l=getFolds(e,i);for(let i=0;i<l.length;i++){let h=l[i].testIndex,u=l[i].trainIndex;o?validateWithCallback(e,r,h,u,a,s,o):validate(t,e,r,n,h,u,a,s)}return new ConfusionMatrix(a,s)}function check(t,e){if(t.length!==e.length)throw new Error("features and labels should have the same length")}function initMatrix(t,e){return new Array(t).fill(0).map((()=>new Array(e).fill(0)))}function getDistinct(t){let e=new Set;for(let r=0;r<t.length;r++)e.add(t[r]);return Array.from(e)}function validate(t,e,r,n,i,o,s,a){const{testFeatures:l,trainFeatures:h,testLabels:u,trainLabels:c}=getTrainTest(e,r,i,o);let f;t.prototype.train?(f=new t(n),f.train(h,c)):f=new t(h,c,n),updateConfusionMatrix(s,u,f.predict(l),a)}function validateWithCallback(t,e,r,n,i,o,s){const{testFeatures:a,trainFeatures:l,testLabels:h,trainLabels:u}=getTrainTest(t,e,r,n);updateConfusionMatrix(i,h,s(l,u,a),o)}function updateConfusionMatrix(t,e,r,n){for(let i=0;i<r.length;i++){const o=n.indexOf(e[i]),s=n.indexOf(r[i]);(o<0||s<0)&&console.warn(`ignore unknown predicted label ${r[i]}`),t[o][s]++}}function getTrainTest(t,e,r,n){return{testFeatures:r.map((function(e){return t[e]})),trainFeatures:n.map((function(e){return t[e]})),testLabels:r.map((function(t){return e[t]})),trainLabels:n.map((function(t){return e[t]}))}}var index$3=Object.freeze({__proto__:null,leaveOneOut:leaveOneOut,leavePOut:leavePOut,kFold:kFold,getTrainTest:getTrainTest,sampleAClass:sampleAClass,getFolds:getFolds});function OPLSNipals(t,e,r={}){const{numberOSC:n=100}=r;let i,o,s,a,l=Matrix$2.checkMatrix(t),h=Matrix$2.checkMatrix(e),u=h.getColumnVector(0),c=1;for(let t=0;t<n&&c>1e-10;t++)s=u.transpose().mmul(l).div(u.transpose().mmul(u).get(0,0)),s=s.transpose().div(norm$1(s)),i=l.mmul(s).div(s.transpose().mmul(s).get(0,0)),o=i.transpose().mmul(h).div(i.transpose().mmul(i).get(0,0)),a=h.mmul(o.transpose()),a=a.div(o.transpose().mmul(o).get(0,0)),t>0&&(c=a.clone().sub(u).pow(2).sum()/a.clone().pow(2).sum()),u=a.clone();let f=i.transpose().mmul(l).div(i.transpose().mmul(i).get(0,0)),m=f.clone().sub(s.transpose().mmul(f.transpose()).div(s.transpose().mmul(s).get(0,0)).mmul(s.transpose()));m.div(norm$1(m));let g=l.mmul(m.transpose()).div(m.mmul(m.transpose()).get(0,0)),d=g.transpose().mmul(l).div(g.transpose().mmul(g).get(0,0));return{filteredX:l.clone().sub(g.mmul(d)),weightsXOrtho:m,loadingsXOrtho:d,scoresXOrtho:g,weightsXPred:s,loadingsXpred:f,scoresXpred:i,loadingsY:o}}function tss(t){return Matrix$2.mul(t,t).sum()}class OPLS{constructor(t,e,r={}){if(!0===t){const t=r;return this.center=t.center,this.scale=t.scale,this.means=t.means,this.meansY=t.meansY,this.stdevs=t.stdevs,this.stdevs=t.stdevsY,this.model=t.model,this.tCV=t.tCV,this.tOrthCV=t.tOrthCV,this.yHatCV=t.yHatCV,void(this.mode=t.mode)}let n=t.clone();const{nComp:i=3,center:o=!0,scale:s=!0,cvFolds:a=[]}=r;let l,h;if("number"==typeof e[0])this.mode="regression",l=Matrix$2.from1DArray(e.length,1,e);else if("string"==typeof e[0])throw this.mode="discriminantAnalysis",l=e,new Error("discriminant analysis is not yet supported");if("Matrix"!==n.constructor.name)throw new TypeError("features must be of class Matrix");this.center=o,this.center?(this.means=n.mean("column"),this.meansY=l.mean("column")):this.stdevs=null,this.scale=s,this.scale?(this.stdevs=n.standardDeviation("column"),this.stdevsY=l.standardDeviation("column")):this.means=null,h=a.length>0?a:getFolds(e,5);let u=[];this.model=[],this.tCV=[],this.tOrthCV=[],this.yHatCV=[];let c,f=[],m=[];for(c=0;c<i;c++){let t=new Matrix$2(l.rows,1),e=new Matrix$2(l.rows,1),i=new Matrix$2(l.rows,1),a=[],g=0;for(let r of h){let h=this._getTrainTest(n,l,r),u=h.testFeatures,m=h.trainFeatures,d=h.trainLabels,p=m.mean("column"),w=m.standardDeviation("column");o&&(m.center("column"),d.center("column")),s&&(m.scale("column"),d.scale("column")),a[g]=OPLSNipals(0===c?m:f[c-1][g].filteredX,d),f[c]=a;let x=new nipals(a[g].filteredX,{Y:d});u.center("column",{center:p}),u.scale("column",{scale:w});let y,M=u;for(let t=0;t<c+1;t++)y=M.mmul(f[t][g].weightsXOrtho.transpose()),M.sub(y.mmul(f[t][g].loadingsXOrtho));let v=M.mmul(x.w.transpose()),b=v.mmul(x.betas);for(let n=0;n<r.testIndex.length;n++)t.setRow(r.testIndex[n],[b.get(n,0)]),e.setRow(r.testIndex[n],[v.get(n,0)]),i.setRow(r.testIndex[n],[y.get(n,0)]);g++}if(this.tCV.push(e),this.tOrthCV.push(i),this.yHatCV.push(t),"regression"===this.mode){let e=tss(l.center("column").scale("column")),r=1-tss(l.clone().sub(t))/e;u.push(r)}else if("discriminantAnalysis"===this.mode)throw new Error("discriminant analysis is not yet supported");m=0===c?this._predictAll(n,l):this._predictAll(m.xRes,l,r={scale:!1,center:!1}),m.Q2y=u,this.model.push(m)}let g=this.tCV,d=this.tOrthCV,p=this.model[c-1],w=p.XOrth,x=n.center("column").scale("column"),y=l.center("column").scale("column"),M=x.clone().sub(w),v=new nipals(M,{Y:y}),b=M.clone().sub(v.t.mmul(v.p)),S=this.model.map((t=>t.R2x)),A=this.model.map((t=>t.R2y));this.output={Q2y:u,R2x:S,R2y:A,tPred:p.plsC.t,pPred:p.plsC.p,wPred:p.plsC.w,betasPred:p.plsC.betas,Qpc:p.plsC.q,tCV:g,tOrthCV:d,tOrth:p.tOrth,pOrth:p.pOrth,wOrth:p.wOrth,XOrth:w,yHat:p.totalPred,Yres:p.plsC.yResidual,E:b}}getLogs(){return this.output}getScores(){return{scoresX:this.tCV.map((t=>t.to1DArray())),scoresY:this.tOrthCV.map((t=>t.to1DArray()))}}static load(t){if("string"!=typeof t.name)throw new TypeError("model must have a name property");if("OPLS"!==t.name)throw new RangeError(`invalid model: ${t.name}`);return new OPLS(!0,[],t)}toJSON(){return{name:"OPLS",center:this.center,scale:this.scale,means:this.means,stdevs:this.stdevs,model:this.model,tCV:this.tCV,tOrthCV:this.tOrthCV,yHatCV:this.yHatCV}}predict(t,e={}){let{trueLabels:r=[],nc:n=1}=e,i=[];r.length>0&&(r=Matrix$2.from1DArray(r.length,1,r),i=r.clone());let o=t.clone();this.center&&(o.center("column",{center:this.means}),i.rows>0&&"regression"===this.mode&&i.center("column",{center:this.meansY})),this.scale&&(o.scale("column",{scale:this.stdevs}),i.rows>0&&"regression"===this.mode&&i.scale("column",{scale:this.stdevsY}));let s,a,l,h,u,c=o.clone();for(let t=0;t<n;t++)a=this.model[t].wOrth.transpose(),l=this.model[t].pOrth,s=c.mmul(a),c.sub(s.mmul(l)),u=c.mmul(this.model[t].plsC.w.transpose()),h=u.mmul(this.model[t].plsC.betas);if(!(i.rows>0))return{tPred:u,tOrth:s,yHat:h};if("regression"===this.mode){let t=tss(i);return{tPred:u,tOrth:s,yHat:h,Q2y:1-tss(i.clone().sub(h))/t}}if("discriminantAnalysis"===this.mode){let t=[];return t=ConfusionMatrix.fromLabels(r.to1DArray(),h.to1DArray()),{tPred:u,tOrth:s,yHat:h,confusionMatrix:t}}}_predictAll(t,e,r={}){const{center:n=!0,scale:i=!0}=r;n&&(t.center("column"),e.center("column")),i&&(t.scale("column"),e.scale("column"),this.tssy=tss(e),this.tssx=tss(t));let o=OPLSNipals(t,e),s=new nipals(o.filteredX,{Y:e}),a=o.filteredX.mmul(s.w.transpose()),l=a.mmul(s.betas);return{R2y:1-tss(e.clone().sub(l))/this.tssy,R2x:tss(s.t.mmul(s.p))/this.tssx,xRes:o.filteredX,tOrth:o.scoresXOrtho,pOrth:o.loadingsXOrtho,wOrth:o.weightsXOrtho,tPred:a,totalPred:l,XOrth:o.scoresXOrtho.mmul(o.loadingsXOrtho),oplsC:o,plsC:s}}_getTrainTest(t,e,r){let n=new Matrix$2(r.testIndex.length,t.columns),i=new Matrix$2(r.testIndex.length,1);r.testIndex.forEach(((r,o)=>{n.setRow(o,t.getRow(r)),i.setRow(o,e.getRow(r))}));let o=new Matrix$2(r.trainIndex.length,t.columns),s=new Matrix$2(r.trainIndex.length,1);return r.trainIndex.forEach(((r,n)=>{o.setRow(n,t.getRow(r)),s.setRow(n,e.getRow(r))})),{trainFeatures:o,testFeatures:n,trainLabels:s,testLabels:i}}}var require$$0$1=getAugmentedNamespace(MatrixLib);function logistic(t){return 1/(1+Math.exp(-t))}function expELU(t,e){return t<0?e*(Math.exp(t)-1):t}function softExponential(t,e){return e<0?-Math.log(1-e*(t+e))/e:e>0?(Math.exp(e*t)-1)/e+e:t}function softExponentialPrime(t,e){return e<0?1/(1-e*(e+t)):Math.exp(e*t)}const ACTIVATION_FUNCTIONS={tanh:{activation:Math.tanh,derivate:t=>1-t*t},identity:{activation:t=>t,derivate:()=>1},logistic:{activation:logistic,derivate:t=>logistic(t)*(1-logistic(t))},arctan:{activation:Math.atan,derivate:t=>1/(t*t+1)},softsign:{activation:t=>t/(1+Math.abs(t)),derivate:t=>1/((1+Math.abs(t))*(1+Math.abs(t)))},relu:{activation:t=>t<0?0:t,derivate:t=>t<0?0:1},softplus:{activation:t=>Math.log(1+Math.exp(t)),derivate:t=>1/(1+Math.exp(-t))},bent:{activation:t=>(Math.sqrt(t*t+1)-1)/2+t,derivate:t=>t/(2*Math.sqrt(t*t+1))+1},sinusoid:{activation:Math.sin,derivate:Math.cos},sinc:{activation:t=>0===t?1:Math.sin(t)/t,derivate:t=>0===t?0:Math.cos(t)/t-Math.sin(t)/(t*t)},gaussian:{activation:t=>Math.exp(-t*t),derivate:t=>-2*t*Math.exp(-t*t)},"parametric-relu":{activation:(t,e)=>t<0?e*t:t,derivate:(t,e)=>t<0?e:1},"exponential-elu":{activation:expELU,derivate:(t,e)=>t<0?expELU(t,e)+e:1},"soft-exponential":{activation:softExponential,derivate:softExponentialPrime}};class Layer{constructor(t){this.inputSize=t.inputSize,this.outputSize=t.outputSize,this.regularization=t.regularization,this.epsilon=t.epsilon,this.activation=t.activation,this.activationParam=t.activationParam;var e=ACTIVATION_FUNCTIONS[t.activation],r=e.activation.length,n=r>1?r=>e.activation(r,t.activationParam):e.activation,i=r>1?r=>e.derivate(r,t.activationParam):e.derivate;this.activationFunction=function(t,e){this.set(t,e,n(this.get(t,e)))},this.derivate=function(t,e){this.set(t,e,i(this.get(t,e)))},t.model?(this.W=require$$0$1.Matrix.checkMatrix(t.W),this.b=require$$0$1.Matrix.checkMatrix(t.b)):(this.W=require$$0$1.Matrix.rand(this.inputSize,this.outputSize),this.b=require$$0$1.Matrix.zeros(1,this.outputSize),this.W.apply((function(e,r){this.set(e,r,this.get(e,r)/Math.sqrt(t.inputSize))})))}forward(t){var e=t.mmul(this.W).addRowVector(this.b);return e.apply(this.activationFunction),this.a=e.clone(),e}backpropagation(t,e){this.dW=e.transpose().mmul(t),this.db=require$$0$1.Matrix.rowVector(t.sum("column"));var r=e.clone();return t.mmul(this.W.transpose()).mul(r.apply(this.derivate))}update(){this.dW.add(this.W.clone().mul(this.regularization)),this.W.add(this.dW.mul(-this.epsilon)),this.b.add(this.db.mul(-this.epsilon))}toJSON(){return{model:"Layer",inputSize:this.inputSize,outputSize:this.outputSize,regularization:this.regularization,epsilon:this.epsilon,activation:this.activation,W:this.W,b:this.b}}static load(t){if("Layer"!==t.model)throw new RangeError("the current model is not a Layer model");return new Layer(t)}}class OutputLayer extends Layer{constructor(t){super(t),this.activationFunction=function(t,e){this.set(t,e,Math.exp(this.get(t,e)))}}static load(t){if("Layer"!==t.model)throw new RangeError("the current model is not a Layer model");return new OutputLayer(t)}}class FeedForwardNeuralNetworks{constructor(t){if((t=t||{}).model){this.hiddenLayers=t.hiddenLayers,this.iterations=t.iterations,this.learningRate=t.learningRate,this.regularization=t.regularization,this.dicts=t.dicts,this.activation=t.activation,this.activationParam=t.activationParam,this.model=new Array(t.layers.length);for(var e=0;e<this.model.length-1;++e)this.model[e]=Layer.load(t.layers[e]);this.model[this.model.length-1]=OutputLayer.load(t.layers[this.model.length-1])}else this.hiddenLayers=t.hiddenLayers||[10],this.iterations=t.iterations||50,this.learningRate=t.learningRate||.01,this.regularization=t.regularization||.01,this.activation=t.activation||"tanh",this.activationParam=t.activationParam||1,this.activation in Object.keys(ACTIVATION_FUNCTIONS)||(this.activation="tanh")}buildNetwork(t,e){var r=this.hiddenLayers.length-1+2;this.model=new Array(r),this.model[0]=new Layer({inputSize:t,outputSize:this.hiddenLayers[0],activation:this.activation,activationParam:this.activationParam,regularization:this.regularization,epsilon:this.learningRate});for(var n=1;n<this.hiddenLayers.length;++n)this.model[n]=new Layer({inputSize:this.hiddenLayers[n-1],outputSize:this.hiddenLayers[n],activation:this.activation,activationParam:this.activationParam,regularization:this.regularization,epsilon:this.learningRate});this.model[r-1]=new OutputLayer({inputSize:this.hiddenLayers[this.hiddenLayers.length-1],outputSize:e,activation:this.activation,activationParam:this.activationParam,regularization:this.regularization,epsilon:this.learningRate})}train(t,e){t=require$$0$1.Matrix.checkMatrix(t),this.dicts=dictOutputs(e);var r=t.columns,n=Object.keys(this.dicts.inputs).length;this.model||this.buildNetwork(r,n);for(var i=0;i<this.iterations;++i){var o=this.propagate(t);this.backpropagation(t,e,o)}}propagate(t){for(var e=t,r=0;r<this.model.length;++r)e=this.model[r].forward(e);return e.divColumnVector(e.sum("row"))}backpropagation(t,e,r){for(var n=0;n<r.rows;++n)r.set(n,this.dicts.inputs[e[n]],r.get(n,this.dicts.inputs[e[n]])-1);var i=r;for(n=this.model.length-1;n>=0;--n){var o=n>0?this.model[n-1].a:t;i=this.model[n].backpropagation(i,o)}for(n=0;n<this.model.length;++n)this.model[n].update()}predict(t){t=require$$0$1.Matrix.checkMatrix(t);for(var e=new Array(t.rows),r=this.propagate(t),n=0;n<t.rows;++n)e[n]=this.dicts.outputs[r.maxRowIndex(n)[1]];return e}toJSON(){for(var t={model:"FNN",hiddenLayers:this.hiddenLayers,iterations:this.iterations,learningRate:this.learningRate,regularization:this.regularization,activation:this.activation,activationParam:this.activationParam,dicts:this.dicts,layers:new Array(this.model.length)},e=0;e<this.model.length;++e)t.layers[e]=this.model[e].toJSON();return t}static load(t){if("FNN"!==t.model)throw new RangeError("the current model is not a feed forward network");return new FeedForwardNeuralNetworks(t)}}function dictOutputs(t){for(var e={},r={},n=0,i=0;i<t.length;i+=1)void 0===e[t[i]]&&(e[t[i]]=n,r[n]=t[i],n++);return{inputs:e,outputs:r}}var FeedForwardNeuralNetwork=FeedForwardNeuralNetworks;function NodeSquare(t,e,r,n){this.x=t,this.y=e,this.weights=r,this.som=n,this.neighbors={}}NodeSquare.prototype.adjustWeights=function(t,e,r){for(var n=0,i=this.weights.length;n<i;n++)this.weights[n]+=e*r*(t[n]-this.weights[n])},NodeSquare.prototype.getDistance=function(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y))},NodeSquare.prototype.getDistanceTorus=function(t){var e=Math.abs(this.x-t.x),r=Math.abs(this.y-t.y);return Math.max(Math.min(e,this.som.gridDim.x-e),Math.min(r,this.som.gridDim.y-r))},NodeSquare.prototype.getNeighbors=function(t){if(!this.neighbors[t]){var e,r,n,i;if(this.neighbors[t]=new Array(2),this[t]>0?e=this[t]-1:this.som.torus&&(e=this.som.gridDim[t]-1),void 0!==e)"x"===t?(r=e,n=this.y):(r=this.x,n=e),this.neighbors[t][0]=this.som.nodes[r][n];this[t]<this.som.gridDim[t]-1?i=this[t]+1:this.som.torus&&(i=0),void 0!==i&&("x"===t?(r=i,n=this.y):(r=this.x,n=i),this.neighbors[t][1]=this.som.nodes[r][n])}return this.neighbors[t]},NodeSquare.prototype.getPos=function(t,e){var r,n,i=this.getNeighbors(t),o=this.som.distance;i[0]?i[1]?o(e,i[0].weights)<o(e,i[1].weights)?(r=i[0],n=-1):(r=i[1],n=1):(r=i[0],n=-1):(r=i[1],n=1);var s=1-o(e,this.weights),a=1-o(e,r.weights);return.5+.5*((s-a)/(2-s-a))*n},NodeSquare.prototype.getPosition=function(t){return[this.getPos("x",t),this.getPos("y",t)]};var nodeSquare=NodeSquare;function NodeHexagonal(t,e,r,n){nodeSquare.call(this,t,e,r,n),this.hX=t-Math.floor(e/2),this.z=0-this.hX-e}NodeHexagonal.prototype=new nodeSquare,NodeHexagonal.prototype.constructor=NodeHexagonal,NodeHexagonal.prototype.getDistance=function(t){return Math.max(Math.abs(this.hX-t.hX),Math.abs(this.y-t.y),Math.abs(this.z-t.z))},NodeHexagonal.prototype.getDistanceTorus=function(t){var e=Math.abs(this.hX-t.hX),r=Math.abs(this.y-t.y),n=Math.abs(this.z-t.z);return Math.max(Math.min(e,this.som.gridDim.x-e),Math.min(r,this.som.gridDim.y-r),Math.min(n,this.som.gridDim.z-n))},NodeHexagonal.prototype.getPosition=function(){throw new Error("Unimplemented : cannot get position of the points for hexagonal grid")};var nodeHexagonal=NodeHexagonal,defaultOptions$b={fields:3,randomizer:Math.random,distance:squareEuclidean,iterations:10,learningRate:.1,gridType:"rect",torus:!0,method:"random"};function SOM(t,e,r,n){for(var i in this.x=t,this.y=e,r=r||{},this.options={},defaultOptions$b)r.hasOwnProperty(i)?this.options[i]=r[i]:this.options[i]=defaultOptions$b[i];if("number"==typeof this.options.fields)this.numWeights=this.options.fields;else{if(!Array.isArray(this.options.fields))throw new Error("Invalid fields definition");this.numWeights=this.options.fields.length;var o=getConverters(this.options.fields);this.extractor=o.extractor,this.creator=o.creator}if("rect"===this.options.gridType)this.nodeType=nodeSquare,this.gridDim={x:t,y:e};else{this.nodeType=nodeHexagonal;var s=this.x-Math.floor(this.y/2);this.gridDim={x:s,y:this.y,z:-(0-s-this.y)}}if(this.torus=this.options.torus,this.distanceMethod=this.torus?"getDistanceTorus":"getDistance",this.distance=this.options.distance,this.maxDistance=getMaxDistance(this.distance,this.numWeights),!0!==n){if(!(t>0&&e>0))throw new Error("x and y must be positive");this.times={findBMU:0,adjust:0},this.randomizer=this.options.randomizer,this.iterationCount=0,this.iterations=this.options.iterations,this.startLearningRate=this.learningRate=this.options.learningRate,this.mapRadius=Math.floor(Math.max(t,e)/2),this.algorithmMethod=this.options.method,this._initNodes(),this.done=!1}else this.done=!0}function getConverters(t){for(var e=t.length,r=new Array(e),n=new Array(e),i=0;i<e;i++)r[i]=getNormalizer(t[i].range),n[i]=getDenormalizer(t[i].range);return{extractor:function(n){for(var i=new Array(e),o=0;o<e;o++)i[o]=r[o](n[t[o].name]);return i},creator:function(r){for(var i={},o=0;o<e;o++)i[t[o].name]=n[o](r[o]);return i}}}function getNormalizer(t){return function(e){return(e-t[0])/(t[1]-t[0])}}function getDenormalizer(t){return function(e){return t[0]+e*(t[1]-t[0])}}function squareEuclidean(t,e){for(var r=0,n=0,i=t.length;n<i;n++)r+=(t[n]-e[n])*(t[n]-e[n]);return r}function getRandomValue(t,e){return t[Math.floor(e()*t.length)]}function getMaxDistance(t,e){for(var r=new Array(e),n=new Array(e),i=0;i<e;i++)r[i]=0,n[i]=1;return t(r,n)}SOM.load=function loadModel(model,distance){if("SOM"===model.name){var x=model.data.length,y=model.data[0].length;distance?model.options.distance=distance:model.options.distance&&(model.options.distance=eval("("+model.options.distance+")"));var som=new SOM(x,y,model.options,!0);som.nodes=new Array(x);for(var i=0;i<x;i++){som.nodes[i]=new Array(y);for(var j=0;j<y;j++)som.nodes[i][j]=new som.nodeType(i,j,model.data[i][j],som)}return som}throw new Error("expecting a SOM model")},SOM.prototype.export=function(t){if(!this.done)throw new Error("model is not ready yet");var e={name:"SOM"};e.options={fields:this.options.fields,gridType:this.options.gridType,torus:this.options.torus},e.data=new Array(this.x);for(var r=0;r<this.x;r++){e.data[r]=new Array(this.y);for(var n=0;n<this.y;n++)e.data[r][n]=this.nodes[r][n].weights}return t&&(e.options.distance=this.distance.toString()),e},SOM.prototype._initNodes=function(){var t,e,r,n=Date.now();for(this.nodes=new Array(this.x),t=0;t<this.x;t++)for(this.nodes[t]=new Array(this.y),e=0;e<this.y;e++){var i=new Array(this.numWeights);for(r=0;r<this.numWeights;r++)i[r]=this.randomizer();this.nodes[t][e]=new this.nodeType(t,e,i,this)}this.times.initNodes=Date.now()-n},SOM.prototype.setTraining=function(t){if(this.trainingSet)throw new Error("training set has already been set");var e,r=Date.now(),n=t,i=t.length;if(this.extractor)for(n=new Array(i),e=0;e<i;e++)n[e]=this.extractor(t[e]);this.numIterations=this.iterations*i,"random"===this.algorithmMethod?this.timeConstant=this.numIterations/Math.log(this.mapRadius):this.timeConstant=i/Math.log(this.mapRadius),this.trainingSet=n,this.times.setTraining=Date.now()-r},SOM.prototype.trainOne=function(){return!this.done&&(this.numIterations-- >0?("random"===this.algorithmMethod?(t=this.mapRadius*Math.exp(-this.iterationCount/this.timeConstant),e=getRandomValue(this.trainingSet,this.randomizer),this._adjust(e,t),this.learningRate=this.startLearningRate*Math.exp(-this.iterationCount/this.numIterations)):(r=-Math.floor(this.iterationCount/this.trainingSet.length),t=this.mapRadius*Math.exp(r/this.timeConstant),e=this.trainingSet[this.iterationCount%this.trainingSet.length],this._adjust(e,t),(this.iterationCount+1)%this.trainingSet.length==0&&(this.learningRate=this.startLearningRate*Math.exp(r/Math.floor(this.numIterations/this.trainingSet.length)))),this.iterationCount++,!0):(this.done=!0,!1));var t,e,r},SOM.prototype._adjust=function(t,e){var r,n,i,o,s=Date.now(),a=this._findBestMatchingUnit(t),l=Date.now();this.times.findBMU+=l-s;var h=Math.floor(e),u=a.x-h,c=a.x+h,f=a.y-h,m=a.y+h;for(r=u;r<=c;r++){var g=r;for(r<0?g+=this.x:r>=this.x&&(g-=this.x),n=f;n<=m;n++){var d=n;n<0?d+=this.y:n>=this.y&&(d-=this.y),(i=a[this.distanceMethod](this.nodes[g][d]))<e&&(o=Math.exp(-i/(2*e)),this.nodes[g][d].adjustWeights(t,this.learningRate,o))}}this.times.adjust+=Date.now()-l},SOM.prototype.train=function(t){if(!this.done)for(this.setTraining(t);this.trainOne(););},SOM.prototype.getConvertedNodes=function(){for(var t=new Array(this.x),e=0;e<this.x;e++){t[e]=new Array(this.y);for(var r=0;r<this.y;r++){var n=this.nodes[e][r];t[e][r]=this.creator?this.creator(n.weights):n.weights}}return t},SOM.prototype._findBestMatchingUnit=function(t){for(var e,r,n=1/0,i=0;i<this.x;i++)for(var o=0;o<this.y;o++)(r=this.distance(this.nodes[i][o].weights,t))<n&&(n=r,e=this.nodes[i][o]);return e},SOM.prototype.predict=function(t,e){if("boolean"==typeof t&&(e=t,t=null),t||(t=this.trainingSet),Array.isArray(t)&&(Array.isArray(t[0])||"object"==typeof t[0])){var r=this;return t.map((function(t){return r._predict(t,e)}))}return this._predict(t,e)},SOM.prototype._predict=function(t,e){Array.isArray(t)||(t=this.extractor(t));var r=this._findBestMatchingUnit(t),n=[r.x,r.y];return e&&(n[2]=r.getPosition(t)),n},SOM.prototype.getQuantizationError=function(){for(var t=this.getFit(),e=t.length,r=0,n=0;n<e;n++)r+=t[n];return r/e},SOM.prototype.getFit=function(t){t||(t=this.trainingSet);for(var e,r=t.length,n=new Array(r),i=0;i<r;i++)e=this._findBestMatchingUnit(t[i]),n[i]=Math.sqrt(this.distance(t[i],e.weights));return n};var src$3=SOM;function maybeToPrecision(t,e){return t<0?(t=0-t,"number"==typeof e?`- ${t.toPrecision(e)}`:`- ${t.toString()}`):"number"==typeof e?t.toPrecision(e):t.toString()}function checkArraySize(t,e){if(!isAnyArray(t)||!isAnyArray(e))throw new TypeError("x and y must be arrays");if(t.length!==e.length)throw new RangeError("x and y arrays must have the same length")}class BaseRegression{constructor(){if(new.target===BaseRegression)throw new Error("BaseRegression must be subclassed")}predict(t){if("number"==typeof t)return this._predict(t);if(isAnyArray(t)){const e=[];for(let r=0;r<t.length;r++)e.push(this._predict(t[r]));return e}throw new TypeError("x must be a number or array")}_predict(){throw new Error("_predict must be implemented")}train(){}toString(){return""}toLaTeX(){return""}score(t,e){if(!isAnyArray(t)||!isAnyArray(e)||t.length!==e.length)throw new Error("x and y must be arrays of the same length");const r=t.length,n=new Array(r);for(let e=0;e<r;e++)n[e]=this._predict(t[e]);let i=0,o=0,s=0,a=0,l=0,h=0,u=0;for(let t=0;t<r;t++)i+=n[t],o+=e[t],l+=n[t]*n[t],h+=e[t]*e[t],u+=n[t]*e[t],0!==e[t]&&(s+=(e[t]-n[t])*(e[t]-n[t])/e[t]),a+=(e[t]-n[t])*(e[t]-n[t]);const c=(r*u-i*o)/Math.sqrt((r*l-i*i)*(r*h-o*o));return{r:c,r2:c*c,chi2:s,rmsd:Math.sqrt(a/r)}}}class PolynomialRegression extends BaseRegression{constructor(t,e,r){super(),!0===t?(this.degree=e.degree,this.powers=e.powers,this.coefficients=e.coefficients):(checkArraySize(t,e),regress$3(this,t,e,r))}_predict(t){let e=0;for(let r=0;r<this.powers.length;r++)e+=this.coefficients[r]*Math.pow(t,this.powers[r]);return e}toJSON(){return{name:"polynomialRegression",degree:this.degree,powers:this.powers,coefficients:this.coefficients}}toString(t){return this._toFormula(t,!1)}toLaTeX(t){return this._toFormula(t,!0)}_toFormula(t,e){let r="^",n="",i=" * ";e&&(r="^{",n="}",i="");let o="",s="";for(let e=0;e<this.coefficients.length;e++)s="",0!==this.coefficients[e]&&(s=0===this.powers[e]?maybeToPrecision(this.coefficients[e],t):1===this.powers[e]?`${maybeToPrecision(this.coefficients[e],t)+i}x`:`${maybeToPrecision(this.coefficients[e],t)+i}x${r}${this.powers[e]}${n}`,this.coefficients[e]>0&&e!==this.coefficients.length-1?s=` + ${s}`:e!==this.coefficients.length-1&&(s=` ${s}`)),o=s+o;return"+"===o.charAt(0)&&(o=o.slice(1)),`f(x) = ${o}`}static load(t){if("polynomialRegression"!==t.name)throw new TypeError("not a polynomial regression model");return new PolynomialRegression(!0,t)}}function regress$3(t,e,r,n){const i=e.length;let o;if(Array.isArray(n))o=n,n=o.length;else{n++,o=new Array(n);for(let t=0;t<n;t++)o[t]=t}const s=new Matrix$2(i,n),a=new Matrix$2([r]);for(let t=0;t<n;t++)for(let r=0;r<i;r++)0===o[t]?s.set(r,t,1):s.set(r,t,Math.pow(e[r],o[t]));const l=new MatrixTransposeView$1(s),h=l.mmul(s),u=l.mmul(new MatrixTransposeView$1(a));t.degree=n-1,t.powers=o,t.coefficients=solve(h,u).to1DArray()}class SimpleLinearRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.slope=e.slope,this.intercept=e.intercept,this.coefficients=[e.intercept,e.slope]):(checkArraySize(t,e),regress$2(this,t,e))}toJSON(){return{name:"simpleLinearRegression",slope:this.slope,intercept:this.intercept}}_predict(t){return this.slope*t+this.intercept}computeX(t){return(t-this.intercept)/this.slope}toString(t){let e="f(x) = ";if(0!==this.slope){const r=maybeToPrecision(this.slope,t);if(e+=("1"===r?"":`${r} * `)+"x",0!==this.intercept){const r=Math.abs(this.intercept);e+=` ${r===this.intercept?"+":"-"} ${maybeToPrecision(r,t)}`}}else e+=maybeToPrecision(this.intercept,t);return e}toLaTeX(t){return this.toString(t)}static load(t){if("simpleLinearRegression"!==t.name)throw new TypeError("not a SLR model");return new SimpleLinearRegression(!0,t)}}function regress$2(t,e,r){const n=e.length;let i=0,o=0,s=0,a=0;for(let t=0;t<n;t++)i+=e[t],o+=r[t],s+=e[t]*e[t],a+=e[t]*r[t];const l=n*a-i*o;t.slope=l/(n*s-i*i),t.intercept=1/n*o-t.slope*(1/n)*i,t.coefficients=[t.intercept,t.slope]}class ExponentialRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.A=e.A,this.B=e.B):(checkArraySize(t,e),regress$1(this,t,e))}_predict(t){return this.B*Math.exp(t*this.A)}toJSON(){return{name:"exponentialRegression",A:this.A,B:this.B}}toString(t){return`f(x) = ${maybeToPrecision(this.B,t)} * e^(${maybeToPrecision(this.A,t)} * x)`}toLaTeX(t){return this.A>=0?`f(x) = ${maybeToPrecision(this.B,t)}e^{${maybeToPrecision(this.A,t)}x}`:`f(x) = \\frac{${maybeToPrecision(this.B,t)}}{e^{${maybeToPrecision(-this.A,t)}x}}`}static load(t){if("exponentialRegression"!==t.name)throw new TypeError("not a exponential regression model");return new ExponentialRegression(!0,t)}}function regress$1(t,e,r){const n=e.length,i=new Array(n);for(let t=0;t<n;t++)i[t]=Math.log(r[t]);const o=new SimpleLinearRegression(e,i);t.A=o.slope,t.B=Math.exp(o.intercept)}class PowerRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.A=e.A,this.B=e.B):(checkArraySize(t,e),regress(this,t,e))}_predict(t){return this.A*Math.pow(t,this.B)}toJSON(){return{name:"powerRegression",A:this.A,B:this.B}}toString(t){return`f(x) = ${maybeToPrecision(this.A,t)} * x^${maybeToPrecision(this.B,t)}`}toLaTeX(t){let e="";return e=this.B>=0?`f(x) = ${maybeToPrecision(this.A,t)}x^{${maybeToPrecision(this.B,t)}}`:`f(x) = \\frac{${maybeToPrecision(this.A,t)}}{x^{${maybeToPrecision(-this.B,t)}}}`,e=e.replace(/e([+-]?[0-9]+)/g,"e^{$1}"),e}static load(t){if("powerRegression"!==t.name)throw new TypeError("not a power regression model");return new PowerRegression(!0,t)}}function regress(t,e,r){const n=e.length,i=new Array(n),o=new Array(n);for(let t=0;t<n;t++)i[t]=Math.log(e[t]),o[t]=Math.log(r[t]);const s=new SimpleLinearRegression(i,o);t.A=Math.exp(s.intercept),t.B=s.slope}class MultivariateLinearRegression{constructor(t,e,r={}){const{intercept:n=!0,statistics:i=!0}=r;if(this.statistics=i,!0===t)this.weights=e.weights,this.inputs=e.inputs,this.outputs=e.outputs,this.intercept=e.intercept;else{t=new Matrix$2(t),e=new Matrix$2(e),n&&t.addColumn(new Array(t.rows).fill(1));let r=t.transpose();const o=r.mmul(t),s=r.mmul(e),a=new SingularValueDecomposition(o).inverse(),l=s.transpose().mmul(a).transpose();if(this.weights=l.to2DArray(),this.inputs=t.columns,this.outputs=e.columns,n&&this.inputs--,this.intercept=n,i){const r=t.mmul(l),n=e.clone().addM(r.neg()).to2DArray().map((t=>Math.pow(t[0],2))).reduce(((t,e)=>t+e))/(e.rows-t.columns);this.stdError=Math.sqrt(n),this.stdErrorMatrix=pseudoInverse(o).mul(n),this.stdErrors=this.stdErrorMatrix.diagonal().map((t=>Math.sqrt(t))),this.tStats=this.weights.map(((t,e)=>0===this.stdErrors[e]?0:t[0]/this.stdErrors[e]))}}}predict(t){if(Array.isArray(t)){if("number"==typeof t[0])return this._predict(t);if(Array.isArray(t[0])){const e=new Array(t.length);for(let r=0;r<t.length;r++)e[r]=this._predict(t[r]);return e}}else if(Matrix$2.isMatrix(t)){const e=new Matrix$2(t.rows,this.outputs);for(let r=0;r<t.rows;r++)e.setRow(r,this._predict(t.getRow(r)));return e}throw new TypeError("x must be a matrix or array of numbers")}_predict(t){const e=new Array(this.outputs);if(this.intercept)for(let t=0;t<this.outputs;t++)e[t]=this.weights[this.inputs][t];else e.fill(0);for(let r=0;r<this.inputs;r++)for(let n=0;n<this.outputs;n++)e[n]+=this.weights[r][n]*t[r];return e}score(){throw new Error("score method is not implemented yet")}toJSON(){return{name:"multivariateLinearRegression",weights:this.weights,inputs:this.inputs,outputs:this.outputs,intercept:this.intercept,summary:this.statistics?{regressionStatistics:{standardError:this.stdError,observations:this.outputs},variables:this.weights.map(((t,e)=>({label:e===this.weights.length-1?"Intercept":`X Variable ${e+1}`,coefficients:t,standardError:this.stdErrors[e],tStat:this.tStats[e]})))}:void 0}}static load(t){if("multivariateLinearRegression"!==t.name)throw new Error("not a MLR model");return new MultivariateLinearRegression(!0,t)}}var require$$0=getAugmentedNamespace(euclidean$3);const{squaredEuclidean:squaredEuclidean$3}=require$$0,defaultOptions$a={sigma:1};class GaussianKernel{constructor(t){t=Object.assign({},defaultOptions$a,t),this.sigma=t.sigma,this.divisor=2*t.sigma*t.sigma}compute(t,e){const r=squaredEuclidean$3(t,e);return Math.exp(-r/this.divisor)}}var gaussianKernel=GaussianKernel;const defaultOptions$9={degree:1,constant:1,scale:1};class PolynomialKernel{constructor(t){t=Object.assign({},defaultOptions$9,t),this.degree=t.degree,this.constant=t.constant,this.scale=t.scale}compute(t,e){for(var r=0,n=0;n<t.length;n++)r+=t[n]*e[n];return Math.pow(this.scale*r+this.constant,this.degree)}}var polynomialKernel=PolynomialKernel;const defaultOptions$8={alpha:.01,constant:-Math.E};class SigmoidKernel{constructor(t){t=Object.assign({},defaultOptions$8,t),this.alpha=t.alpha,this.constant=t.constant}compute(t,e){for(var r=0,n=0;n<t.length;n++)r+=t[n]*e[n];return Math.tanh(this.alpha*r+this.constant)}}var sigmoidKernel=SigmoidKernel;const defaultOptions$7={sigma:1,degree:1};class ANOVAKernel{constructor(t){t=Object.assign({},defaultOptions$7,t),this.sigma=t.sigma,this.degree=t.degree}compute(t,e){for(var r=0,n=Math.min(t.length,e.length),i=1;i<=n;++i)r+=Math.pow(Math.exp(-this.sigma*Math.pow(Math.pow(t[i-1],i)-Math.pow(e[i-1],i),2)),this.degree);return r}}var anovaKernel=ANOVAKernel;const{squaredEuclidean:squaredEuclidean$2}=require$$0,defaultOptions$6={sigma:1};class CauchyKernel{constructor(t){t=Object.assign({},defaultOptions$6,t),this.sigma=t.sigma}compute(t,e){return 1/(1+squaredEuclidean$2(t,e)/(this.sigma*this.sigma))}}var cauchyKernel=CauchyKernel;const{euclidean:euclidean$1}=require$$0,defaultOptions$5={sigma:1};class ExponentialKernel{constructor(t){t=Object.assign({},defaultOptions$5,t),this.sigma=t.sigma,this.divisor=2*t.sigma*t.sigma}compute(t,e){const r=euclidean$1(t,e);return Math.exp(-r/this.divisor)}}var exponentialKernel=ExponentialKernel;class HistogramIntersectionKernel{compute(t,e){for(var r=Math.min(t.length,e.length),n=0,i=0;i<r;++i)n+=Math.min(t[i],e[i]);return n}}var histogramIntersectionKernel=HistogramIntersectionKernel;const{euclidean:euclidean}=require$$0,defaultOptions$4={sigma:1};class LaplacianKernel{constructor(t){t=Object.assign({},defaultOptions$4,t),this.sigma=t.sigma}compute(t,e){const r=euclidean(t,e);return Math.exp(-r/this.sigma)}}var laplacianKernel=LaplacianKernel;const{squaredEuclidean:squaredEuclidean$1}=require$$0,defaultOptions$3={constant:1};class MultiquadraticKernel{constructor(t){t=Object.assign({},defaultOptions$3,t),this.constant=t.constant}compute(t,e){return Math.sqrt(squaredEuclidean$1(t,e)+this.constant*this.constant)}}var multiquadraticKernel=MultiquadraticKernel;const{squaredEuclidean:squaredEuclidean}=require$$0,defaultOptions$2={constant:1};class RationalQuadraticKernel{constructor(t){t=Object.assign({},defaultOptions$2,t),this.constant=t.constant}compute(t,e){const r=squaredEuclidean(t,e);return 1-r/(r+this.constant)}}var rationalQuadraticKernel=RationalQuadraticKernel;const{Matrix:Matrix$1,MatrixTransposeView:MatrixTransposeView}=require$$0$1,kernelType={gaussian:gaussianKernel,rbf:gaussianKernel,polynomial:polynomialKernel,poly:polynomialKernel,anova:anovaKernel,cauchy:cauchyKernel,exponential:exponentialKernel,histogram:histogramIntersectionKernel,min:histogramIntersectionKernel,laplacian:laplacianKernel,multiquadratic:multiquadraticKernel,rational:rationalQuadraticKernel,sigmoid:sigmoidKernel,mlp:sigmoidKernel};class Kernel{constructor(t,e){if(this.kernelType=t,"linear"!==t)if("string"==typeof t){t=t.toLowerCase();var r=kernelType[t];if(!r)throw new Error(`unsupported kernel type: ${t}`);this.kernelFunction=new r(e)}else{if("object"!=typeof t||"function"!=typeof t.compute)throw new TypeError("first argument must be a valid kernel type or instance");this.kernelFunction=t}}compute(t,e){if(t=Matrix$1.checkMatrix(t),e=void 0===e?t:Matrix$1.checkMatrix(e),"linear"===this.kernelType)return t.mmul(new MatrixTransposeView(e));const r=new Matrix$1(t.rows,e.rows);if(t===e)for(let e=0;e<t.rows;e++)for(let n=e;n<t.rows;n++){const i=this.kernelFunction.compute(t.getRow(e),t.getRow(n));r.set(e,n,i),r.set(n,e,i)}else for(let n=0;n<t.rows;n++)for(let i=0;i<e.rows;i++)r.set(n,i,this.kernelFunction.compute(t.getRow(n),e.getRow(i)));return r}}var kernel=Kernel;class TheilSenRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.slope=e.slope,this.intercept=e.intercept,this.coefficients=e.coefficients):(checkArraySize(t,e),theilSen(this,t,e))}toJSON(){return{name:"TheilSenRegression",slope:this.slope,intercept:this.intercept}}_predict(t){return this.slope*t+this.intercept}computeX(t){return(t-this.intercept)/this.slope}toString(t){var e="f(x) = ";if(this.slope){var r=maybeToPrecision(this.slope,t);if(e+=(Math.abs(r-1)<1e-5?"":`${r} * `)+"x",this.intercept){var n=Math.abs(this.intercept);e+=` ${n===this.intercept?"+":"-"} ${maybeToPrecision(n,t)}`}}else e+=maybeToPrecision(this.intercept,t);return e}toLaTeX(t){return this.toString(t)}static load(t){if("TheilSenRegression"!==t.name)throw new TypeError("not a Theil-Sen model");return new TheilSenRegression(!0,t)}}function theilSen(t,e,r){let n=e.length,i=new Array(n*n),o=0;for(let t=0;t<n;++t)for(let s=t+1;s<n;++s)e[t]!==e[s]&&(i[o++]=(r[s]-r[t])/(e[s]-e[t]));i.length=o;let s=median(i),a=new Array(n);for(let t=0;t<n;++t)a[t]=r[t]-s*e[t];t.slope=s,t.intercept=median(a),t.coefficients=[t.intercept,t.slope]}class RobustPolynomialRegression extends BaseRegression{constructor(t,e,r){super(),!0===t?(this.degree=e.degree,this.powers=e.powers,this.coefficients=e.coefficients):(checkArraySize(t,e),robustPolynomial(this,t,e,r))}toJSON(){return{name:"robustPolynomialRegression",degree:this.degree,powers:this.powers,coefficients:this.coefficients}}_predict(t){return predict(t,this.powers,this.coefficients)}toString(t){return this._toFormula(t,!1)}toLaTeX(t){return this._toFormula(t,!0)}_toFormula(t,e){let r="^",n="",i=" * ";e&&(r="^{",n="}",i="");let o="",s="";for(let e=0;e<this.coefficients.length;e++)s="",0!==this.coefficients[e]&&(s=0===this.powers[e]?maybeToPrecision(this.coefficients[e],t):1===this.powers[e]?`${maybeToPrecision(this.coefficients[e],t)+i}x`:`${maybeToPrecision(this.coefficients[e],t)+i}x${r}${this.powers[e]}${n}`,this.coefficients[e]>0&&e!==this.coefficients.length-1?s=` + ${s}`:e!==this.coefficients.length-1&&(s=` ${s}`)),o=s+o;return"+"===o.charAt(0)&&(o=o.slice(1)),`f(x) = ${o}`}static load(t){if("robustPolynomialRegression"!==t.name)throw new TypeError("not a RobustPolynomialRegression model");return new RobustPolynomialRegression(!0,t)}}function robustPolynomial(t,e,r,n){let i=Array(n).fill(0).map(((t,e)=>e));const o=getRandomTuples(e,r,n);for(var s,a=0;a<o.length;a++){for(var l=calcCoefficients(o[a],i),h=e.slice(),u=0;u<e.length;u++)h[u]=r[u]-predict(e[u],i,l),h[u]={residual:h[u]*h[u],coefficients:l};var c=residualsMedian(h);(!s||c.residual<s.residual)&&(s=c)}t.degree=n,t.powers=i,t.coefficients=s.coefficients}function getRandomTuples(t,e,r){for(var n=Math.floor(t.length/r),i=new Array(n),o=0;o<t.length;o++){for(var s=Math.floor(Math.random()*n),a=0;a<t.length;){if(!i[s]){i[s]=[{x:t[o],y:e[o]}];break}if(i[s].length<r){i[s].push({x:t[o],y:e[o]});break}a++,s=(s+1)%n}if(a===t.length)return i}return i}function calcCoefficients(t,e){for(var r=t.slice(),n=t.slice(),i=0;i<r.length;i++){n[i]=[t[i].y],r[i]=new Array(e.length);for(var o=0;o<e.length;o++)r[i][o]=Math.pow(t[i].x,e[o])}return solve(r,n).to1DArray()}function predict(t,e,r){let n=0;for(let i=0;i<e.length;i++)n+=r[i]*Math.pow(t,e[i]);return n}function residualsMedian(t){t.sort(((t,e)=>t.residual-e.residual));var e=t.length,r=Math.floor(e/2);return e%2==0?t[r-1]:t[r]}function checkOptions$1(t,e,r){let{timeout:n,minValues:i,maxValues:o,initialValues:s,weights:a=1,damping:l=.01,dampingStepUp:h=11,dampingStepDown:u=9,maxIterations:c=100,errorTolerance:f=1e-7,centralDifference:m=!1,gradientDifference:g=.1,improvementThreshold:d=.001}=r;if(l<=0)throw new Error("The damping option must be a positive number");if(!t.x||!t.y)throw new Error("The data parameter must have x and y elements");if(!isAnyArray(t.x)||t.x.length<2||!isAnyArray(t.y)||t.y.length<2)throw new Error("The data parameter elements must be an array with more than 2 points");if(t.x.length!==t.y.length)throw new Error("The data parameter elements must have the same size");let p,w,x=s||new Array(e.length).fill(1),y=t.y.length,M=x.length;if(o=o||new Array(M).fill(Number.MAX_SAFE_INTEGER),i=i||new Array(M).fill(Number.MIN_SAFE_INTEGER),o.length!==i.length)throw new Error("minValues and maxValues must be the same size");if(!isAnyArray(x))throw new Error("initialValues must be an array");if("number"==typeof g)g=new Array(x.length).fill(g);else{if(!isAnyArray(g))throw new Error("gradientDifference should be a number or array with length equal to the number of parameters");g.length!==M&&(g=new Array(M).fill(g[0]))}if("number"==typeof a){let t=1/a**2;p=()=>t}else{if(!isAnyArray(a))throw new Error("weights should be a number or array with length equal to the number of data points");if(a.length<t.x.length){let t=1/a[0]**2;p=()=>t}else p=t=>1/a[t]**2}if(void 0!==n){if("number"!=typeof n)throw new Error("timeout should be a number");let t=Date.now()+1e3*n;w=()=>Date.now()>t}else w=()=>!1;let v=new Array(t.x.length);for(let t=0;t<y;t++)v[t]=p(t);return{checkTimeout:w,minValues:i,maxValues:o,parameters:x,weightSquare:v,damping:l,dampingStepUp:h,dampingStepDown:u,maxIterations:c,errorTolerance:f,centralDifference:m,gradientDifference:g,improvementThreshold:d}}function errorCalculation(t,e,r,n){let i=0;const o=r(e);for(let e=0;e<t.x.length;e++)i+=Math.pow(t.y[e]-o(t.x[e]),2)/n[e];return i}function gradientFunction(t,e,r,n,i,o){const s=r.length,a=t.x.length;let l=Matrix$2.zeros(s,a),h=0;for(let u=0;u<s;u++){if(0===n[u])continue;let s=n[u],c=r.slice();c[u]+=s;let f=i(c);if(o){c=r.slice(),c[u]-=s,s*=2;let e=i(c);for(let r=0;r<a;r++)l.set(h,r,(e(t.x[r])-f(t.x[r]))/s)}else for(let r=0;r<a;r++)l.set(h,r,(e[r]-f(t.x[r]))/s);h++}return l}function matrixFunction(t,e){const r=t.x.length;let n=new Matrix$2(r,1);for(let i=0;i<r;i++)n.set(i,0,t.y[i]-e[i]);return n}function step(t,e,r,n,i,o,s){let a=r,l=Matrix$2.eye(e.length,e.length,a);const h=i(e);let u=new Float64Array(t.x.length);for(let e=0;e<t.x.length;e++)u[e]=h(t.x[e]);let c=gradientFunction(t,u,e,n,i,o),f=matrixFunction(t,u),m=inverse(l.add(c.mmul(c.transpose().scale("row",{scale:s})))),g=c.mmul(f.scale("row",{scale:s}));return{perturbations:m.mmul(g),jacobianWeigthResidualError:g}}function levenbergMarquardt(t,e,r={}){let{checkTimeout:n,minValues:i,maxValues:o,parameters:s,weightSquare:a,damping:l,dampingStepUp:h,dampingStepDown:u,maxIterations:c,errorTolerance:f,centralDifference:m,gradientDifference:g,improvementThreshold:d}=checkOptions$1(t,e,r),p=errorCalculation(t,s,e,a),w=p<=f,x=0;for(;x<c&&!w;x++){let c=p,{perturbations:x,jacobianWeigthResidualError:y}=step(t,s,l,g,e,m,a);for(let t=0;t<s.length;t++)s[t]=Math.min(Math.max(i[t],s[t]-x.get(t,0)),o[t]);if(p=errorCalculation(t,s,e,a),isNaN(p))break;if((c-p)/x.transpose().mmul(x.mulS(l).add(y)).get(0,0)>d?l=Math.max(l/u,1e-7):(p=c,l=Math.min(l*h,1e7)),n())throw new Error(`The execution time is over to ${r.timeout} seconds`);w=p<=f}return{parameterValues:s,parameterError:p,iterations:x}}function sortCollectionSet(t){let e,r=t.map(((t,e)=>{let r=BigInt(0);return t.forEach((t=>r|=BigInt(1)<<BigInt(t))),{value:t,index:e,key:r}})).sort(((t,e)=>t.key-e.key<0?-1:1)),n=[],i=[];for(let t of r)t.key!==e&&(e=t.key,i.push([]),n.push(t.value)),i[i.length-1].push(t.index);return{values:n,indices:i}}function cssls(t,e,r,n,i){let o=Matrix$2.zeros(n,i);if(null===r){let r=new CholeskyDecomposition$1(t);if(!0===r.isPositiveDefinite())o=r.solve(e);else{let r=new LuDecomposition$1(t);o=!1===r.isSingular()?r.solve(Matrix$2.eye(n)).mmul(e):solve(t,e,{useSVD:!0})}}else{let s=sortCollectionSet(r).values,a=sortCollectionSet(r).indices;if(1===s.length&&0===s[0].length&&a[0].length===i)return o;if(1===s.length&&s[0].length===n&&a[0].length===i){let r=new CholeskyDecomposition$1(t);if(!0===r.isPositiveDefinite())o=r.solve(e);else{let r=new LuDecomposition$1(t);o=!1===r.isSingular()?r.solve(Matrix$2.eye(n)).mmul(e):solve(t,e,{useSVD:!0})}}else for(let r=0;r<s.length;r++){let n,i=a[r],l=s[r],h=new CholeskyDecomposition$1(t.selection(l,l));if(!0===h.isPositiveDefinite())n=h.solve(e.selection(l,i));else{let r=new LuDecomposition$1(t.selection(l,l));n=!1===r.isSingular()?r.solve(Matrix$2.eye(l.length)).mmul(e.selection(l,i)):solve(t.selection(l,l),e.selection(l,i),{useSVD:!0})}for(let t=0;t<n.rows;t++)for(let e=0;e<n.columns;e++)o.set(l[t],i[e],n.get(t,e))}}return o}function initialisation(t,e){let r=t.rows,n=t.columns,i=e.columns;if(e.rows!==r)throw new Error("ERROR: matrix size not compatible");let o=Matrix$2.zeros(n,i),s=t.transpose().mmul(t),a=t.transpose().mmul(e),l=cssls(s,a,null,n,i),h=[];for(let t=0;t<i;t++){h[t]=[];for(let e=0;e<n;e++)l.get(e,t)>0?h[t].push(e):l.set(e,t,0)}let u=[];for(let t=0;t<i;t++)h[t].length!==n&&u.push(t);let c=l.clone();return{n:r,l:n,p:i,iter:0,W:o,XtX:s,XtY:a,K:l,Pset:h,Fset:u,D:c}}function setDifference(t,e){let r=[];for(let n of t)e.includes(n)||r.push(n);return r}function optimality(t,e,r,n,i,o,s,a,l,h,u){if(t===e)throw new Error("Maximum number of iterations exceeded");let c=n.subMatrixColumn(i).subtract(r.mmul(a.subMatrixColumn(i)));for(let t=0;t<i.length;t++)s.setColumn(i[t],c.subMatrixColumn([t]));let f=[],m=[];for(let t=0;t<l;t++)m.push(t);for(let t=0;t<i.length;t++){let e=setDifference(m,o[i[t]]);(0===e.length||s.selection(e,[i[t]]).max()<=0)&&f.push(i[t])}if(0!==(i=setDifference(i,f)).length){for(let t=0;t<i.length;t++){for(let e=0;e<l;e++)o[i[t]].includes(e)&&s.set(e,i[t],-1/0);o[i[t]].push(s.subMatrixColumn(i).maxColumnIndex(t)[0])}for(let t=0;t<i.length;t++)u.setColumn(i[t],a.getColumn(i[t]))}for(let t=0;t<h;t++)o[t].sort(((t,e)=>t-e));return{Pset:o,Fset:i,W:s}}function selection(t,e){let r=[];for(let n=0;n<e.length;n++)r[n]=t[e[n]];return r}function fcnnls(t,e,r={}){t=Matrix$2.checkMatrix(t),e=Matrix$2.checkMatrix(e);let{l:n,p:i,iter:o,W:s,XtX:a,XtY:l,K:h,Pset:u,Fset:c,D:f}=initialisation(t,e);const{maxIterations:m=3*t.columns}=r;for(;c.length>0;){let t=cssls(a,l.subMatrixColumn(c),selection(u,c),n,c.length);for(let e=0;e<n;e++)for(let r=0;r<c.length;r++)h.set(e,c[r],t.get(e,r));let e=[];for(let r=0;r<c.length;r++)for(let i=0;i<n;i++)if(t.get(i,r)<0){e.push(r);break}let r=selection(c,e);if(r.length>0){let e=r.length,i=Matrix$2.ones(n,e);for(;e>0&&o<m;){o++,i.mul(1/0);let s=[[],[]],c=[[],[]];for(let t=0;t<e;t++)for(let e=0;e<u[r[t]].length;e++)h.get(u[r[t]][e],r[t])<0&&(s[0].push(u[r[t]][e]),s[1].push(t),c[0].push(u[r[t]][e]),c[1].push(r[t]));for(let t=0;t<s[0].length;t++)i.set(s[0][t],s[1][t],f.get(c[0][t],c[1][t])/(f.get(c[0][t],c[1][t])-h.get(c[0][t],c[1][t])));let m=[],g=[];for(let t=0;t<e;t++)m[t]=i.minColumn(t),g[t]=i.minColumnIndex(t)[0];m=Matrix$2.rowVector(m);for(let t=0;t<n;t++)i.setSubMatrix(m,t,0);let d=new Matrix$2(n,e);d=f.subMatrixColumn(r).subtract(i.subMatrix(0,n-1,0,e-1).mul(f.subMatrixColumn(r).subtract(h.subMatrixColumn(r))));for(let t=0;t<e;t++)f.setColumn(r[t],d.subMatrixColumn([t]));let p=[g,r];for(let t=0;t<e;t++)f.set(p[0][t],p[1][t],0);for(let t=0;t<e;t++)u[r[t]].splice(u[r[t]].findIndex((e=>e===g[t])),1);t=cssls(a,l.subMatrixColumn(r),selection(u,r),n,e);for(let n=0;n<e;n++)h.setColumn(r[n],t.subMatrixColumn([n]));r=[];for(let t=0;t<h.columns;t++)for(let e=0;e<n;e++)if(h.get(e,t)<0){r.push(t);break}e=r.length}}let g=optimality(o,m,a,l,c,u,s,h,n,i,f);u=g.Pset,c=g.Fset,s=g.W}return h}function fcnnlsVector(t,e,r={}){if(!1===Array.isArray(e))throw new TypeError("y must be a 1D Array");return fcnnls(t,Matrix$2.columnVector(e),r).to1DArray()}var index$2=Object.freeze({__proto__:null,fcnnls:fcnnls,fcnnlsVector:fcnnlsVector}),binarySearch=function(t,e,r,n,i){var o,s;if(void 0===n)n=0;else if((n|=0)<0||n>=t.length)throw new RangeError("invalid lower bound");if(void 0===i)i=t.length-1;else if((i|=0)<n||i>=t.length)throw new RangeError("invalid upper bound");for(;n<=i;)if((s=+r(t[o=n+(i-n>>>1)],e,o,t))<0)n=o+1;else{if(!(s>0))return o;i=o-1}return~n};function assertNumber$3(t){if("number"!=typeof t)throw new TypeError("Expected a number")}var ascending$3=(t,e)=>(assertNumber$3(t),assertNumber$3(e),Number.isNaN(t)?-1:Number.isNaN(e)?1:t-e);const largestPrime=2147483647,primeNumbers=[largestPrime,5,11,23,47,97,197,397,797,1597,3203,6421,12853,25717,51437,102877,205759,411527,823117,1646237,3292489,6584983,13169977,26339969,52679969,105359939,210719881,421439783,842879579,1685759167,433,877,1759,3527,7057,14143,28289,56591,113189,226379,452759,905551,1811107,3622219,7244441,14488931,28977863,57955739,115911563,231823147,463646329,927292699,1854585413,953,1907,3821,7643,15287,30577,61169,122347,244703,489407,978821,1957651,3915341,7830701,15661423,31322867,62645741,125291483,250582987,501165979,1002331963,2004663929,1039,2081,4177,8363,16729,33461,66923,133853,267713,535481,1070981,2141977,4283963,8567929,17135863,34271747,68543509,137087021,274174111,548348231,1096696463,31,67,137,277,557,1117,2237,4481,8963,17929,35863,71741,143483,286973,573953,1147921,2295859,4591721,9183457,18366923,36733847,73467739,146935499,293871013,587742049,1175484103,599,1201,2411,4831,9677,19373,38747,77509,155027,310081,620171,1240361,2480729,4961459,9922933,19845871,39691759,79383533,158767069,317534141,635068283,1270136683,311,631,1277,2557,5119,10243,20507,41017,82037,164089,328213,656429,1312867,2625761,5251529,10503061,21006137,42012281,84024581,168049163,336098327,672196673,1344393353,3,7,17,37,79,163,331,673,1361,2729,5471,10949,21911,43853,87719,175447,350899,701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,359339171,718678369,1437356741,43,89,179,359,719,1439,2879,5779,11579,23159,46327,92657,185323,370661,741337,1482707,2965421,5930887,11861791,23723597,47447201,94894427,189788857,379577741,759155483,1518310967,379,761,1523,3049,6101,12203,24407,48817,97649,195311,390647,781301,1562611,3125257,6250537,12501169,25002389,50004791,100009607,200019221,400038451,800076929,1600153859,13,29,59,127,257,521,1049,2099,4201,8419,16843,33703,67409,134837,269683,539389,1078787,2157587,4315183,8630387,17260781,34521589,69043189,138086407,276172823,552345671,1104691373,19,41,83,167,337,677,1361,2729,5471,10949,21911,43853,87719,175447,350899,701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,359339171,718678369,1437356741,53,107,223,449,907,1823,3659,7321,14653,29311,58631,117269,234539,469099,938207,1876417,3752839,7505681,15011389,30022781,60045577,120091177,240182359,480364727,960729461,1921458943];function nextPrime(t){let e=binarySearch(primeNumbers,t,ascending$3);return e<0&&(e=~e),primeNumbers[e]}primeNumbers.sort(ascending$3);const FREE=0,FULL=1,REMOVED=2,defaultInitialCapacity=150,defaultMinLoadFactor=1/6,defaultMaxLoadFactor=2/3;class HashTable{constructor(t={}){if(t instanceof HashTable)return this.table=t.table.slice(),this.values=t.values.slice(),this.state=t.state.slice(),this.minLoadFactor=t.minLoadFactor,this.maxLoadFactor=t.maxLoadFactor,this.distinct=t.distinct,this.freeEntries=t.freeEntries,this.lowWaterMark=t.lowWaterMark,void(this.highWaterMark=t.maxLoadFactor);const e=void 0===t.initialCapacity?defaultInitialCapacity:t.initialCapacity;if(e<0)throw new RangeError(`initial capacity must not be less than zero: ${e}`);const r=void 0===t.minLoadFactor?defaultMinLoadFactor:t.minLoadFactor,n=void 0===t.maxLoadFactor?defaultMaxLoadFactor:t.maxLoadFactor;if(r<0||r>=1)throw new RangeError(`invalid minLoadFactor: ${r}`);if(n<=0||n>=1)throw new RangeError(`invalid maxLoadFactor: ${n}`);if(r>=n)throw new RangeError(`minLoadFactor (${r}) must be smaller than maxLoadFactor (${n})`);let i=e;i=i/n|0,i=nextPrime(i),0===i&&(i=1),this.table=newArray(i),this.values=newArray(i),this.state=newArray(i),this.minLoadFactor=r,this.maxLoadFactor=i===largestPrime?1:n,this.distinct=0,this.freeEntries=i,this.lowWaterMark=0,this.highWaterMark=chooseHighWaterMark(i,this.maxLoadFactor)}clone(){return new HashTable(this)}get size(){return this.distinct}get(t){const e=this.indexOfKey(t);return e<0?0:this.values[e]}set(t,e){let r=this.indexOfInsertion(t);if(r<0)return r=-r-1,this.values[r]=e,!1;if(this.distinct>this.highWaterMark){const r=chooseGrowCapacity(this.distinct+1,this.minLoadFactor,this.maxLoadFactor);return this.rehash(r),this.set(t,e)}if(this.table[r]=t,this.values[r]=e,this.state[r]===FREE&&this.freeEntries--,this.state[r]=FULL,this.distinct++,this.freeEntries<1){const t=chooseGrowCapacity(this.distinct+1,this.minLoadFactor,this.maxLoadFactor);this.rehash(t)}return!0}remove(t,e){const r=this.indexOfKey(t);return!(r<0)&&(this.state[r]=REMOVED,this.distinct--,e||this.maybeShrinkCapacity(),!0)}delete(t,e){const r=this.indexOfKey(t);return!(r<0)&&(this.state[r]=FREE,this.distinct--,e||this.maybeShrinkCapacity(),!0)}maybeShrinkCapacity(){if(this.distinct<this.lowWaterMark){const t=chooseShrinkCapacity(this.distinct,this.minLoadFactor,this.maxLoadFactor);this.rehash(t)}}containsKey(t){return this.indexOfKey(t)>=0}indexOfKey(t){const e=this.table,r=this.state,n=this.table.length,i=2147483647&t;let o=i%n,s=i%(n-2);for(0===s&&(s=1);r[o]!==FREE&&(r[o]===REMOVED||e[o]!==t);)o-=s,o<0&&(o+=n);return r[o]===FREE?-1:o}containsValue(t){return this.indexOfValue(t)>=0}indexOfValue(t){const e=this.values,r=this.state;for(var n=0;n<r.length;n++)if(r[n]===FULL&&e[n]===t)return n;return-1}indexOfInsertion(t){const e=this.table,r=this.state,n=e.length,i=2147483647&t;let o=i%n,s=i%(n-2);for(0===s&&(s=1);r[o]===FULL&&e[o]!==t;)o-=s,o<0&&(o+=n);if(r[o]===REMOVED){const i=o;for(;r[o]!==FREE&&(r[o]===REMOVED||e[o]!==t);)o-=s,o<0&&(o+=n);r[o]===FREE&&(o=i)}return r[o]===FULL?-o-1:o}ensureCapacity(t){if(this.table.length<t){const e=nextPrime(t);this.rehash(e)}}rehash(t){const e=this.table.length;if(t<=this.distinct)throw new Error("Unexpected");const r=this.table,n=this.values,i=this.state,o=newArray(t),s=newArray(t),a=newArray(t);this.lowWaterMark=chooseLowWaterMark(t,this.minLoadFactor),this.highWaterMark=chooseHighWaterMark(t,this.maxLoadFactor),this.table=o,this.values=s,this.state=a,this.freeEntries=t-this.distinct;for(var l=0;l<e;l++)if(i[l]===FULL){var h=r[l],u=this.indexOfInsertion(h);o[u]=h,s[u]=n[l],a[u]=FULL}}forEachKey(t){for(var e=0;e<this.state.length;e++)if(this.state[e]===FULL&&!t(this.table[e]))return!1;return!0}forEachValue(t){for(var e=0;e<this.state.length;e++)if(this.state[e]===FULL&&!t(this.values[e]))return!1;return!0}forEachPair(t){for(var e=0;e<this.state.length;e++)if(this.state[e]===FULL&&!t(this.table[e],this.values[e]))return!1;return!0}}function chooseLowWaterMark(t,e){return t*e|0}function chooseHighWaterMark(t,e){return Math.min(t-2,t*e|0)}function chooseGrowCapacity(t,e,r){return nextPrime(Math.max(t+1,4*t/(3*e+r)|0))}function chooseShrinkCapacity(t,e,r){return nextPrime(Math.max(t+1,4*t/(e+3*r)|0))}function newArray(t){return Array(t).fill(0)}class SparseMatrix{constructor(t,e,r={}){if(t instanceof SparseMatrix){const e=t;this._init(e.rows,e.columns,e.elements.clone(),e.threshold)}else if(Array.isArray(t)){const n=t;t=n.length,r=e||{},e=n[0].length,this._init(t,e,new HashTable(r),r.threshold);for(let r=0;r<t;r++)for(let t=0;t<e;t++){let i=n[r][t];this.threshold&&Math.abs(i)<this.threshold&&(i=0),0!==i&&this.elements.set(r*e+t,n[r][t])}}else this._init(t,e,new HashTable(r),r.threshold)}_init(t,e,r,n){this.rows=t,this.columns=e,this.elements=r,this.threshold=n||0}static eye(t=1,e=t){const r=Math.min(t,e),n=new SparseMatrix(t,e,{initialCapacity:r});for(let t=0;t<r;t++)n.set(t,t,1);return n}clone(){return new SparseMatrix(this)}to2DArray(){const t=new Array(this.rows);for(let e=0;e<this.rows;e++){t[e]=new Array(this.columns);for(let r=0;r<this.columns;r++)t[e][r]=this.get(e,r)}return t}isSquare(){return this.rows===this.columns}isSymmetric(){if(!this.isSquare())return!1;let t=!0;return this.forEachNonZero(((e,r,n)=>this.get(r,e)!==n?(t=!1,!1):n)),t}bandWidth(){let t=this.columns,e=-1;return this.forEachNonZero(((r,n,i)=>{let o=r-n;return t=Math.min(t,o),e=Math.max(e,o),i})),e-t}isBanded(t){return this.bandWidth()<=t}get cardinality(){return this.elements.size}get size(){return this.rows*this.columns}get(t,e){return this.elements.get(t*this.columns+e)}set(t,e,r){return this.threshold&&Math.abs(r)<this.threshold&&(r=0),0===r?this.elements.remove(t*this.columns+e):this.elements.set(t*this.columns+e,r),this}mmul(t){this.columns!==t.rows&&console.warn("Number of columns of left matrix are not equal to number of rows of right matrix.");const e=this.rows,r=t.columns,n=new SparseMatrix(e,r);return this.forEachNonZero(((e,r,i)=>(t.forEachNonZero(((t,o,s)=>(r===t&&n.set(e,o,n.get(e,o)+i*s),s))),i))),n}kroneckerProduct(t){const e=this.rows,r=this.columns,n=t.rows,i=t.columns,o=new SparseMatrix(e*n,r*i,{initialCapacity:this.cardinality*t.cardinality});return this.forEachNonZero(((e,r,s)=>(t.forEachNonZero(((t,a,l)=>(o.set(n*e+t,i*r+a,s*l),l))),s))),o}forEachNonZero(t){return this.elements.forEachPair(((e,r)=>{const n=e/this.columns|0,i=e%this.columns;let o=t(n,i,r);return!1!==o&&(this.threshold&&Math.abs(o)<this.threshold&&(o=0),o!==r&&(0===o?this.elements.remove(e,!0):this.elements.set(e,o)),!0)})),this.elements.maybeShrinkCapacity(),this}getNonZeros(){const t=this.cardinality,e=new Array(t),r=new Array(t),n=new Array(t);let i=0;return this.forEachNonZero(((t,o,s)=>(e[i]=t,r[i]=o,n[i]=s,i++,s))),{rows:e,columns:r,values:n}}setThreshold(t){return 0!==t&&t!==this.threshold&&(this.threshold=t,this.forEachNonZero(((t,e,r)=>r))),this}transpose(){let t=new SparseMatrix(this.columns,this.rows,{initialCapacity:this.cardinality});return this.forEachNonZero(((e,r,n)=>(t.set(r,e,n),n))),t}isEmpty(){return 0===this.rows||0===this.columns}}SparseMatrix.prototype.klass="Matrix",SparseMatrix.identity=SparseMatrix.eye,SparseMatrix.prototype.tensorProduct=SparseMatrix.prototype.kroneckerProduct;let inplaceOperator="\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n",inplaceOperatorScalar="\n(function %name%S(value) {\n    this.forEachNonZero((i, j, v) => v %op% value);\n    return this;\n})\n",inplaceOperatorMatrix="\n(function %name%M(matrix) {\n    matrix.forEachNonZero((i, j, v) => {\n        this.set(i, j, this.get(i, j) %op% v);\n        return v;\n    });\n    return this;\n})\n",staticOperator="\n(function %name%(matrix, value) {\n    var newMatrix = new SparseMatrix(matrix);\n    return newMatrix.%name%(value);\n})\n",inplaceMethod="\n(function %name%() {\n    this.forEachNonZero((i, j, v) => %method%(v));\n    return this;\n})\n",staticMethod="\n(function %name%(matrix) {\n    var newMatrix = new SparseMatrix(matrix);\n    return newMatrix.%name%();\n})\n";const operators=[["+","add"],["-","sub","subtract"],["*","mul","multiply"],["/","div","divide"],["%","mod","modulus"],["&","and"],["|","or"],["^","xor"],["<<","leftShift"],[">>","signPropagatingRightShift"],[">>>","rightShift","zeroFillRightShift"]];for(const operator of operators)for(let i=1;i<operator.length;i++)SparseMatrix.prototype[operator[i]]=eval(fillTemplateFunction(inplaceOperator,{name:operator[i],op:operator[0]})),SparseMatrix.prototype[`${operator[i]}S`]=eval(fillTemplateFunction(inplaceOperatorScalar,{name:`${operator[i]}S`,op:operator[0]})),SparseMatrix.prototype[`${operator[i]}M`]=eval(fillTemplateFunction(inplaceOperatorMatrix,{name:`${operator[i]}M`,op:operator[0]})),SparseMatrix[operator[i]]=eval(fillTemplateFunction(staticOperator,{name:operator[i]}));let methods=[["~","not"]];["abs","acos","acosh","asin","asinh","atan","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","log","log1p","log10","log2","round","sign","sin","sinh","sqrt","tan","tanh","trunc"].forEach((function(t){methods.push([`Math.${t}`,t])}));for(const method of methods)for(let i=1;i<method.length;i++)SparseMatrix.prototype[method[i]]=eval(fillTemplateFunction(inplaceMethod,{name:method[i],method:method[0]})),SparseMatrix[method[i]]=eval(fillTemplateFunction(staticMethod,{name:method[i]}));function fillTemplateFunction(t,e){for(const r in e)t=t.replace(new RegExp(`%${r}%`,"g"),e[r]);return t}function additiveSymmetric(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])*(t[r]+e[r])/(t[r]*e[r]);return 2*i}function avg(t,e){for(var r=t.length,n=0,i=0,o=0,s=0;s<r;s++)i+=o=Math.abs(t[s]-e[s]),n<o&&(n=o);return(n+i)/2}function bhattacharyya(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.sqrt(t[i]*e[i]);return-Math.log(n)}function canberra(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.abs(t[i]-e[i])/(t[i]+e[i]);return n}function chebyshev(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n<(i=Math.abs(t[o]-e[o]))&&(n=i);return n}function clark(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=Math.sqrt((t[r]-e[r])*(t[r]-e[r])/((t[r]+e[r])*(t[r]+e[r])));return 2*i}function czekanowskiSimilarity(t,e){for(var r=0,n=0,i=0;i<t.length;i++)r+=Math.min(t[i],e[i]),n+=t[i]+e[i];return 2*r/n}function czekanowskiDistance(t,e){return 1-czekanowskiSimilarity(t,e)}function dice$1(t,e){for(var r=t.length,n=0,i=0,o=0,s=0;s<r;s++)n+=t[s]*t[s],i+=e[s]*e[s],o+=(t[s]-e[s])*(t[s]-e[s]);return o/(n+i)}function divergence(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/((t[r]+e[r])*(t[r]+e[r]));return 2*i}function fidelity(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.sqrt(t[i]*e[i]);return n}function gower(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.abs(t[i]-e[i]);return n/r}function harmonicMean(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*e[i]/(t[i]+e[i]);return 2*n}function hellinger(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.sqrt(t[i]*e[i]);return 2*Math.sqrt(1-n)}function innerProduct(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*e[i];return n}function intersection$1(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.min(t[i],e[i]);return 1-n}function jaccard$1(t,e){for(var r=t.length,n=0,i=0,o=0,s=0,a=0;a<r;a++)n+=t[a]*e[a],i+=t[a]*t[a],o+=e[a]*e[a],s+=(t[a]-e[a])*(t[a]-e[a]);return s/(i+o-n)}function jeffreys(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=(t[i]-e[i])*Math.log(t[i]/e[i]);return n}function jensenDifference(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=(t[i]*Math.log(t[i])+e[i]*Math.log(e[i]))/2-(t[i]+e[i])/2*Math.log((t[i]+e[i])/2);return n}function jensenShannon(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=t[o]*Math.log(2*t[o]/(t[o]+e[o])),i+=e[o]*Math.log(2*e[o]/(t[o]+e[o]));return(n+i)/2}function kdivergence(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*Math.log(2*t[i]/(t[i]+e[i]));return n}function kulczynski$1(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.abs(t[o]-e[o]),i+=Math.min(t[o],e[o]);return n/i}function kullbackLeibler(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*Math.log(t[i]/e[i]);return n}function kumarHassebrook(t,e){for(var r=t.length,n=0,i=0,o=0,s=0;s<r;s++)n+=t[s]*e[s],i+=t[s]*t[s],o+=e[s]*e[s];return n/(i+o-n)}function kumarJohnson(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.pow(t[i]*t[i]-e[i]*e[i],2)/(2*Math.pow(t[i]*e[i],1.5));return n}function lorentzian(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.log(Math.abs(t[i]-e[i])+1);return n}function manhattan(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=Math.abs(t[r]-e[r]);return i}function matusita(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.sqrt(t[i]*e[i]);return Math.sqrt(2-2*n)}function minkowski(t,e,r){for(var n=0,i=t.length,o=0;n<i;n++)o+=Math.pow(Math.abs(t[n]-e[n]),r);return Math.pow(o,1/r)}function motyka$1(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.min(t[o],e[o]),i+=t[o]+e[o];return 1-n/i}function neyman(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/t[r];return i}function pearson$1(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/e[r];return i}function probabilisticSymmetric(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/(t[r]+e[r]);return 2*i}function ruzicka(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.min(t[o],e[o]),i+=Math.max(t[o],e[o]);return n/i}function soergel(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.abs(t[o]-e[o]),i+=Math.max(t[o],e[o]);return n/i}function sorensen(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.abs(t[o]-e[o]),i+=t[o]+e[o];return n/i}function squared(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/(t[r]+e[r]);return i}function squaredChord$1(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=(Math.sqrt(t[i])-Math.sqrt(e[i]))*(Math.sqrt(t[i])-Math.sqrt(e[i]));return n}function taneja(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=(t[i]+e[i])/2*Math.log((t[i]+e[i])/(2*Math.sqrt(t[i]*e[i])));return n}function tanimoto$1(t,e,r){if(r){for(var n=0,i=0,o=0;o<t.length;o++)n+=t[o]&&e[o],i+=t[o]||e[o];return 0===i?1:n/i}for(var s=t.length,a=0,l=0,h=0,u=0;u<s;u++)a+=t[u],l+=e[u],h+=Math.min(t[u],e[u]);return 1-(a+l-2*h)/(a+l-h)}function tanimoto(t,e,r){if(r)return 1-tanimoto$1(t,e,r);for(var n=t.length,i=0,o=0,s=0,a=0;a<n;a++)i+=t[a],o+=e[a],s+=Math.min(t[a],e[a]);return(i+o-2*s)/(i+o-s)}function topsoe(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*Math.log(2*t[i]/(t[i]+e[i]))+e[i]*Math.log(2*e[i]/(t[i]+e[i]));return n}function waveHedges(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=1-Math.min(t[i],e[i])/Math.max(t[i],e[i]);return n}var distances=Object.freeze({__proto__:null,euclidean:euclidean$2,squaredEuclidean:squaredEuclidean$4,additiveSymmetric:additiveSymmetric,avg:avg,bhattacharyya:bhattacharyya,canberra:canberra,chebyshev:chebyshev,clark:clark,czekanowski:czekanowskiDistance,dice:dice$1,divergence:divergence,fidelity:fidelity,gower:gower,harmonicMean:harmonicMean,hellinger:hellinger,innerProduct:innerProduct,intersection:intersection$1,jaccard:jaccard$1,jeffreys:jeffreys,jensenDifference:jensenDifference,jensenShannon:jensenShannon,kdivergence:kdivergence,kulczynski:kulczynski$1,kullbackLeibler:kullbackLeibler,kumarHassebrook:kumarHassebrook,kumarJohnson:kumarJohnson,lorentzian:lorentzian,manhattan:manhattan,matusita:matusita,minkowski:minkowski,motyka:motyka$1,neyman:neyman,pearson:pearson$1,probabilisticSymmetric:probabilisticSymmetric,ruzicka:ruzicka,soergel:soergel,sorensen:sorensen,squared:squared,squaredChord:squaredChord$1,taneja:taneja,tanimoto:tanimoto,topsoe:topsoe,waveHedges:waveHedges});function assertNumber$2(t){if("number"!=typeof t)throw new TypeError("Expected a number")}var ascending$2=(t,e)=>(assertNumber$2(t),assertNumber$2(e),Number.isNaN(t)?-1:Number.isNaN(e)?1:t-e);function createTree(t,e={}){var r=t[0];const{minWindow:n=.16,threshold:i=.01,from:o=r[0],to:s=r[r.length-1]}=e;return mainCreateTree(t[0],t[1],o,s,n,i)}function mainCreateTree(t,e,r,n,i,o){if(n-r<i)return null;var s=binarySearch(t,r,ascending$2);s<0&&(s=~s);for(var a=0,l=0,h=s;h<t.length&&!(t[h]>=n);h++)a+=e[h],l+=t[h]*e[h];return a<o||(l/=a)-r<1e-6||n-l<1e-6?null:l-r<i/4?mainCreateTree(t,e,l,n,i,o):n-l<i/4?mainCreateTree(t,e,r,l,i,o):new Tree(a,l,mainCreateTree(t,e,r,l,i,o),mainCreateTree(t,e,l,n,i,o))}class Tree{constructor(t,e,r,n){this.sum=t,this.center=e,this.left=r,this.right=n}}function getSimilarity(t,e,r={}){const{alpha:n=.1,beta:i=.33,gamma:o=.001}=r;return null===t||null===e?0:(Array.isArray(t)&&(t=createTree(t)),Array.isArray(e)&&(e=createTree(e)),i*(n*Math.min(t.sum,e.sum)/Math.max(t.sum,e.sum)+(1-n)*Math.exp(-o*Math.abs(t.center-e.center)))+(1-i)*(getSimilarity(t.left,e.left,r)+getSimilarity(t.right,e.right,r))/2)}function treeSimilarity(t,e,r={}){return getSimilarity(t,e,r)}function getFunction(t={}){return(e,r)=>getSimilarity(e,r,t)}var index$1=Object.freeze({__proto__:null,treeSimilarity:treeSimilarity,getFunction:getFunction,createTree:createTree});function cosine(t,e){for(var r=t.length,n=0,i=0,o=0,s=0;s<r;s++)n+=t[s]*e[s],i+=t[s]*t[s],o+=e[s]*e[s];return n/(Math.sqrt(i)*Math.sqrt(o))}function dice(t,e){return 1-dice$1(t,e)}function intersection(t,e){return 1-intersection$1(t,e)}function jaccard(t,e){return 1-jaccard$1(t,e)}function kulczynski(t,e){return 1/kulczynski$1(t,e)}function motyka(t,e){return 1-motyka$1(t,e)}function pearson(t,e){for(var r=mean$1(t),n=mean$1(e),i=new Array(t.length),o=new Array(e.length),s=0;s<i.length;s++)i[s]=t[s]-r,o[s]=e[s]-n;return cosine(i,o)}function squaredChord(t,e){return 1-squaredChord$1(t,e)}var similarities=Object.freeze({__proto__:null,tree:index$1,cosine:cosine,czekanowski:czekanowskiSimilarity,dice:dice,intersection:intersection,jaccard:jaccard,kulczynski:kulczynski,motyka:motyka,pearson:pearson,squaredChord:squaredChord,tanimoto:tanimoto$1});function zeroInsteadOfNegative(t){let e=t.rows,r=t.columns,n=new Matrix$2(t);for(let t=0;t<e;t++)for(let e=0;e<r;e++)n.get(t,e)<0&&n.set(t,e,0);return n}function checkMatrixS(t,e){let{A:r,S:n}=t,i=[],o=n.sum("row");for(let t=0;t<o.length;t++)if(0!==o[t]){for(let e=0;e<n.columns;e++)if(isNaN(n.get(t,e))){i.push(t);break}}else i.push(t);if(i.length>0){let t=fastExtractNMF(e.clone().subM(r.mmul(n)),i.length);for(let e=0;e<i.length;e++){for(let r=0;r<n.columns;r++)n.set(i[e],r,t.S.get(e,r));for(let n=0;n<r.rows;n++)r.set(n,i[e],t.A.get(n,e))}}return Object.assign({},t,{A:r,S:n})}function fastExtractNMF(t,e){if(e<=0)return{A:[],S:[]};const{columns:r,rows:n}=t;let i=Matrix$2.zeros(n,e),o=Matrix$2.zeros(e,r);for(let s=0;s<e;s++){if(0===(t=zeroInsteadOfNegative(t)).sum())continue;let e=Matrix$2.pow(t,2).sum("column"),a=0;for(let t=1;t<e.length;t++)e[a]<e[t]&&(a=t);if(e[a]>0){let l=Math.sqrt(e[a]);for(let e=0;e<n;e++){let r=t.get(e,a)/l;i.set(e,s,r)}let h=i.getColumnVector(s).transpose().mmul(t);for(let t=0;t<r;t++)o.set(s,t,Math.max(h.get(0,t),0));let u=i.getColumnVector(s).mmul(o.getRowVector(s));t=t.sub(u)}}return{A:i,S:o}}function normBy(t,e="column"){let r=Matrix$2.mul(t,t).sum(e),n=r.length;for(let t=0;t<n;t++)r[t]=Math.sqrt(r[t]);return"row"===e?Matrix$2.from1DArray(n,1,r):Matrix$2.from1DArray(1,n,r)}function normProj(t,e){let r,n=t.rows,i=t.columns;if(e.rows===n){r=normBy(t,"row");for(let o=0;o<n;o++)if(!(r.get(o,0)<=0))for(let n=0;n<i;n++){let i=t.get(o,n)*Math.min(r.get(o,0),e.get(o,0)/r.get(o,0));t.set(o,n,i)}}else{r=normBy(t,"column");for(let o=0;o<i;o++)if(!(r.get(0,o)<=0))for(let i=0;i<n;i++){let n=t.get(i,o)*Math.min(r.get(0,o),e.get(0,o)/r.get(0,o));t.set(i,o,n)}}return t}function updateMatrixA(t,e,r,n){let i,{maxFBIteration:o,toleranceFB:s,normConstrained:a=!1,lambda:l}=n,h=e.transpose(),u=e.mmul(h),c=r.mmul(h),f=new EigenvalueDecomposition(u,{assumeSymmetric:!0}),m=Math.max(...f.realEigenvalues),g=t,d=g.clone(),p=1;if(a){let e=normBy(t,"column");i=(t,r)=>normProj(zeroInsteadOfNegative(t.subS(r)),e)}else i=(t,e)=>zeroInsteadOfNegative(t.subS(e));for(let t=0;t<o;t++){let t=(1+Math.sqrt(1+4*p*p))/2,e=(p-1)/t;p=t;let r=Matrix$2.mul(g,e+1).sub(Matrix$2.mul(d,e));if(d=g.clone(),g=i(r.sub((w=r,w.mmul(u).sub(c)).divS(m)),l/m),Matrix$2.sub(d,g).norm()/g.norm()<s)break}var w;return g}function getMax(t=[]){let e=Number.MIN_SAFE_INTEGER;for(let r=0;r<t.length;r++)e<t[r]&&(e=t[r]);return e}function updateMatrixS(t,e,r,n,i){let{maxFBIteration:o,toleranceFB:s}=i,a=t.transpose(),l=a.mmul(t),h=a.mmul(r),u=getMax(new EigenvalueDecomposition(l,{assumeSymmetric:!0}).realEigenvalues),c=1,f=e.clone(),m=f.clone(),g=(t,e)=>zeroInsteadOfNegative(t.subS(e));for(let t=0;t<o;t++){let t=(1+Math.sqrt(1+4*c*c))/2,e=(c-1)/t;c=t;let r=Matrix$2.mul(f,1+e).sub(Matrix$2.mul(m,e));if(m=f.clone(),f=g(r.sub((d=r,l.mmul(d).sub(h)).divS(u)),n/u),Matrix$2.sub(m,f).norm()/f.norm()<s)break}var d;return f}function initialize(t,e={}){const{rank:r,randGenerator:n,maxInitFBIteration:i,toleranceFBInit:o,maxFBIteration:s,toleranceFB:a,normConstrained:l}=e;let h={},u=t.rows;h.A=Matrix$2.rand(u,r,{random:n});for(let e=0;e<i;e++){let e=h.A.sum("column");for(let t=0;t<e.length;t++)for(;0===e[t];){e[t]=0;for(let r=0;r<u;r++)h.A.set(r,t,n()),e[t]+=h.A.get(r,t)}h.S=zeroInsteadOfNegative(solve(h.A,t));let r=h.S.sum("row"),i=[],l=[];for(let t=0;t<r.length;t++)r[t]>0&&(i.push(t),l.push(h.S.getRow(t)));l=Matrix$2.checkMatrix(l);let c=zeroInsteadOfNegative(solve(l.transpose(),t.transpose()));for(let t=0;t<i.length;t++){let e=c.getRow(t);for(let r=0;r<u;r++)h.A.set(r,i[t],e[r])}let f=h.S.clone();if(h.S=updateMatrixS(h.A,h.S,t,0,{maxFBIteration:s,toleranceFB:a}),h=checkMatrixS(h,t),h.A=updateMatrixA(h.A,h.S,t,0),Matrix$2.sub(f,h.S).norm()/h.S.norm()<o)break}return h}function normalize$1(t,e){const{normOnA:r}=e;let n,i,o=normBy(t.S.transpose(),"column"),s=normBy(t.A,"column"),a=Matrix$2.mul(o,s);r?(n=(e,r)=>t.S.get(e,r)*a.get(0,e)/o.get(0,e),i=(e,r)=>t.A.get(r,e)/s.get(0,e)):(n=(e,r)=>t.S.get(e,r)/o.get(0,e),i=(e,r)=>t.A.get(r,e)*a.get(0,e)/s.get(0,e));const l=t.S.columns,h=t.A.rows;for(let e=0;e<a.columns;e++){let r,o;a.get(0,e)>0?(r=n,o=i):(o=()=>0,r=()=>0);for(let n=0;n<l;n++)t.S.set(e,n,r(e,n));for(let r=0;r<h;r++)t.A.set(r,e,o(e,r))}return t}function getMedians(t,e){let r=[],n=t.rows,i=t.columns;switch(e){case"column":for(let e=0;e<i;e++)r.push(medianQuickselect_min(t.getColumn(e)));r=Matrix$2.from1DArray(1,i,r);break;default:for(let e=0;e<n;e++)r.push(medianQuickselect_min(t.getRow(e)));r=Matrix$2.from1DArray(n,1,r)}return r}function dimMADstd(t,e){let r=getMedians(t,e),n=t.clone();return n="column"===e?n.subRowVector(r.to1DArray()):n.subColumnVector(r.to1DArray()),Matrix$2.mul(getMedians(n.abs(),e),1.4826)}function updateLambda(t,e,r={}){let n,{refinementBeginning:i,tauMAD:o}=r,{iteration:s,lambda:a,A:l,S:h}=t;if(i<=s)return a;if(void 0!==r.lambdaInf)n=r.lambdaInf/r.tauMAD;else if(void 0!==r.addStd)n=r.addStd;else{let t=Matrix$2.sub(e,l.mmul(h)).to1DArray();n=dimMADstd(Matrix$2.from1DArray(1,t.length,t),"row").get(0,0)}return Math.max(o*n,a-1/(i-s))}function nGMCA(t,e,r={}){const{maximumIteration:n=500,maxFBIteration:i=80,maxInitFBIteration:o=50,toleranceFBInit:s=0,toleranceFB:a=1e-5,phaseRatio:l=.8,randGenerator:h=Math.random,tauMAD:u=1,useTranspose:c=!1}=r;let{normConstrained:f=!1}=r;t=Matrix$2.checkMatrix(t),c&&(t=t.transpose());let m=Math.floor(l*n),g=initialize(t,{rank:e,randGenerator:h,maxInitFBIteration:o,toleranceFBInit:s,maxFBIteration:i,toleranceFB:a});g=normalize$1(g,{normOnA:!0}),g.lambda=g.A.transpose().mmul(g.A.mmul(g.S).sub(t)).abs().max();for(let e=0;e<n;e++)g.iteration=e,g.S=updateMatrixS(g.A,g.S,t,g.lambda,r),g=checkMatrixS(g,t),g=normalize$1(g,{normOnA:!1}),e>m&&(f=!0),g.A=updateMatrixA(g.A,g.S,t,{maxFBIteration:i,toleranceFB:a,normConstrained:f,lambda:0}),g=normalize$1(g,{normOnA:!0}),g.lambda=updateLambda(g,t,{refinementBeginning:m,tauMAD:u});if(c){let t=g.A.transpose();g.A=g.S.transpose(),g.S=t}return g}var acc=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=(t.tn[n]+t.tp[n])/(e-1);return r},err=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fn[n]+t.fp[n]/(e-1);return r},fpr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fp[n]/t.nNeg;return r},tpr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.tp[n]/t.nPos;return r},fnr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fn[n]/t.nPos;return r},tnr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.tn[n]/t.nNeg;return r},ppv=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fp[n]+t.tp[n]!==0?t.tp[n]/(t.fp[n]+t.tp[n]):0;return r},npv=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fn[n]+t.tn[n]!==0?t.tn[n]/(t.fn[n]+t.tn[n]):0;return r},pcfall=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fp[n]+t.tp[n]!==0?1-t.tp[n]/(t.fp[n]+t.tp[n]):1;return r},pcmiss=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fn[n]+t.tn[n]!==0?1-t.tn[n]/(t.fn[n]+t.tn[n]):1;return r},lift=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=0!==t.nPosPred[n]?t.tp[n]/t.nPos/(t.nPosPred[n]/t.nSamples):0;return r},rpp=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.nPosPred[n]/t.nSamples;return r},rnp=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.nNegPred[n]/t.nSamples;return r},threshold=t=>{const e=t.cutoffs.slice();return e[0]=e[1],e},measures={acc:acc,err:err,fpr:fpr,tpr:tpr,fnr:fnr,tnr:tnr,ppv:ppv,npv:npv,pcfall:pcfall,pcmiss:pcmiss,lift:lift,rpp:rpp,rnp:rnp,threshold:threshold};class Performance{constructor(t,e,r){if(r=r||{},t.length!==e.length||t[0].length!==e[0].length)throw new Error("dimensions of prediction and target do not match");const n=t.length,i=t[0].length,o=!r.max,s=[];if(r.all)for(var a=0;a<n;a++)for(var l=0;l<i;l++)s.push({pred:t[a][l],targ:e[a][l]});else{if(n<3||n!==i)throw new Error('When "all" option is false, the prediction matrix must be square and have at least 3 columns');for(a=0;a<n-1;a++)for(l=a+1;l<i;l++)s.push({pred:t[a][l],targ:e[a][l]})}o?s.sort(((t,e)=>t.pred-e.pred)):s.sort(((t,e)=>e.pred-t.pred));const h=this.cutoffs=[o?Number.MIN_VALUE:Number.MAX_VALUE],u=this.fp=[0],c=this.tp=[0];var f=0,m=0,g=s[0].pred,d=0,p=0;for(a=0;a<s.length;a++)s[a].pred!==g&&(h.push(g),u.push(p),c.push(d),g=s[a].pred),s[a].targ?(f++,d++):(m++,p++);h.push(g),u.push(p),c.push(d);const w=h.length,x=this.fn=new Array(w),y=this.tn=new Array(w),M=this.nPosPred=new Array(w),v=this.nNegPred=new Array(w);for(a=0;a<w;a++)x[a]=f-c[a],y[a]=m-u[a],M[a]=c[a]+u[a],v[a]=y[a]+x[a];this.nPos=f,this.nNeg=m,this.nSamples=f+m}getMeasure(t){if("string"!=typeof t)throw new Error("No measure specified");if(!measures[t])throw new Error(`The specified measure (${t}) does not exist`);return measures[t](this)}getAURC(){const t=this.cutoffs.length,e=new Array(t),r=new Array(t);for(var n=0;n<t;n++)e[n]=this.fp[n]/this.nNeg,r[n]=this.tp[n]/this.nPos;var i=0;for(n=1;n<t;n++)i+=.5*(e[n]-e[n-1])*(r[n]+r[n-1]);return i}getAUDC(){const t=this.cutoffs.length,e=new Array(t),r=new Array(t);for(var n=0;n<t;n++)e[n]=this.fn[n]/this.nPos,r[n]=this.fp[n]/this.nNeg;var i=0;for(n=1;n<t;n++)i+=.5*(e[n]+e[n-1])*(r[n]-r[n-1]);return i}getDistribution(t){t=t||{};for(var e=this.cutoffs.length,r=t.xMin||Math.floor(100*this.cutoffs[e-1])/100,n=t.xMax||Math.ceil(100*this.cutoffs[1])/100,i=t.interval||Math.floor((n-r)/20*1e7-1)/1e7,o=[],s=[],a=[],l=[],h=[],u=this.tp[e-1],c=0,f=this.fp[e-1],m=0,g=r,d=e-1;g<=n;g+=i){for(;this.cutoffs[d]<g;)d--;o.push(g);var p=u-c-this.tp[d],w=f-m-this.fp[d];c+=p,m+=w,s.push(w),a.push(p),l.push(100-(f-this.fp[d])/f*100),h.push(100-(u-this.tp[d])/u*100)}return{xLabels:o,interValues:s,intraValues:a,interCumPercent:l,intraCumPercent:h}}}Performance.names={acc:"Accuracy",err:"Error rate",fpr:"False positive rate",tpr:"True positive rate",fnr:"False negative rate",tnr:"True negative rate",ppv:"Positive predictive value",npv:"Negative predictive value",pcfall:"Prediction-conditioned fallout",pcmiss:"Prediction-conditioned miss",lift:"Lift value",rpp:"Rate of positive predictions",rnp:"Rate of negative predictions",threshold:"Threshold"};var src$2=Performance,defaultOptions$1={size:1,value:0};function arrayCase(t,e){var r=t.length;"number"==typeof e.size&&(e.size=[e.size,e.size]);var n,i,o=r+e.size[0]+e.size[1];if(e.output){if(e.output.length!==o)throw new RangeError("Wrong output size");n=e.output}else n=new Array(o);if("circular"===e.value)for(i=0;i<o;i++)i<e.size[0]?n[i]=t[(r-e.size[0]%r+i)%r]:i<e.size[0]+r?n[i]=t[i-e.size[0]]:n[i]=t[(i-e.size[0])%r];else if("replicate"===e.value)for(i=0;i<o;i++)i<e.size[0]?n[i]=t[0]:i<e.size[0]+r?n[i]=t[i-e.size[0]]:n[i]=t[r-1];else if("symmetric"===e.value){if(e.size[0]>r||e.size[1]>r)throw new RangeError("expanded value should not be bigger than the data length");for(i=0;i<o;i++)i<e.size[0]?n[i]=t[e.size[0]-1-i]:i<e.size[0]+r?n[i]=t[i-e.size[0]]:n[i]=t[2*r+e.size[0]-i-1]}else for(i=0;i<o;i++)i<e.size[0]?n[i]=e.value:i<e.size[0]+r?n[i]=t[i-e.size[0]]:n[i]=e.value;return n}function matrixCase(t,e){throw void 0===e.size[0]&&(e.size=[e.size,e.size,e.size,e.size]),new Error("matrix not supported yet, sorry")}function padArray(t,e){if(e=Object.assign({},defaultOptions$1,e),Array.isArray(t))return Array.isArray(t[0])?matrixCase(t,e):arrayCase(t,e);throw new TypeError("data should be an array")}var src$1=padArray;function factorial(t){let e=1;for(;t>0;)e*=t--;return e}const defaultOptions={windowSize:5,derivative:1,polynomial:2,pad:"none",padValue:"replicate"};function savitzkyGolay(t,e,r){if((r=Object.assign({},defaultOptions,r)).windowSize%2==0||r.windowSize<5||!Number.isInteger(r.windowSize))throw new RangeError("Invalid window size (should be odd and at least 5 integer number)");if(r.derivative<0||!Number.isInteger(r.derivative))throw new RangeError("Derivative should be a positive integer");if(r.polynomial<1||!Number.isInteger(r.polynomial))throw new RangeError("Polynomial should be a positive integer");let n,i,o=Math.floor(r.windowSize/2);"pre"===r.pad&&(t=src$1(t,{size:o,value:r.padValue}));let s=new Array(t.length-2*o);if(5!==r.windowSize||2!==r.polynomial||1!==r.derivative&&2!==r.derivative){let t=Matrix$2.ones(r.windowSize,r.polynomial+1),e=-(r.windowSize-1)/2;for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)e+1===0&&0===n||t.set(r,n,Math.pow(e+r,n));let o=new MatrixTransposeView$1(t);n=inverse(o.mmul(t)).mmul(o),n=n.getRow(r.derivative),i=1/factorial(r.derivative)}else 1===r.derivative?(n=[-2,-1,0,1,2],i=10):(n=[2,-1,-2,-1,2],i=7);let a=i*Math.pow(e,r.derivative);for(let e=o;e<t.length-o;e++){let r=0;for(let i=0;i<n.length;i++)r+=n[i]*t[i+e-o]/a;s[e-o]=r}return"post"===r.pad&&(s=src$1(s,{size:o,value:r.padValue})),s}for(var ans=new Array(256),i=0;i<256;i++){for(var num=i,c=0;num;)num&=num-1,c++;ans[i]=c}var creator=ans;function count(t){for(var e=0,r=0;r<t.length;r++)e+=creator[255&t[r]]+creator[t[r]>>8&255]+creator[t[r]>>16&255]+creator[t[r]>>24&255];return e}function and(t,e){for(var r=new Array(t.length),n=0;n<t.length;n++)r[n]=t[n]&e[n];return r}function or(t,e){for(var r=new Array(t.length),n=0;n<t.length;n++)r[n]=t[n]|e[n];return r}function xor(t,e){for(var r=new Array(t.length),n=0;n<t.length;n++)r[n]=t[n]^e[n];return r}function not(t){for(var e=new Array(t.length),r=0;r<e.length;r++)e[r]=~t[r];return e}function getBit(t,e){var r=1<<31-e%32;return Boolean(t[e>>5]&r)}function setBit(t,e,r){var n=e>>5,i=1<<31-e%32;return t[n]=r?i|t[n]:~i&t[n],t}function toBinaryString(t){for(var e="",r=0;r<t.length;r++){var n=(t[r]>>>0).toString(2);e+="00000000000000000000000000000000".substr(n.length)+n}return e}function parseBinaryString(t){for(var e=t.length/32,r=new Array(e),n=0;n<e;n++)r[n]=0|parseInt(t.substr(32*n,32),2);return r}function toHexString(t){for(var e="",r=0;r<t.length;r++){var n=(t[r]>>>0).toString(16);e+="00000000".substr(n.length)+n}return e}function parseHexString(t){for(var e=t.length/8,r=new Array(e),n=0;n<e;n++)r[n]=0|parseInt(t.substr(8*n,8),16);return r}function toDebug(t){for(var e=toBinaryString(t),r="",n=0;n<t.length;n++){r+="0000".substr((32*n).toString(16).length)+(32*n).toString(16)+":";for(var i=0;i<32;i+=4)r+=" "+e.substr(32*n+i,4);n<t.length-1&&(r+="\n")}return r}var src={count:count,and:and,or:or,xor:xor,not:not,getBit:getBit,setBit:setBit,toBinaryString:toBinaryString,parseBinaryString:parseBinaryString,toHexString:toHexString,parseHexString:parseHexString,toDebug:toDebug};const GAUSSIAN_EXP_FACTOR=-4*Math.LN2,ROOT_PI_OVER_LN2=Math.sqrt(Math.PI/Math.LN2),ROOT_THREE=Math.sqrt(3),ROOT_2LN2=Math.sqrt(2*Math.LN2),ROOT_2LN2_MINUS_ONE=Math.sqrt(2*Math.LN2)-1;function erfinv(t){if(0===t)return 0;let e=Math.log(1-t*t),r=e/2+2/(.147*Math.PI),n=Math.sqrt(r**2-e/.147);return Math.sqrt(n-r)*(t>0?1:-1)}class Gaussian{constructor(t={}){this.fwhm=t.sd?Gaussian.widthToFWHM(2*t.sd):t.fwhm?t.fwhm:500,this.height=void 0===t.height?Math.sqrt(-GAUSSIAN_EXP_FACTOR/Math.PI)/this.fwhm:t.height}getData(t={}){let{length:e,factor:r=this.getFactor()}=t;e||(e=Math.min(Math.ceil(this.fwhm*r),Math.pow(2,25)-1),e%2==0&&e++);const n=(e-1)/2,i=new Float64Array(e);for(let t=0;t<=n;t++)i[t]=this.fct(t-n)*this.height,i[e-1-t]=i[t];return i}fct(t){return Gaussian.fct(t,this.fwhm)}getFactor(t=.9999){return Gaussian.getFactor(t)}getArea(){return Gaussian.getArea(this.fwhm,{height:this.height})}widthToFWHM(t){return Gaussian.widthToFWHM(t)}fwhmToWidth(t=this.fwhm){return Gaussian.fwhmToWidth(t)}setFWHM(t){this.fwhm=t}setHeight(t){this.height=t}}Gaussian.fct=function(t,e=500){return Math.exp(GAUSSIAN_EXP_FACTOR*Math.pow(t/e,2))},Gaussian.widthToFWHM=function(t){return t*ROOT_2LN2},Gaussian.fwhmToWidth=function(t){return t/ROOT_2LN2},Gaussian.getArea=function(t,e={}){let{height:r=1}=e;return r*ROOT_PI_OVER_LN2*t/2},Gaussian.getFactor=function(t=.9999){return Math.sqrt(2)*erfinv(t)};class Lorentzian{constructor(t={}){this.fwhm=void 0===t.fwhm?500:t.fwhm,this.height=void 0===t.height?2/Math.PI/this.fwhm:t.height}getData(t={}){let{length:e,factor:r=this.getFactor()}=t;e||(e=Math.min(Math.ceil(this.fwhm*r),Math.pow(2,25)-1),e%2==0&&e++);const n=(e-1)/2,i=new Float64Array(e);for(let t=0;t<=n;t++)i[t]=this.fct(t-n)*this.height,i[e-1-t]=i[t];return i}fct(t){return Lorentzian.fct(t,this.fwhm)}getFactor(t=.9999){return Lorentzian.getFactor(t)}getArea(){return Lorentzian.getArea(this.fwhm,{height:this.height})}fwhmToWidth(t=this.fwhm){return Lorentzian.fwhmToWidth(t)}widthToFWHM(t){return Lorentzian.widthToFWHM(t)}setFWHM(t){this.fwhm=t}setHeight(t){this.height=t}}Lorentzian.fct=function(t,e){const r=e*e;return r/(4*Math.pow(t,2)+r)},Lorentzian.fwhmToWidth=function(t){return t/ROOT_THREE},Lorentzian.widthToFWHM=function(t){return t*ROOT_THREE},Lorentzian.getArea=function(t,e={}){let{height:r=1}=e;return r*Math.PI*t/2},Lorentzian.getFactor=function(t=.9999){return 2*Math.tan(Math.PI*(t-.5))};class PseudoVoigt{constructor(t={}){this.mu=void 0===t.mu?.5:t.mu,this.fwhm=void 0===t.fwhm?500:t.fwhm,this.height=void 0===t.height?1/(this.mu/Math.sqrt(-GAUSSIAN_EXP_FACTOR/Math.PI)*this.fwhm+(1-this.mu)*this.fwhm*Math.PI/2):t.height}getData(t={}){let{length:e,factor:r=this.getFactor()}=t;e||(e=Math.ceil(this.fwhm*r),e%2==0&&e++);const n=(e-1)/2;let i=new Float64Array(e);for(let t=0;t<=n;t++)i[t]=this.fct(t-n)*this.height,i[e-1-t]=i[t];return i}fct(t){return PseudoVoigt.fct(t,this.fwhm,this.mu)}getFactor(t=.9999,e=this.mu){return PseudoVoigt.getFactor(t,e)}getArea(){return PseudoVoigt.getArea(this.fwhm,{height:this.height,mu:this.mu})}widthToFWHM(t,e){return PseudoVoigt.widthToFWHM(t,e)}fwhmToWidth(t=this.fwhm,e=this.mu){return PseudoVoigt.fwhmToWidth(t,e)}setFWHM(t){this.fwhm=t}setHeight(t){this.height=t}setMu(t){this.mu=t}}PseudoVoigt.fct=function(t,e,r=.5){return(1-r)*Lorentzian.fct(t,e)+r*Gaussian.fct(t,e)},PseudoVoigt.widthToFWHM=function(t,e=.5){return t*(e*ROOT_2LN2_MINUS_ONE+1)},PseudoVoigt.fwhmToWidth=function(t,e=.5){return t/(e*ROOT_2LN2_MINUS_ONE+1)},PseudoVoigt.getArea=function(t,e={}){let{height:r=1,mu:n=.5}=e;return t*r*(n*ROOT_PI_OVER_LN2+(1-n)*Math.PI)/2},PseudoVoigt.getFactor=function(t=.9999,e=.5){return e<1?Lorentzian.getFactor(t):Gaussian.getFactor(t)};let axis=["x","y"];class Gaussian2D{constructor(t={}){let{fwhm:e=500}=t;for(let r of axis){let n;n=t[r]?t[r].sd?Gaussian2D.widthToFWHM(2*t[r].sd):t[r].fwhm||e:e,this[r]={fwhm:n}}this.height=void 0===t.height?-GAUSSIAN_EXP_FACTOR/Math.PI/this.x.fwhm/this.y.fwhm:t.height}getData(t={}){let{x:e={},y:r={},factor:n=this.getFactor(),length:i}=t,o=e.length||i;if(!o){let{factor:t=n}=e;o=Math.min(Math.ceil(this.x.fwhm*t),Math.pow(2,25)-1),o%2==0&&o++}let s=r.length||i;if(!s){let{factor:t=n}=r;s=Math.min(Math.ceil(this.y.fwhm*t),Math.pow(2,25)-1),s%2==0&&s++}const a=(o-1)/2,l=(s-1)/2,h=new Array(o);for(let t=0;t<o;t++)h[t]=new Array(s);for(let t=0;t<o;t++)for(let e=0;e<s;e++)h[t][e]=this.fct(t-a,e-l)*this.height;return h}fct(t,e){return Gaussian2D.fct(t,e,this.x.fwhm,this.y.fwhm)}getFactor(t=.9999){return Gaussian2D.getFactor(t)}getVolume(){return Gaussian2D.getVolume(this.x.fwhm,this.y.fwhm,{height:this.height})}widthToFWHM(t){return Gaussian2D.widthToFWHM(t)}fwhmToWidth(t=this.x.fwhm){return Gaussian2D.fwhmToWidth(t)}setFWHM(t,e){e||(e=axis),Array.isArray(e)||(e=[e]);for(let r of e){let e=r.toLowerCase();if("y"!==e&&"x"!==e)throw new Error("axis label should be x or y");this[e].fwhm=t}}setHeight(t){this.height=t}}function getShapeGenerator(t){let{kind:e="Gaussian",options:r}=t;switch(e.toLowerCase().replace(/[^a-z^0-9]/g,"")){case"gaussian":return new Gaussian(r);case"lorentzian":return new Lorentzian(r);case"pseudovoigt":return new PseudoVoigt(r);case"gaussian2d":return new Gaussian2D(r);default:throw new Error(`Unknown kind: ${e}`)}}function SavitzkyGolay(t,e,r={}){let{windowSize:n=9,derivative:i=0,polynomial:o=3}=r;if(n%2==0||n<5||!Number.isInteger(n))throw new RangeError("Invalid window size (should be odd and at least 5 integer number)");if(n>t.length)throw new RangeError(`Window size is higher than the data length ${n}>${t.length}`);if(i<0||!Number.isInteger(i))throw new RangeError("Derivative should be a positive integer");if(o<1||!Number.isInteger(o))throw new RangeError("Polynomial should be a positive integer");o>=6&&console.warn("You should not use polynomial grade higher than 5 if you are not sure that your data arises from such a model. Possible polynomial oscillation problems");let s=Math.floor(n/2),a=t.length,l=new Array(a),h=fullWeights(n,o,i),u=0,c=!0;Array.isArray(e)?c=!1:u=Math.pow(e,i);for(let r=0;r<s;r++){let o=h[s-r-1],f=h[s+r+1],m=0,g=0;for(let e=0;e<n;e++)m+=o[e]*t[e],g+=f[e]*t[a-n+e];c?(l[s-r-1]=m/u,l[a-s+r]=g/u):(u=getHs(e,s-r-1,s,i),l[s-r-1]=m/u,u=getHs(e,a-s+r,s,i),l[a-s+r]=g/u)}let f=h[s];for(let r=n;r<=a;r++){let o=0;for(let e=0;e<n;e++)o+=f[e]*t[e+r-n];c||(u=getHs(e,r-s-1,s,i)),l[r-s-1]=o/u}return l}function getHs(t,e,r,n){let i=0,o=0;for(let n=e-r;n<e+r;n++)n>=0&&n<t.length-1&&(i+=t[n+1]-t[n],o++);return Math.pow(i/o,n)}function GramPoly(t,e,r,n){let i=0;return i=r>0?(4*r-2)/(r*(2*e-r+1))*(t*GramPoly(t,e,r-1,n)+n*GramPoly(t,e,r-1,n-1))-(r-1)*(2*e+r)/(r*(2*e-r+1))*GramPoly(t,e,r-2,n):0===r&&0===n?1:0,i}function GenFact(t,e){let r=1;if(t>=e)for(let n=t-e+1;n<=t;n++)r*=n;return r}function Weight(t,e,r,n,i){let o=0;for(let s=0;s<=n;s++)o+=(2*s+1)*(GenFact(2*r,s)/GenFact(2*r+s+1,s+1))*GramPoly(t,r,s,0)*GramPoly(e,r,s,i);return o}function fullWeights(t,e,r){let n=new Array(t),i=Math.floor(t/2);for(let o=-i;o<=i;o++){n[o+i]=new Array(t);for(let t=-i;t<=i;t++)n[o+i][t+i]=Weight(t,o,i,e,r)}return n}function gsd(t,e={}){let{noiseLevel:r,sgOptions:n={windowSize:9,polynomial:3},shape:i={},smoothY:o=!0,heightFactor:s=0,broadRatio:a=0,maxCriteria:l=!0,minMaxRatio:h=25e-5,derivativeThreshold:u=-1,realTopDetection:c=!1}=e,{y:f,x:m}=t;const g=f.slice();let d=isEqualSpaced(m);void 0===r&&(r=d?getNoiseLevel(g):0);const p={m:1,b:r};l||(p.m=-1,p.b*=-1);for(let t=0;t<g.length;t++)g[t]=p.m*g[t]-p.b;for(let t=0;t<g.length;t++)g[t]<0&&(g[t]=0);let w,x,y=g;const{windowSize:M,polynomial:v}=n;d?(o&&(y=SavitzkyGolay(g,m[1]-m[0],{windowSize:M,polynomial:v,derivative:0})),w=SavitzkyGolay(g,m[1]-m[0],{windowSize:M,polynomial:v,derivative:1}),x=SavitzkyGolay(g,m[1]-m[0],{windowSize:M,polynomial:v,derivative:2})):(o&&(y=SavitzkyGolay(g,m,{windowSize:M,polynomial:v,derivative:0})),w=SavitzkyGolay(g,m,{windowSize:M,polynomial:v,derivative:1}),x=SavitzkyGolay(g,m,{windowSize:M,polynomial:v,derivative:2}));const b=m,S=m[1]-m[0];let A=0,E=0;for(let t=0;t<y.length;t++)Math.abs(x[t])>A&&(A=Math.abs(x[t])),Math.abs(y[t])>E&&(E=Math.abs(y[t]));let R=null,N=null,$=[],k=[],T=[],C=[];for(let t=1;t<y.length-1;++t)Math.abs(w[t])>u&&((w[t]<w[t-1]&&w[t]<=w[t+1]||w[t]<=w[t-1]&&w[t]<w[t+1])&&(N={x:b[t],index:t},S>0&&null!==R&&(k.push(R),T.push(N))),(w[t]>=w[t-1]&&w[t]>w[t+1]||w[t]>w[t-1]&&w[t]>=w[t+1])&&(R={x:b[t],index:t},S<0&&null!==N&&(k.push(R),T.push(N)))),x[t]<x[t-1]&&x[t]<x[t+1]&&($.push(t),C.push(Math.abs(x[t])<=a*A));let O,I,F,L,P,D=i.kind?getShapeGenerator(i.kind,i.options).widthToFWHM:t=>t,_=[],V=-1;for(let t=0;t<$.length;++t){I=b[$[t]],O=-1;let e=V+1;for(L=Number.MAX_VALUE,F=0,P=!0;-1===O&&e<k.length&&P;)F=Math.abs(I-(k[e].x+T[e].x)/2),F<L?L=F:P=!1,F<Math.abs(k[e].x-T[e].x)/2&&(O=e,V=e),++e;if(-1!==O&&Math.abs(y[$[t]])>h*E){let e=Math.abs(T[O].x-k[O].x);if(_.push({index:$[t],x:I,y:(y[$[t]]+p.b)/p.m,width:D(e),soft:C[t]}),_[_.length-1].left=k[O],_[_.length-1].right=T[O],s){let t=y[k[O].index],e=y[T[O].index];_[_.length-1].height=s*(_[_.length-1].y-(t+e)/2)}}}c&&determineRealTop(_,b,y);for(let t=0;t<_.length;t++)_[t].base=r;return _.sort((function(t,e){return t.x-e.x})),_}Gaussian2D.fct=function(t,e,r=500,n=500){return Math.exp(GAUSSIAN_EXP_FACTOR*(Math.pow(t/r,2)+Math.pow(e/n,2)))},Gaussian2D.widthToFWHM=function(t){return t*ROOT_2LN2},Gaussian2D.fwhmToWidth=function(t){return t/ROOT_2LN2},Gaussian2D.getVolume=function(t,e,r={}){let{height:n=1}=r;return n*Math.PI*t*e/Math.LN2/4},Gaussian2D.getFactor=function(t=.9999){return Math.sqrt(2)*erfinv(t)};const isEqualSpaced=t=>{let e,r=0,n=Number.MAX_SAFE_INTEGER;for(let i=0;i<t.length-1;++i)e=Math.abs(t[i+1]-t[i]),e<n&&(n=e),e>r&&(r=e);return(r-n)/r<.05},getNoiseLevel=t=>{let e=0,r=0,n=t.length;for(let r=0;r<n;++r)e+=t[r];e/=n;let i=new Array(n);for(let r=0;r<n;++r)i[r]=Math.abs(t[r]-e);return i.sort(((t,e)=>t-e)),r=n%2==1?i[(n-1)/2]/.6745:.5*(i[n/2]+i[n/2-1])/.6745,r},determineRealTop=(t,e,r)=>{let n,i,o,s,a;for(let l=0;l<t.length;l++)a=t[l].index,r[a-1]>=r[a-2]&&r[a-1]>=r[a]?a--:r[a+1]>=r[a]&&r[a+1]>=r[a+2]?a++:r[a-2]>=r[a-3]&&r[a-2]>=r[a-1]?a-=2:r[a+2]>=r[a+1]&&r[a+2]>=r[a+3]&&(a+=2),r[a-1]>0&&r[a+1]>0&&r[a]>=r[a-1]&&r[a]>=r[a+1]&&(r[a]!==r[a-1]||r[a]!==r[a+1])&&(n=20*Math.log10(r[a-1]),i=20*Math.log10(r[a]),o=20*Math.log10(r[a+1]),s=.5*(n-o)/(n-2*i+o),t[l].x=e[a]+(e[a]-e[a-1])*s,t[l].y=r[a]-.25*(r[a-1]-r[a+1])*s)},toString=Object.prototype.toString,isEnumerable=Object.prototype.propertyIsEnumerable,getSymbols=Object.getOwnPropertySymbols;var assignSymbols=(t,...e)=>{if(!isObject(t))throw new TypeError("expected the first argument to be an object");if(0===e.length||"function"!=typeof Symbol||"function"!=typeof getSymbols)return t;for(let r of e){let e=getSymbols(r);for(let n of e)isEnumerable.call(r,n)&&(t[n]=r[n])}return t};function isObject(t){return"function"==typeof t||"[object Object]"===toString.call(t)||Array.isArray(t)}
/*!
   * assign-deep <https://github.com/jonschlinkert/assign-deep>
   *
   * Copyright (c) 2017-present, Jon Schlinkert.
   * Released under the MIT License.
   */var assignDeep=createCommonjsModule((function(t){const e=Object.prototype.toString,r=t=>"__proto__"!==t&&"constructor"!==t&&"prototype"!==t,n=t.exports=(t,...e)=>{let o=0;var s;for(("object"==typeof(s=t)?null===s:"function"!=typeof s)&&(t=e[o++]),t||(t={});o<e.length;o++)if(i(e[o])){for(const s of Object.keys(e[o]))r(s)&&(i(t[s])&&i(e[o][s])?n(t[s],e[o][s]):t[s]=e[o][s]);assignSymbols(t,e[o])}return t};function i(t){return"function"==typeof t||"[object Object]"===e.call(t)}}));function sumOfGaussianLorentzians(t){return function(e){let r=t.length/4,n=0;for(let i=0;i<r;i++)n+=t[i+r]*PseudoVoigt.fct(e-t[i],t[i+2*r],t[i+3*r]);return n}}function sumOfGaussians(t){return function(e){let r=t.length/3,n=0;for(let i=0;i<r;i++)n+=t[i+r]*Gaussian.fct(e-t[i],t[i+2*r]);return n}}function sumOfLorentzians(t){return function(e){let r=t.length/3,n=0;for(let i=0;i<r;i++)n+=t[i+r]*Lorentzian.fct(e-t[i],t[i+2*r]);return n}}function checkInput(t,e,r){let n,i,{shape:o={kind:"gaussian"},optimization:s={kind:"lm"}}=r;if("string"!=typeof o.kind)throw new Error("kind should be a string");switch(o.kind.toLowerCase().replace(/[^a-z]/g,"")){case"gaussian":n=sumOfGaussians,i={x:{init:t=>t.x,max:t=>t.x+2*t.width,min:t=>t.x-2*t.width,gradientDifference:t=>.002*t.width},y:{init:t=>t.y,max:()=>1.5,min:()=>0,gradientDifference:()=>.001},width:{init:t=>t.width,max:t=>4*t.width,min:t=>.25*t.width,gradientDifference:t=>.002*t.width}};break;case"lorentzian":n=sumOfLorentzians,i={x:{init:t=>t.x,max:t=>t.x+2*t.width,min:t=>t.x-2*t.width,gradientDifference:t=>.002*t.width},y:{init:t=>t.y,max:()=>1.5,min:()=>0,gradientDifference:()=>.001},width:{init:t=>t.width,max:t=>4*t.width,min:t=>.25*t.width,gradientDifference:t=>.002*t.width}};break;case"pseudovoigt":n=sumOfGaussianLorentzians,i={x:{init:t=>t.x,max:t=>t.x+2*t.width,min:t=>t.x-2*t.width,gradientDifference:t=>.002*t.width},y:{init:t=>t.y,max:()=>1.5,min:()=>0,gradientDifference:()=>.001},width:{init:t=>t.width,max:t=>4*t.width,min:t=>.25*t.width,gradientDifference:t=>.002*t.width},mu:{init:t=>void 0!==t.mu?t.mu:.5,min:()=>0,max:()=>1,gradientDifference:()=>.01}};break;default:throw new Error("kind of shape is not supported")}let a=t.x,l=max(t.y),h=new Array(a.length);for(let e=0;e<a.length;e++)h[e]=t.y[e]/l;for(let t=0;t<e.length;t++)e[t].y/=l;let u=assignDeep({},s.parameters,i);for(let t in u)for(let r in u[t]){if(Array.isArray(u[t][r])||(u[t][r]=[u[t][r]]),1!==u[t][r].length&&u[t][r].length!==e.length)throw new Error(`The length of ${t}-${r} is not correct`);for(let e=0;e<u[t][r].length;e++)if("number"==typeof u[t][r][e]){let n=u[t][r][e];u[t][r][e]=()=>n}}return s.parameters=u,{y:h,x:a,maxY:l,peaks:e,paramsFunc:n,optimization:s}}const LEVENBERG_MARQUARDT=1;function selectMethod(t={}){let{kind:e,options:r}=t;switch(e=getKind(e),e){case LEVENBERG_MARQUARDT:return{algorithm:levenbergMarquardt,optimizationOptions:checkOptions(e,r)};default:throw new Error("Unknown kind algorithm")}}function checkOptions(t,e={}){switch(t){case LEVENBERG_MARQUARDT:return Object.assign({},lmOptions,e)}}function getKind(t){if("string"!=typeof t)return t;switch(t.toLowerCase().replace(/[^a-z]/g,"")){case"lm":case"levenbergmarquardt":return LEVENBERG_MARQUARDT;default:throw new Error("Unknown kind algorithm")}}const lmOptions={damping:1.5,maxIterations:100,errorTolerance:1e-8};function optimize(t,e,r={}){const{y:n,x:i,maxY:o,peaks:s,paramsFunc:a,optimization:l}=checkInput(t,e,r);let h=l.parameters,u=s.length,c=Object.keys(h),f=u*c.length,m=new Float64Array(f),g=new Float64Array(f),d=new Float64Array(f),p=new Float64Array(f);for(let t=0;t<u;t++){let e=s[t];for(let r=0;r<c.length;r++){let n=c[r],i=h[n].init,o=h[n].min,s=h[n].max,a=h[n].gradientDifference;d[t+r*u]=i[t%i.length](e),m[t+r*u]=o[t%o.length](e),g[t+r*u]=s[t%s.length](e),p[t+r*u]=a[t%a.length](e)}}let{algorithm:w,optimizationOptions:x}=selectMethod(l);x.minValues=m,x.maxValues=g,x.initialValues=d,x.gradientDifference=p;let y=w({x:i,y:n},a,x),{parameterError:M,iterations:v}=y,b={error:M,iterations:v,peaks:s};for(let t=0;t<u;t++){y.parameterValues[t+u]*=o;for(let e=0;e<c.length;e++)s[t][c[e]]=y.parameterValues[t+e*u]}return b}function xFindClosestIndex(t,e){let r=0,n=t.length-1,i=0;for(;n-r>1;)if(i=r+(n-r>>1),t[i]<e)r=i;else{if(!(t[i]>e))return i;n=i}return r<t.length-1?Math.abs(e-t[r])<Math.abs(t[r+1]-e)?r:r+1:r}function xGetFromToIndex(t,e={}){let{fromIndex:r,toIndex:n,from:i,to:o}=e;return void 0===r&&(r=void 0!==i?xFindClosestIndex(t,i):0),void 0===n&&(n=void 0!==o?xFindClosestIndex(t,o):t.length-1),r>n&&([r,n]=[n,r]),{fromIndex:r,toIndex:n}}function _typeof(t){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function sequentialFill(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"!==_typeof(t)||isAnyArray(t)||(e=t,t=[]),!isAnyArray(t))throw new TypeError("input must be an array");var r=e,n=r.from,i=void 0===n?0:n,o=r.to,s=void 0===o?10:o,a=r.size,l=void 0===a?t.length:a,h=r.step;if(0!==l&&h)throw new Error("step is defined by the array size");if(l||(l=h?Math.floor((s-i)/h)+1:s-i+1),!h&&l&&(h=(s-i)/(l-1)),Array.isArray(t)){t.length=0;for(var u=0;u<l;u++)t.push(i),i+=h}else{if(t.length!==l)throw new Error("sequentialFill typed array must have the correct length");for(var c=0;c<l;c++)t[c]=i,i+=h}return t}function variance(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!isAnyArray(t))throw new TypeError("input must be an array");for(var r=e.unbiased,n=void 0===r||r,i=e.mean,o=void 0===i?mean$1(t):i,s=0,a=0;a<t.length;a++){var l=t[a]-o;s+=l*l}return n?s/(t.length-1):s/t.length}function standardDeviation(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Math.sqrt(variance(t,e))}function groupPeaks(t,e=1){if(0===t.length)return[];let r=t.sort(((t,e)=>t.x-e.x)),n={x:Number.NEGATIVE_INFINITY,width:1},i=[n],o=[];for(let t of r)(t.x-n.x)/(t.width+n.width)<=e/2?i.push(t):(i=[t],o.push(i)),t.group=o.length-1,n=t;return o}function optimizePeaks(t,e,r={}){const{factorWidth:n=1,factorLimits:i=2,shape:o={kind:"gaussian"},optimization:s={kind:"lm",options:{timeout:10}}}=r;t.x[0]>t.x[1]&&(t.x.reverse(),t.y.reverse());let a=groupPeaks(e,n),l=[];for(const e of a){const r=e[0],n=e[e.length-1],a=r.x-r.width*i,h=n.x+n.width*i,{fromIndex:u,toIndex:c}=xGetFromToIndex(t.x,{from:a,to:h}),f={x:t.x.slice(u,c),y:t.y.slice(u,c)};if(f.x.length>5){let{peaks:t}=optimize(f,e,{shape:o,optimization:s});l=l.concat(t)}else l=l.concat(e)}return l}function joinBroadPeaks(t,e={}){let{width:r=.25,shape:n={kind:"gaussian"},optimization:i={kind:"lm",timeout:10}}=e,o=[],s=0,a=0,l=1;for(let e=t.length-1;e>=0;e--)t[e].soft&&o.push(t.splice(e,1)[0]);o.push({x:Number.MAX_VALUE});let h={x:[o[0].x],y:[o[0].y]},u=[0];for(let e=1;e<o.length;e++)if(Math.abs(o[e-1].x-o[e].x)<r)h.x.push(o[e].x),h.y.push(o[e].y),o[e].y>s&&(s=o[e].y,a=e),u.push(e),l++;else{if(l>2){let e=optimize(h,[{x:o[a].x,y:s,width:Math.abs(h.x[0]-h.x[h.x.length-1])}],{shape:n,optimization:i}),{peaks:r}=e;r[0].index=Math.floor(u.reduce(((t,e)=>t+e),0)/u.length),r[0].soft=!1,t.push(r[0])}else u.forEach((e=>{t.push(o[e])}));h={x:[o[e].x],y:[o[e].y]},u=[e],s=o[e].y,a=e,l=1}return t.sort((function(t,e){return t.x-e.x})),t}function broadenPeaks(t,e={}){const{factor:r=2,overlap:n=!1}=e;for(let e of t)e.right&&e.left?(e.from=e.x-(e.x-e.left.x)*r,e.to=e.x+(e.right.x-e.x)*r):(e.from=e.x-e.width/2*r,e.to=e.x+e.width/2*r);if(!n)for(let e=0;e<t.length-1;e++){let r=t[e],n=t[e+1];r.to>n.from&&(r.to=n.from=(r.to+n.from)/2)}for(let e of t)e.width=e.to-e.from;return t}var index=Object.freeze({__proto__:null,gsd:gsd,optimizePeaks:optimizePeaks,joinBroadPeaks:joinBroadPeaks,broadenPeaks:broadenPeaks});function mode(t){if(!isAnyArray(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=0,r=0,n=0,i={},o=0;o<t.length;++o){var s=t[o];(n=i[s])?(i[s]++,n++):i[s]=n=1,n>r&&(r=n,e=t[o])}return e}function norm(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=r.algorithm,i=void 0===n?"absolute":n,o=r.sumValue,s=void 0===o?1:o,a=r.maxValue,l=void 0===a?1:a;if(!isAnyArray(t))throw new Error("input must be an array");if(void 0!==r.output){if(!isAnyArray(r.output))throw new TypeError("output option must be an array if specified");e=r.output}else e=new Array(t.length);if(0===t.length)throw new Error("input must not be empty");switch(i.toLowerCase()){case"absolute":var h=absoluteSum(t)/s;if(0===h)return t.slice(0);for(var u=0;u<t.length;u++)e[u]=t[u]/h;return e;case"max":var c=max(t);if(0===c)return t.slice(0);for(var f=l/c,m=0;m<t.length;m++)e[m]=t[m]*f;return e;case"sum":var g=sum(t)/s;if(0===g)return t.slice(0);for(var d=0;d<t.length;d++)e[d]=t[d]/g;return e;default:throw new Error("norm: unknown algorithm: ".concat(i))}}function absoluteSum(t){for(var e=0,r=0;r<t.length;r++)e+=Math.abs(t[r]);return e}function mergeByCentroids(t,e,r={}){const{window:n=.01}=r;let i={x:e.slice(),y:new Array(e.length).fill(0)},o=0,s=0;for(;o<t.x.length&&s<e.length;){let r=t.x[o]-e[s];Math.abs(r)<n?i.y[s]+=t.y[o++]:r<0?o++:s++}return i}function assertNumber$1(t){if("number"!=typeof t)throw new TypeError("Expected a number")}var ascending$1=(t,e)=>(assertNumber$1(t),assertNumber$1(e),Number.isNaN(t)?-1:Number.isNaN(e)?1:t-e),descending$1=(t,e)=>(assertNumber$1(t),assertNumber$1(e),Number.isNaN(t)?1:Number.isNaN(e)?-1:e-t);function closestX(t,e){const{x:r,y:n}=t,{target:i=r[0],reverse:o=!1}=e;let s;return s=binarySearch(r,i,o?descending$1:ascending$1),s>=0?{x:r[s],y:n[s]}:(s=~s,0!==s&&Math.abs(r[s]-i)>.5||s===r.length?{x:r[s-1],y:n[s-1]}:{x:r[s],y:n[s]})}function covariance(t,e={}){const{x:r,y:n}=t,{unbiased:i=!0}=e,o=mean$1(r),s=mean$1(n);let a=0;for(let t=0;t<r.length;t++)a+=(r[t]-o)*(n[t]-s);return i?a/(r.length-1):a/r.length}function maxMerge(t,e={}){const{x:r,y:n}=t,{groupWidth:i=.001}=e;let o={x:[],y:[]},s={x:[],y:[]},a=0,l=0;for(;l<r.length;)0===a||r[l]-o.x[a-1]>i?(s.x.push(r[l]),s.y.push(n[l]),o.x.push(r[l]),o.y.push(n[l]),l++,a++):(n[l]>s.y[a-1]&&(s.x[a-1]=r[l],s.y[a-1]=n[l]),o.x[a-1]=r[l],o.y[a-1]+=n[l],l++);return o.x=s.x.slice(),o}function assertNumber(t){if("number"!=typeof t)throw new TypeError("Expected a number")}var ascending=(t,e)=>(assertNumber(t),assertNumber(e),Number.isNaN(t)?-1:Number.isNaN(e)?1:t-e),descending=(t,e)=>(assertNumber(t),assertNumber(e),Number.isNaN(t)?1:Number.isNaN(e)?-1:e-t);function maxY(t,e={}){const{x:r,y:n}=t;let{from:i={index:0},to:o={index:r.length},reverse:s=!1}=e;void 0!==i.value&&void 0===i.index&&(i.index=calculateIndex(i.value,r,s)),void 0!==o.value&&void 0===o.index&&(o.index=calculateIndex(o.value,r,s));let a,l=Number.MIN_VALUE;for(let t=i.index;t<o.index;t++)l<n[t]&&(l=n[t],a=t);return{index:a,value:l}}function calculateIndex(t,e,r){let n;if(n=binarySearch(e,t,r?descending:ascending),n<0)throw new Error(`the value ${t} doesn't belongs to the abscissa value`);return n}function sortX(t,e={}){const{x:r,y:n}=t,{reverse:i=!1}=e;let o;o=i?(t,e)=>e.x-t.x:(t,e)=>t.x-e.x;let s=r.map(((t,e)=>({x:t,y:n[e]}))).sort(o),a={x:r.slice(),y:n.slice()};for(let t=0;t<r.length;t++)a.x[t]=s[t].x,a.y[t]=s[t].y;return a}function uniqueX(t={}){const{x:e,y:r}=t;if(e.length<2)return;if(e.length!==r.length)throw new Error("The X and Y arrays mush have the same length");let n=e[0],i=0;for(let t=1;t<e.length;t++)n!==e[t]&&(i++,n=e[t],e[i]=e[t],t!==i&&(r[i]=0)),t!==i&&(r[i]+=r[t]);e.length=i+1,r.length=i+1}function weightedMerge(t,e={}){const{x:r,y:n}=t,{groupWidth:i=.001}=e;let o={x:[],y:[]},s={x:[],y:[]},a=0,l=0;for(;l<r.length;)0===a||r[l]-o.x[a-1]>i?(s.x.push(r[l]*n[l]),s.y.push(n[l]),o.x.push(r[l]),o.y.push(n[l]),l++,a++):(s.x[a-1]+=r[l]*n[l],s.y[a-1]+=n[l],o.x[a-1]=r[l],o.y[a-1]+=n[l],l++);for(let t=0;t<o.x.length;t++)o.x[t]=s.x[t]/s.y[t];return o}function normalize(t=[],e={}){if(0===t.length)return[];let{from:r=Number.NEGATIVE_INFINITY,to:n=Number.POSITIVE_INFINITY}=e;if(r>n&&([r,n]=[n,r]),(t=(t=JSON.parse(JSON.stringify(t)).map((t=>t.from>t.to?{from:t.to,to:t.from}:t))).sort(((t,e)=>t.from!==e.from?t.from-e.from:t.to-e.to))).forEach((t=>{r>t.from&&(t.from=r),n<t.to&&(t.to=n)})),0===(t=t.filter((t=>t.from<=t.to))).length)return[];let i=t[0],o=[i];for(let e=1;e<t.length;e++){let r=t[e];r.from<=i.to?i.to=r.to:(i=r,o.push(i))}return o}function invert(t=[],e={}){let{from:r=Number.NEGATIVE_INFINITY,to:n=Number.POSITIVE_INFINITY}=e;if(r>n&&([r,n]=[n,r]),0===(t=normalize(t,{from:r,to:n})).length)return[{from:r,to:n}];let i=[];for(let e=0;e<t.length;e++){let o=t[e],s=t[e+1];0===e&&o.from>r&&i.push({from:r,to:o.from}),e===t.length-1?o.to<n&&i.push({from:o.to,to:n}):i.push({from:o.to,to:s.from})}return i}function zonesWithPoints(t,e,r={}){if(0===t.length)return t;let n=(t=normalize(t,r)).reduce(((t,e)=>t+(e.to-e.from)),0)/e,i=0;for(let r=0;r<t.length-1;r++){let o=t[r];o.numberOfPoints=Math.min(Math.round((o.to-o.from)/n),e-i),i+=o.numberOfPoints}return t[t.length-1].numberOfPoints=e-i,t}function equallySpacedSlot(t,e,r,n,i){let o=t.length,s=(n-r)/(i>1?i-1:1),a=s/2,l=t[t.length-1]-t[t.length-2],h=r-a,u=new Array(i),c=h,f=h+s,m=-Number.MAX_VALUE,g=0,d=t[0],p=e[0],w=0,x=!0,y=0,M=0,v=1,b=0;t:for(;;){if(m>=d)throw new Error("x must be an increasing serie");for(;m-f>0;){if(x&&(M++,x=!1),u[b]=M<=0?0:y/M,b++,b===i)break t;c=f,f+=s,y=0,M=0}m>c&&(y+=g,M++),(m===-Number.MAX_VALUE||w>1)&&M--,m=d,g=p,v<o?(d=t[v],p=e[v],v++):(d+=l,p=0,w++)}return u}function integral(t,e,r,n){return.5*r*e*e+n*e-(.5*r*t*t+n*t)}function equallySpacedSmooth(t,e,r,n,i){let o=t.length,s=(n-r)/(i>1?i-1:1),a=s/2,l=new Array(i),h=t[1]-t[0],u=t[o-1]-t[o-2],c=r-a,f=r+a,m=Number.MIN_VALUE,g=0,d=t[0]-h,p=0,w=0,x=0,y=0,M=0,v=0,b=0,S=0;let A=0;t:for(;;){for(m<=c&&c<=d&&(A=integral(0,c-m,x,g),M=w+A);d-f>=0;){if(A=integral(0,f-m,x,g),v=w+A,l[S++]=(v-M)/s,S===i)break t;c=f,f+=s,M=v}w+=integral(m,d,x,y),m=d,g=p,b<o?(d=t[b],p=e[b],b++):b===o&&(d+=u,p=0),x=(p-g)/(d-m),y=-x*m+g}return l}function equallySpaced(t={},e={}){let{x:r,y:n}=t,i=r.length,o=!1;r.length>1&&r[0]>r[1]&&(r=r.slice().reverse(),n=n.slice().reverse(),o=!0);let{from:s=r[0],to:a=r[i-1],variant:l="smooth",numberOfPoints:h=100,exclusions:u=[],zones:c=[]}=e;if(i!==n.length)throw new RangeError("the x and y vector doesn't have the same size.");if("number"!=typeof s||isNaN(s))throw new RangeError("'from' option must be a number");if("number"!=typeof a||isNaN(a))throw new RangeError("'to' option must be a number");if("number"!=typeof h||isNaN(h))throw new RangeError("'numberOfPoints' option must be a number");if(h<2)throw new RangeError("'numberOfPoints' option must be greater than 1");0===c.length&&(c=invert(u,{from:s,to:a})),c=zonesWithPoints(c,h,{from:s,to:a});let f=[],m=[];for(let t of c){let e=processZone(r,n,t.from,t.to,t.numberOfPoints,l);f=f.concat(e.x),m=m.concat(e.y)}return o?s<a?{x:f.reverse(),y:m.reverse()}:{x:f,y:m}:s<a?{x:f,y:m}:{x:f.reverse(),y:m.reverse()}}function processZone(t,e,r,n,i,o){if(i<1)throw new RangeError("the number of points must be at least 1");let s="slot"===o?equallySpacedSlot(t,e,r,n,i):equallySpacedSmooth(t,e,r,n,i);return{x:sequentialFill({from:r,to:n,size:i}),y:s}}function getZones(t,e,r=[]){t>e&&([t,e]=[e,t]),r=r.filter((t=>void 0!==t.from&&void 0!==t.to)),(r=JSON.parse(JSON.stringify(r))).forEach((t=>{t.from>t.to&&([t.to,t.from]=[t.from,t.to])})),r.sort(((t,e)=>t.from-e.from)),r.forEach((r=>{r.from<t&&(r.from=t),r.to>e&&(r.to=e)}));for(let t=0;t<r.length-1;t++)r[t].to>r[t+1].from&&(r[t].to=r[t+1].from);if(!(r=r.filter((t=>t.from<t.to)))||0===r.length)return[{from:t,to:e}];let n=[],i=t;for(let t of r)i<t.from&&n.push({from:i,to:t.from}),i=t.to;return i<e&&n.push({from:i,to:e}),n}function filterX(t,e={}){const{x:r,y:n}=t,{from:i=r[0],to:o=r[r.length-1],exclusions:s=[]}=e;let a=getZones(i,o,s),l=0,h=[],u=[],c=0;for(;c<r.length;){if(r[c]<=a[l].to&&r[c]>=a[l].from)h.push(r[c]),u.push(n[c]);else if(r[c]>a[l].to&&(l++,!a[l]))break;c++}return{x:h,y:u}}const{Matrix:Matrix,SVD:SVD,EVD:EVD,CholeskyDecomposition:CholeskyDecomposition,LuDecomposition:LuDecomposition,QrDecomposition:QrDecomposition}=MatrixLib,Array$1={min:min,max:max,median:median,mean:mean$1,mode:mode,normed:norm,rescale:rescale,sequentialFill:sequentialFill,standardDeviation:standardDeviation,sum:sum,variance:variance},ArrayXY={centroidsMerge:mergeByCentroids,closestX:closestX,covariance:covariance,maxMerge:maxMerge,maxY:maxY,sortX:sortX,uniqueX:uniqueX,weightedMerge:weightedMerge,equallySpaced:equallySpaced,filterX:filterX};exports.Array=Array$1,exports.ArrayXY=ArrayXY,exports.BitArray=src,exports.CholeskyDecomposition=CholeskyDecomposition,exports.ConfusionMatrix=ConfusionMatrix,exports.CrossValidation=index$3,exports.DecisionTreeClassifier=DecisionTreeClassifier,exports.DecisionTreeRegression=DecisionTreeRegression,exports.Distance=distances,exports.EVD=EVD,exports.ExponentialRegression=ExponentialRegression,exports.FCNNLS=index$2,exports.FNN=FeedForwardNeuralNetwork,exports.GSD=index,exports.HClust=index$5,exports.HashTable=HashTable,exports.KMeans=kmeans,exports.KNN=KNN,exports.KOPLS=KOPLS,exports.Kernel=kernel,exports.LuDecomposition=LuDecomposition,exports.Matrix=Matrix,exports.MatrixLib=MatrixLib,exports.MultivariateLinearRegression=MultivariateLinearRegression,exports.NaiveBayes=index$4,exports.OPLS=OPLS,exports.OPLSNipals=OPLSNipals,exports.PCA=PCA,exports.PLS=PLS,exports.Performance=src$2,exports.PolynomialRegression=PolynomialRegression,exports.PowerRegression=PowerRegression,exports.QrDecomposition=QrDecomposition,exports.Random=Random,exports.RandomForestClassifier=RandomForestClassifier,exports.RandomForestRegression=RandomForestRegression,exports.RobustPolynomialRegression=RobustPolynomialRegression,exports.SOM=src$3,exports.SVD=SVD,exports.Similarity=similarities,exports.SimpleLinearRegression=SimpleLinearRegression,exports.SparseMatrix=SparseMatrix,exports.TheilSenRegression=TheilSenRegression,exports.XSadd=XSadd,exports.binarySearch=binarySearch,exports.distanceMatrix=distanceMatrix,exports.levenbergMarquardt=levenbergMarquardt,exports.nGMCA=nGMCA,exports.padArray=src$1,exports.savitzkyGolay=savitzkyGolay,Object.defineProperty(exports,"__esModule",{value:!0})}));
//# sourceMappingURL=ml.min.js.map
