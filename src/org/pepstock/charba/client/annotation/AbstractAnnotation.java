/**
    Copyright 2017 Andrea "Stock" Stocchero

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

	    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
package org.pepstock.charba.client.annotation;

import java.util.concurrent.atomic.AtomicInteger;

import org.pepstock.charba.client.IsChart;
import org.pepstock.charba.client.annotation.enums.DrawTime;
import org.pepstock.charba.client.annotation.listeners.ClickCallback;
import org.pepstock.charba.client.annotation.listeners.DoubleClickCallback;
import org.pepstock.charba.client.annotation.listeners.EnterCallback;
import org.pepstock.charba.client.annotation.listeners.LeaveCallback;
import org.pepstock.charba.client.colors.ColorBuilder;
import org.pepstock.charba.client.colors.IsColor;
import org.pepstock.charba.client.commons.CallbackProxy;
import org.pepstock.charba.client.commons.JsHelper;
import org.pepstock.charba.client.commons.Key;
import org.pepstock.charba.client.commons.NativeObject;
import org.pepstock.charba.client.commons.NativeObjectContainer;
import org.pepstock.charba.client.dom.BaseNativeEvent;
import org.pepstock.charba.client.items.UndefinedValues;

import jsinterop.annotations.JsFunction;

/**
 * Base class to define an annotation into {@link AnnotationPlugin#ID} plugin.<br>
 * It contains all commons properties to define an annotation ({@link BoxAnnotation} or {@link LineAnnotation}.
 * 
 * @author Andrea "Stock" Stocchero
 *
 */
public abstract class AbstractAnnotation extends NativeObjectContainer implements IsDefaultsAnnotation {

	/**
	 * Default annotation display, <b>{@value DEFAULT_DISPLAY}</b>.
	 */
	public static final boolean DEFAULT_DISPLAY = true;
	// internal count
	private static final AtomicInteger COUNTER = new AtomicInteger(0);
	// exception pattern when the scale or scales methods is invoked and the scale type is not correct
	static final String INVALID_DEFAULTS_VALUES_CLASS = "Defaults options are not invalid because is not a {0} annotation defaults";

	/**
	 * Java script FUNCTION callback called to provide events generated by annotations.
	 * 
	 * @author Andrea "Stock" Stocchero
	 */
	@JsFunction
	interface ProxyHandlerCallback {

		/**
		 * Method of function to be called to provide events generated by annotations.
		 * 
		 * @param context context value of <code>this</code> to the execution context of function
		 * @param event native event generated by annotation
		 */
		void call(NativeObject context, BaseNativeEvent event);
	}

	/**
	 * Name of properties of native object.
	 */
	enum Property implements Key
	{
		TYPE("type"),
		ID("id"),
		DISPLAY("display"),
		BORDER_COLOR("borderColor"),
		BORDER_WIDTH("borderWidth"),
		ON_ENTER("enter"),
		ON_LEAVE("leave"),
		ON_CLICK("click"),
		ON_DOUBLE_CLICK("dblclick"),
		// internal property to set an unique id for caching
		CHARBA_ANNOTATION_ID("_charbaAnnotationId");

		// name value of property
		private final String value;
		//

		/**
		 * Creates with the property value to use into native object.
		 * 
		 * @param value value of property name
		 */
		private Property(String value) {
			this.value = value;
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see org.pepstock.charba.client.commons.Key#value()
		 */
		@Override
		public String value() {
			return value;
		}

	}

	// ---------------------------
	// -- CALLBACKS PROXIES ---
	// ---------------------------
	// callback proxy to invoke the ENTER function
	private final CallbackProxy<ProxyHandlerCallback> enterCallbackProxy = JsHelper.get().newCallbackProxy();
	// callback proxy to invoke the LEAVE function
	private final CallbackProxy<ProxyHandlerCallback> leaveCallbackProxy = JsHelper.get().newCallbackProxy();
	// callback proxy to invoke the CLICK function
	private final CallbackProxy<ProxyHandlerCallback> clickCallbackProxy = JsHelper.get().newCallbackProxy();
	// callback proxy to invoke the CLICK function
	private final CallbackProxy<ProxyHandlerCallback> dblclickCallbackProxy = JsHelper.get().newCallbackProxy();
	// callback instance to handle enter event
	private EnterCallback enterCallback = null;
	// callback instance to handle leave event
	private LeaveCallback leaveCallback = null;
	// callback instance to handle click event
	private ClickCallback clickCallback = null;
	// callback instance to handle dblclick event
	private DoubleClickCallback dblclickCallback = null;

	private final IsDefaultsAnnotation defaultValues;
	// draw time instance set at plugin startup
	private DrawTime defaultDrawTime = null;

	/**
	 * Creates the object with the type of annotation to handle.
	 * 
	 * @param type annotation type
	 * @param id annotation id
	 * @param defaultValues default options instance
	 */
	AbstractAnnotation(AnnotationType type, IsAnnotationId id, IsDefaultsAnnotation defaultValues) {
		this(null, defaultValues);
		// checks if is is consistent
		IsAnnotationId.checkIfValid(id);
		// checks if type is consistent
		Key.checkIfValid(type);
		// stores id
		setValue(Property.ID, id);
		// stores type
		setValue(Property.TYPE, type);
		// stores the internal id for caching
		setValue(Property.CHARBA_ANNOTATION_ID, COUNTER.getAndIncrement());
		// cached it
		AnnotationHelper.get().addAnnotation(this);
		// -------------------------------
		// -- SET CALLBACKS to PROXIES ---
		// -------------------------------
		// sets proxy handler to callback proxy to invoke the ENTER function
		enterCallbackProxy.setCallback(this::onenter);
		// sets proxy handler to callback proxy to invoke the LEAVE function
		leaveCallbackProxy.setCallback(this::onleave);
		// sets proxy handler to callback proxy to invoke the CLICK function
		clickCallbackProxy.setCallback(this::onClick);
		// sets proxy handler to callback proxy to invoke the DBLCLICK function
		dblclickCallbackProxy.setCallback(this::onDblclick);
	}

	/**
	 * Creates the object wrapping an existing native object. <b>PAY ATTENTION</b>: this constructor is invoked from plugin before starting drawing and NOT for configuration.
	 * 
	 * @param nativeObject native object to wrap
	 * @param defaultValues default options instance
	 */
	AbstractAnnotation(NativeObject nativeObject, IsDefaultsAnnotation defaultValues) {
		super(nativeObject);
		// checks if default value is consistent
		// stores default options
		this.defaultValues = checkDefaultValuesArgument(defaultValues);
	}

	/**
	 * Returns the defaults values for this object.
	 * 
	 * @return the defaults values for this object
	 */
	final IsDefaultsAnnotation getDefaultsValues() {
		return defaultValues;
	}

	/**
	 * Returns the id of annotation for caching (internal).
	 * 
	 * @return the id of annotation for caching (internal)
	 */
	final int getAnnotationId() {
		return getValue(Property.CHARBA_ANNOTATION_ID, UndefinedValues.INTEGER);
	}

	/**
	 * Returns the id of annotation.
	 * 
	 * @return the id of annotation
	 */
	public final IsAnnotationId getId() {
		return IsAnnotationId.create(getValue(Property.ID, UndefinedValues.STRING));
	}

	/**
	 * Returns the type of annotation.
	 * 
	 * @return the type of annotation
	 */
	@Override
	public final AnnotationType getType() {
		return getValue(Property.TYPE, AnnotationType.values(), defaultValues.getType());
	}

	/**
	 * Sets <code>true</code> whether the annotation should be displayed.
	 * 
	 * @param enabled <code>true</code> whether the annotation should be displayed
	 */
	public final void setDisplay(boolean enabled) {
		setValue(Property.DISPLAY, enabled);
	}

	/**
	 * Returns <code>true</code> whether the annotation should be displayed.
	 * 
	 * @return <code>true</code> whether the annotation should be displayed
	 */
	@Override
	public final boolean isDisplay() {
		return getValue(Property.DISPLAY, defaultValues.isDisplay());
	}

	/**
	 * Sets the draw time defined as default into options as top level.
	 * 
	 * @param drawTime the draw time defined as default into options as top level
	 */
	final void setDefaultDrawTime(DrawTime drawTime) {
		this.defaultDrawTime = drawTime;
	}

	/**
	 * Sets the draw time which defines when the annotations are drawn.
	 * 
	 * @param drawTime the draw time which defines when the annotations are drawn
	 */
	public final void setDrawTime(DrawTime drawTime) {
		setValue(AnnotationOptions.Property.DRAW_TIME, drawTime);
	}

	/**
	 * Returns the draw time which defines when the annotations are drawn.
	 * 
	 * @return the draw time which defines when the annotations are drawn
	 */
	@Override
	public final DrawTime getDrawTime() {
		return getValue(AnnotationOptions.Property.DRAW_TIME, DrawTime.values(), defaultDrawTime != null ? defaultDrawTime : defaultValues.getDrawTime());
	}

	/**
	 * Sets the color of the border of annotation.
	 * 
	 * @param borderColor the color of the border of annotation
	 */
	public final void setBorderColor(IsColor borderColor) {
		setBorderColor(IsColor.checkAndGetValue(borderColor));
	}

	/**
	 * Sets the color of the border of annotation.
	 * 
	 * @param borderColor the color of the border of annotation
	 */
	public final void setBorderColor(String borderColor) {
		setValue(Property.BORDER_COLOR, borderColor);
	}

	/**
	 * Returns the color of the border of annotation.
	 * 
	 * @return the color of the border of annotation
	 */
	public final IsColor getBorderColor() {
		return ColorBuilder.parse(getBorderColorAsString());
	}

	/**
	 * Sets the width of the border in pixels.
	 * 
	 * @param borderWidth the width of the border in pixels.
	 */
	public final void setBorderWidth(int borderWidth) {
		setValue(Property.BORDER_WIDTH, borderWidth);
	}

	/**
	 * Returns the callback called when a "enter" event is occurring.
	 * 
	 * @return the callback called when a "enter" event is occurring
	 */
	public final EnterCallback getEnterCallback() {
		return enterCallback;
	}

	/**
	 * Sets the callback called when a "enter" event is occurring.
	 * 
	 * @param enterCallback the callback called when a "enter" event is occurring
	 */
	public final void setEnterCallback(EnterCallback enterCallback) {
		// sets enter callback
		this.enterCallback = enterCallback;
		// checks if callback is consistent
		if (enterCallback != null) {
			// adds the callback proxy function to java script object
			setValue(Property.ON_ENTER, enterCallbackProxy.getProxy());
		} else {
			// otherwise sets null which removes the properties from java script object
			remove(Property.ON_ENTER);
		}
	}

	/**
	 * Returns the callback called when a "leave" event is occurring.
	 * 
	 * @return the callback called when a "leave" event is occurring
	 */
	public final LeaveCallback getLeaveCallback() {
		return leaveCallback;
	}

	/**
	 * Sets the callback called when a "leave" event is occurring.
	 * 
	 * @param leaveCallback the callback called when a "leave" event is occurring
	 */
	public final void setLeaveCallback(LeaveCallback leaveCallback) {
		// sets leave callback
		this.leaveCallback = leaveCallback;
		// checks if callback is consistent
		if (leaveCallback != null) {
			// adds the callback proxy function to java script object
			setValue(Property.ON_LEAVE, leaveCallbackProxy.getProxy());
		} else {
			// otherwise sets null which removes the properties from java script object
			remove(Property.ON_LEAVE);
		}
	}

	/**
	 * Returns the callback called when a "click" event is occurring.
	 * 
	 * @return the callback called when a "click" event is occurring
	 */
	public final ClickCallback getClickCallback() {
		return clickCallback;
	}

	/**
	 * Sets the callback called when a "click" event is occurring.
	 * 
	 * @param clickCallback the callback called when a "click" event is occurring
	 */
	public final void setClickCallback(ClickCallback clickCallback) {
		// sets click callback
		this.clickCallback = clickCallback;
		// checks if callback is consistent
		if (clickCallback != null) {
			// adds the callback proxy function to java script object
			setValue(Property.ON_CLICK, clickCallbackProxy.getProxy());
		} else {
			// otherwise sets null which removes the properties from java script object
			remove(Property.ON_CLICK);
		}
	}

	/**
	 * Returns the callback called when a "dblclick" event is occurring.
	 * 
	 * @return the callback called when a "dblclick" event is occurring
	 */
	public final DoubleClickCallback getDoubleClickCallback() {
		return dblclickCallback;
	}

	/**
	 * Sets the callback called when a "dblclick" event is occurring.
	 * 
	 * @param dblclickCallback the callback called when a "dblclick" event is occurring
	 */
	public final void setDoubleClickCallback(DoubleClickCallback dblclickCallback) {
		// sets dblclick callback
		this.dblclickCallback = dblclickCallback;
		// checks if callback is consistent
		if (dblclickCallback != null) {
			// adds the callback proxy function to java script object
			setValue(Property.ON_DOUBLE_CLICK, dblclickCallbackProxy.getProxy());
		} else {
			// otherwise sets null which removes the properties from java script object
			remove(Property.ON_DOUBLE_CLICK);
		}
	}

	/**
	 * Manages the ENTER event invoking the callback is exists.
	 * 
	 * @param context value of <code>this</code> to the execution context of function
	 * @param event native event generated by annotation
	 */
	private void onenter(NativeObject context, BaseNativeEvent event) {
		// creates a context wrapper
		Context internalContext = new Context(context);
		// gets chart instance from function context
		IsChart chart = internalContext.getChart();
		// checks if chart, event and callback are consistent
		if (IsChart.isValid(chart) && event != null && enterCallback != null) {
			// invokes callback
			enterCallback.onEnter(chart, event, this);
		}
	}

	/**
	 * Manages the LEAVE event firing an annotation event.
	 * 
	 * @param context value of <code>this</code> to the execution context of function
	 * @param event native event generated by annotation
	 */
	private void onleave(NativeObject context, BaseNativeEvent event) {
		// creates a context wrapper
		Context internalContext = new Context(context);
		// gets chart instance from function context
		IsChart chart = internalContext.getChart();
		// checks if chart is consistent
		if (IsChart.isValid(chart) && event != null && leaveCallback != null) {
			// invokes callback
			leaveCallback.onLeave(chart, event, this);
		}
	}

	/**
	 * Manages the CLICK event firing an annotation event.
	 * 
	 * @param context value of <code>this</code> to the execution context of function
	 * @param event native event generated by annotation
	 */
	private void onClick(NativeObject context, BaseNativeEvent event) {
		// creates a context wrapper
		Context internalContext = new Context(context);
		// gets chart instance from function context
		IsChart chart = internalContext.getChart();
		// checks if chart is consistent
		if (IsChart.isValid(chart) && event != null && clickCallback != null) {
			// invokes callback
			clickCallback.onClick(chart, event, this);
		}
	}

	/**
	 * Manages the DBLCLICK event firing an annotation event.
	 * 
	 * @param context value of <code>this</code> to the execution context of function
	 * @param event native event generated by annotation
	 */
	private void onDblclick(NativeObject context, BaseNativeEvent event) {
		// creates a context wrapper
		Context internalContext = new Context(context);
		// gets chart instance from function context
		IsChart chart = internalContext.getChart();
		// checks if chart is consistent
		if (IsChart.isValid(chart) && event != null && dblclickCallback != null) {
			// invokes callback
			dblclickCallback.onDoubleClick(chart, event, this);
		}
	}

}
